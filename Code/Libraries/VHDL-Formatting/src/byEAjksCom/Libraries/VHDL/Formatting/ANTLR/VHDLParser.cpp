
// Generated from
// /home/k8sadmin/Repositories/hdl-design-tools/Resources/Grammars/VHDL/VHDL.g4
// by ANTLR 4.13.2

#include "VHDLListener.h"
#include "VHDLVisitor.h"

#include "VHDLParser.h"

using namespace antlrcpp;
using namespace byEAjksCom::Libraries::VHDL::Formatting::ANTLR;

using namespace antlr4;

namespace
{

struct VHDLParserStaticData final
{
    VHDLParserStaticData(std::vector<std::string> ruleNames, std::vector<std::string> literalNames, std::vector<std::string> symbolicNames)
        : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)), symbolicNames(std::move(symbolicNames)), vocabulary(this->literalNames, this->symbolicNames)
    {
    }

    VHDLParserStaticData(const VHDLParserStaticData &) = delete;
    VHDLParserStaticData(VHDLParserStaticData &&) = delete;
    VHDLParserStaticData &operator=(const VHDLParserStaticData &) = delete;
    VHDLParserStaticData &operator=(VHDLParserStaticData &&) = delete;

    std::vector<antlr4::dfa::DFA> decisionToDFA;
    antlr4::atn::PredictionContextCache sharedContextCache;
    const std::vector<std::string> ruleNames;
    const std::vector<std::string> literalNames;
    const std::vector<std::string> symbolicNames;
    const antlr4::dfa::Vocabulary vocabulary;
    antlr4::atn::SerializedATNView serializedATN;
    std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag vhdlParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
    std::unique_ptr<VHDLParserStaticData>
        vhdlParserStaticData = nullptr;

void vhdlParserInitialize()
{
#if ANTLR4_USE_THREAD_LOCAL_CACHE
    if (vhdlParserStaticData != nullptr)
    {
        return;
    }
#else
    assert(vhdlParserStaticData == nullptr);
#endif
    auto staticData = std::make_unique<VHDLParserStaticData>(std::vector<std::string>{"abstract_literal",
                                                                                      "access_type_definition",
                                                                                      "across_aspect",
                                                                                      "actual_designator",
                                                                                      "actual_parameter_part",
                                                                                      "actual_part",
                                                                                      "adding_operator",
                                                                                      "aggregate",
                                                                                      "alias_declaration",
                                                                                      "alias_designator",
                                                                                      "alias_indication",
                                                                                      "allocator",
                                                                                      "architecture_body",
                                                                                      "architecture_declarative_part",
                                                                                      "architecture_statement",
                                                                                      "architecture_statement_part",
                                                                                      "array_nature_definition",
                                                                                      "array_type_definition",
                                                                                      "assertion",
                                                                                      "assertion_statement",
                                                                                      "association_element",
                                                                                      "association_list",
                                                                                      "attribute_declaration",
                                                                                      "attribute_designator",
                                                                                      "attribute_specification",
                                                                                      "base_unit_declaration",
                                                                                      "binding_indication",
                                                                                      "block_configuration",
                                                                                      "block_declarative_item",
                                                                                      "block_declarative_part",
                                                                                      "block_header",
                                                                                      "block_specification",
                                                                                      "block_statement",
                                                                                      "block_statement_part",
                                                                                      "branch_quantity_declaration",
                                                                                      "break_element",
                                                                                      "break_list",
                                                                                      "break_selector_clause",
                                                                                      "break_statement",
                                                                                      "case_statement",
                                                                                      "case_statement_alternative",
                                                                                      "choice",
                                                                                      "choices",
                                                                                      "component_configuration",
                                                                                      "component_declaration",
                                                                                      "component_instantiation_statement",
                                                                                      "component_specification",
                                                                                      "composite_nature_definition",
                                                                                      "composite_type_definition",
                                                                                      "concurrent_assertion_statement",
                                                                                      "concurrent_break_statement",
                                                                                      "concurrent_procedure_call_statement",
                                                                                      "concurrent_signal_assignment_statement",
                                                                                      "condition",
                                                                                      "condition_clause",
                                                                                      "conditional_signal_assignment",
                                                                                      "conditional_waveforms",
                                                                                      "configuration_declaration",
                                                                                      "configuration_declarative_item",
                                                                                      "configuration_declarative_part",
                                                                                      "configuration_item",
                                                                                      "configuration_specification",
                                                                                      "constant_declaration",
                                                                                      "constrained_array_definition",
                                                                                      "constrained_nature_definition",
                                                                                      "constraint",
                                                                                      "context_clause",
                                                                                      "context_item",
                                                                                      "delay_mechanism",
                                                                                      "design_file",
                                                                                      "design_unit",
                                                                                      "designator",
                                                                                      "direction",
                                                                                      "disconnection_specification",
                                                                                      "discrete_range",
                                                                                      "element_association",
                                                                                      "element_declaration",
                                                                                      "element_subnature_definition",
                                                                                      "element_subtype_definition",
                                                                                      "entity_aspect",
                                                                                      "entity_class",
                                                                                      "entity_class_entry",
                                                                                      "entity_class_entry_list",
                                                                                      "entity_declaration",
                                                                                      "entity_declarative_item",
                                                                                      "entity_declarative_part",
                                                                                      "entity_designator",
                                                                                      "entity_header",
                                                                                      "entity_name_list",
                                                                                      "entity_specification",
                                                                                      "entity_statement",
                                                                                      "entity_statement_part",
                                                                                      "entity_tag",
                                                                                      "enumeration_literal",
                                                                                      "enumeration_type_definition",
                                                                                      "exit_statement",
                                                                                      "expression",
                                                                                      "factor",
                                                                                      "file_declaration",
                                                                                      "file_logical_name",
                                                                                      "file_open_information",
                                                                                      "file_type_definition",
                                                                                      "formal_parameter_list",
                                                                                      "formal_part",
                                                                                      "free_quantity_declaration",
                                                                                      "generate_statement",
                                                                                      "generation_scheme",
                                                                                      "generic_clause",
                                                                                      "generic_list",
                                                                                      "generic_map_aspect",
                                                                                      "group_constituent",
                                                                                      "group_constituent_list",
                                                                                      "group_declaration",
                                                                                      "group_template_declaration",
                                                                                      "guarded_signal_specification",
                                                                                      "identifier",
                                                                                      "identifier_list",
                                                                                      "if_statement",
                                                                                      "index_constraint",
                                                                                      "index_specification",
                                                                                      "index_subtype_definition",
                                                                                      "instantiated_unit",
                                                                                      "instantiation_list",
                                                                                      "interface_constant_declaration",
                                                                                      "interface_declaration",
                                                                                      "interface_element",
                                                                                      "interface_file_declaration",
                                                                                      "interface_signal_list",
                                                                                      "interface_port_list",
                                                                                      "interface_list",
                                                                                      "interface_quantity_declaration",
                                                                                      "interface_port_declaration",
                                                                                      "interface_signal_declaration",
                                                                                      "interface_terminal_declaration",
                                                                                      "interface_variable_declaration",
                                                                                      "iteration_scheme",
                                                                                      "label_colon",
                                                                                      "library_clause",
                                                                                      "library_unit",
                                                                                      "literal",
                                                                                      "logical_name",
                                                                                      "logical_name_list",
                                                                                      "logical_operator",
                                                                                      "loop_statement",
                                                                                      "signal_mode",
                                                                                      "multiplying_operator",
                                                                                      "name",
                                                                                      "name_part",
                                                                                      "selected_name",
                                                                                      "selected_name_part",
                                                                                      "function_call_or_indexed_name_part",
                                                                                      "slice_name_part",
                                                                                      "attribute_name_part",
                                                                                      "nature_declaration",
                                                                                      "nature_definition",
                                                                                      "nature_element_declaration",
                                                                                      "next_statement",
                                                                                      "numeric_literal",
                                                                                      "object_declaration",
                                                                                      "opts",
                                                                                      "package_body",
                                                                                      "package_body_declarative_item",
                                                                                      "package_body_declarative_part",
                                                                                      "package_declaration",
                                                                                      "package_declarative_item",
                                                                                      "package_declarative_part",
                                                                                      "parameter_specification",
                                                                                      "physical_literal",
                                                                                      "physical_type_definition",
                                                                                      "port_clause",
                                                                                      "port_list",
                                                                                      "port_map_aspect",
                                                                                      "primary",
                                                                                      "primary_unit",
                                                                                      "procedural_declarative_item",
                                                                                      "procedural_declarative_part",
                                                                                      "procedural_statement_part",
                                                                                      "procedure_call",
                                                                                      "procedure_call_statement",
                                                                                      "process_declarative_item",
                                                                                      "process_declarative_part",
                                                                                      "process_statement",
                                                                                      "process_statement_part",
                                                                                      "qualified_expression",
                                                                                      "quantity_declaration",
                                                                                      "quantity_list",
                                                                                      "quantity_specification",
                                                                                      "range_decl",
                                                                                      "explicit_range",
                                                                                      "range_constraint",
                                                                                      "record_nature_definition",
                                                                                      "record_type_definition",
                                                                                      "relation",
                                                                                      "relational_operator",
                                                                                      "report_statement",
                                                                                      "return_statement",
                                                                                      "scalar_nature_definition",
                                                                                      "scalar_type_definition",
                                                                                      "secondary_unit",
                                                                                      "secondary_unit_declaration",
                                                                                      "selected_signal_assignment",
                                                                                      "selected_waveforms",
                                                                                      "sensitivity_clause",
                                                                                      "sensitivity_list",
                                                                                      "sequence_of_statements",
                                                                                      "sequential_statement",
                                                                                      "shift_expression",
                                                                                      "shift_operator",
                                                                                      "signal_assignment_statement",
                                                                                      "signal_declaration",
                                                                                      "signal_kind",
                                                                                      "signal_list",
                                                                                      "signature",
                                                                                      "simple_expression",
                                                                                      "simple_simultaneous_statement",
                                                                                      "simultaneous_alternative",
                                                                                      "simultaneous_case_statement",
                                                                                      "simultaneous_if_statement",
                                                                                      "simultaneous_procedural_statement",
                                                                                      "simultaneous_statement",
                                                                                      "simultaneous_statement_part",
                                                                                      "source_aspect",
                                                                                      "source_quantity_declaration",
                                                                                      "step_limit_specification",
                                                                                      "subnature_declaration",
                                                                                      "subnature_indication",
                                                                                      "subprogram_body",
                                                                                      "subprogram_declaration",
                                                                                      "subprogram_declarative_item",
                                                                                      "subprogram_declarative_part",
                                                                                      "subprogram_kind",
                                                                                      "subprogram_specification",
                                                                                      "procedure_specification",
                                                                                      "function_specification",
                                                                                      "subprogram_statement_part",
                                                                                      "subtype_declaration",
                                                                                      "subtype_indication",
                                                                                      "suffix",
                                                                                      "target",
                                                                                      "term",
                                                                                      "terminal_aspect",
                                                                                      "terminal_declaration",
                                                                                      "through_aspect",
                                                                                      "timeout_clause",
                                                                                      "tolerance_aspect",
                                                                                      "type_declaration",
                                                                                      "type_definition",
                                                                                      "unconstrained_array_definition",
                                                                                      "unconstrained_nature_definition",
                                                                                      "use_clause",
                                                                                      "variable_assignment_statement",
                                                                                      "variable_declaration",
                                                                                      "wait_statement",
                                                                                      "waveform",
                                                                                      "waveform_element"},
                                                             std::vector<std::string>{"",
                                                                                      "'ABS'",
                                                                                      "'ACCESS'",
                                                                                      "'ACROSS'",
                                                                                      "'AFTER'",
                                                                                      "'ALIAS'",
                                                                                      "'ALL'",
                                                                                      "'AND'",
                                                                                      "'ARCHITECTURE'",
                                                                                      "'ARRAY'",
                                                                                      "'ASSERT'",
                                                                                      "'ATTRIBUTE'",
                                                                                      "'BEGIN'",
                                                                                      "'BLOCK'",
                                                                                      "'BODY'",
                                                                                      "'BREAK'",
                                                                                      "'BUFFER'",
                                                                                      "'BUS'",
                                                                                      "'CASE'",
                                                                                      "'COMPONENT'",
                                                                                      "'CONFIGURATION'",
                                                                                      "'CONSTANT'",
                                                                                      "'DISCONNECT'",
                                                                                      "'DOWNTO'",
                                                                                      "'END'",
                                                                                      "'ENTITY'",
                                                                                      "'ELSE'",
                                                                                      "'ELSIF'",
                                                                                      "'EXIT'",
                                                                                      "'FILE'",
                                                                                      "'FOR'",
                                                                                      "'FUNCTION'",
                                                                                      "'GENERATE'",
                                                                                      "'GENERIC'",
                                                                                      "'GROUP'",
                                                                                      "'GUARDED'",
                                                                                      "'IF'",
                                                                                      "'IMPURE'",
                                                                                      "'IN'",
                                                                                      "'INERTIAL'",
                                                                                      "'INOUT'",
                                                                                      "'IS'",
                                                                                      "'LABEL'",
                                                                                      "'LIBRARY'",
                                                                                      "'LIMIT'",
                                                                                      "'LINKAGE'",
                                                                                      "'LITERAL'",
                                                                                      "'LOOP'",
                                                                                      "'MAP'",
                                                                                      "'MOD'",
                                                                                      "'NAND'",
                                                                                      "'NATURE'",
                                                                                      "'NEW'",
                                                                                      "'NEXT'",
                                                                                      "'NOISE'",
                                                                                      "'NOR'",
                                                                                      "'NOT'",
                                                                                      "'NULL'",
                                                                                      "'OF'",
                                                                                      "'ON'",
                                                                                      "'OPEN'",
                                                                                      "'OR'",
                                                                                      "'OTHERS'",
                                                                                      "'OUT'",
                                                                                      "'PACKAGE'",
                                                                                      "'PORT'",
                                                                                      "'POSTPONED'",
                                                                                      "'PROCESS'",
                                                                                      "'PROCEDURE'",
                                                                                      "'PROCEDURAL'",
                                                                                      "'PURE'",
                                                                                      "'QUANTITY'",
                                                                                      "'RANGE'",
                                                                                      "'REVERSE_RANGE'",
                                                                                      "'REJECT'",
                                                                                      "'REM'",
                                                                                      "'RECORD'",
                                                                                      "'REFERENCE'",
                                                                                      "'REGISTER'",
                                                                                      "'REPORT'",
                                                                                      "'RETURN'",
                                                                                      "'ROL'",
                                                                                      "'ROR'",
                                                                                      "'SELECT'",
                                                                                      "'SEVERITY'",
                                                                                      "'SHARED'",
                                                                                      "'SIGNAL'",
                                                                                      "'SLA'",
                                                                                      "'SLL'",
                                                                                      "'SPECTRUM'",
                                                                                      "'SRA'",
                                                                                      "'SRL'",
                                                                                      "'SUBNATURE'",
                                                                                      "'SUBTYPE'",
                                                                                      "'TERMINAL'",
                                                                                      "'THEN'",
                                                                                      "'THROUGH'",
                                                                                      "'TO'",
                                                                                      "'TOLERANCE'",
                                                                                      "'TRANSPORT'",
                                                                                      "'TYPE'",
                                                                                      "'UNAFFECTED'",
                                                                                      "'UNITS'",
                                                                                      "'UNTIL'",
                                                                                      "'USE'",
                                                                                      "'VARIABLE'",
                                                                                      "'WAIT'",
                                                                                      "'WITH'",
                                                                                      "'WHEN'",
                                                                                      "'WHILE'",
                                                                                      "'XNOR'",
                                                                                      "'XOR'",
                                                                                      "",
                                                                                      "",
                                                                                      "",
                                                                                      "",
                                                                                      "",
                                                                                      "",
                                                                                      "",
                                                                                      "",
                                                                                      "",
                                                                                      "",
                                                                                      "",
                                                                                      "",
                                                                                      "'\\n'",
                                                                                      "'\\r'",
                                                                                      "",
                                                                                      "",
                                                                                      "",
                                                                                      "'**'",
                                                                                      "'=='",
                                                                                      "'<='",
                                                                                      "'>='",
                                                                                      "'=>'",
                                                                                      "'/='",
                                                                                      "':='",
                                                                                      "'<>'",
                                                                                      "'\"'",
                                                                                      "';'",
                                                                                      "','",
                                                                                      "'&'",
                                                                                      "'('",
                                                                                      "')'",
                                                                                      "'['",
                                                                                      "']'",
                                                                                      "':'",
                                                                                      "'*'",
                                                                                      "'/'",
                                                                                      "'+'",
                                                                                      "'-'",
                                                                                      "'<'",
                                                                                      "'>'",
                                                                                      "'='",
                                                                                      "'|'",
                                                                                      "'.'",
                                                                                      "'\\'",
                                                                                      "",
                                                                                      "",
                                                                                      "",
                                                                                      "",
                                                                                      "",
                                                                                      "",
                                                                                      "'''"},
                                                             std::vector<std::string>{
                                                                 "",
                                                                 "ABS",
                                                                 "ACCESS",
                                                                 "ACROSS",
                                                                 "AFTER",
                                                                 "ALIAS",
                                                                 "ALL",
                                                                 "AND",
                                                                 "ARCHITECTURE",
                                                                 "ARRAY",
                                                                 "ASSERT",
                                                                 "ATTRIBUTE",
                                                                 "BEGIN",
                                                                 "BLOCK",
                                                                 "BODY",
                                                                 "BREAK",
                                                                 "BUFFER",
                                                                 "BUS",
                                                                 "CASE",
                                                                 "COMPONENT",
                                                                 "CONFIGURATION",
                                                                 "CONSTANT",
                                                                 "DISCONNECT",
                                                                 "DOWNTO",
                                                                 "END",
                                                                 "ENTITY",
                                                                 "ELSE",
                                                                 "ELSIF",
                                                                 "EXIT",
                                                                 "FILE",
                                                                 "FOR",
                                                                 "FUNCTION",
                                                                 "GENERATE",
                                                                 "GENERIC",
                                                                 "GROUP",
                                                                 "GUARDED",
                                                                 "IF",
                                                                 "IMPURE",
                                                                 "IN",
                                                                 "INERTIAL",
                                                                 "INOUT",
                                                                 "IS",
                                                                 "LABEL",
                                                                 "LIBRARY",
                                                                 "LIMIT",
                                                                 "LINKAGE",
                                                                 "LITERAL",
                                                                 "LOOP",
                                                                 "MAP",
                                                                 "MOD",
                                                                 "NAND",
                                                                 "NATURE",
                                                                 "NEW",
                                                                 "NEXT",
                                                                 "NOISE",
                                                                 "NOR",
                                                                 "NOT",
                                                                 "NULL_",
                                                                 "OF",
                                                                 "ON",
                                                                 "OPEN",
                                                                 "OR",
                                                                 "OTHERS",
                                                                 "OUT",
                                                                 "PACKAGE",
                                                                 "PORT",
                                                                 "POSTPONED",
                                                                 "PROCESS",
                                                                 "PROCEDURE",
                                                                 "PROCEDURAL",
                                                                 "PURE",
                                                                 "QUANTITY",
                                                                 "RANGE",
                                                                 "REVERSE_RANGE",
                                                                 "REJECT",
                                                                 "REM",
                                                                 "RECORD",
                                                                 "REFERENCE",
                                                                 "REGISTER",
                                                                 "REPORT",
                                                                 "RETURN",
                                                                 "ROL",
                                                                 "ROR",
                                                                 "SELECT",
                                                                 "SEVERITY",
                                                                 "SHARED",
                                                                 "SIGNAL",
                                                                 "SLA",
                                                                 "SLL",
                                                                 "SPECTRUM",
                                                                 "SRA",
                                                                 "SRL",
                                                                 "SUBNATURE",
                                                                 "SUBTYPE",
                                                                 "TERMINAL",
                                                                 "THEN",
                                                                 "THROUGH",
                                                                 "TO",
                                                                 "TOLERANCE",
                                                                 "TRANSPORT",
                                                                 "TYPE",
                                                                 "UNAFFECTED",
                                                                 "UNITS",
                                                                 "UNTIL",
                                                                 "USE",
                                                                 "VARIABLE",
                                                                 "WAIT",
                                                                 "WITH",
                                                                 "WHEN",
                                                                 "WHILE",
                                                                 "XNOR",
                                                                 "XOR",
                                                                 "BASE_LITERAL",
                                                                 "BIT_STRING_LITERAL",
                                                                 "BIT_STRING_LITERAL_BINARY",
                                                                 "BIT_STRING_LITERAL_OCTAL",
                                                                 "BIT_STRING_LITERAL_HEX",
                                                                 "REAL_LITERAL",
                                                                 "BASIC_IDENTIFIER",
                                                                 "EXTENDED_IDENTIFIER",
                                                                 "LETTER",
                                                                 "COMMENT",
                                                                 "TAB",
                                                                 "SPACE",
                                                                 "NEWLINE",
                                                                 "CR",
                                                                 "CHARACTER_LITERAL",
                                                                 "STRING_LITERAL",
                                                                 "OTHER_SPECIAL_CHARACTER",
                                                                 "DOUBLESTAR",
                                                                 "ASSIGN",
                                                                 "LE",
                                                                 "GE",
                                                                 "ARROW",
                                                                 "NEQ",
                                                                 "VARASGN",
                                                                 "BOX",
                                                                 "DBLQUOTE",
                                                                 "SEMI",
                                                                 "COMMA",
                                                                 "AMPERSAND",
                                                                 "LPAREN",
                                                                 "RPAREN",
                                                                 "LBRACKET",
                                                                 "RBRACKET",
                                                                 "COLON",
                                                                 "MUL",
                                                                 "DIV",
                                                                 "PLUS",
                                                                 "MINUS",
                                                                 "LOWERTHAN",
                                                                 "GREATERTHAN",
                                                                 "EQ",
                                                                 "BAR",
                                                                 "DOT",
                                                                 "BACKSLASH",
                                                                 "EXPONENT",
                                                                 "HEXDIGIT",
                                                                 "INTEGER",
                                                                 "DIGIT",
                                                                 "BASED_INTEGER",
                                                                 "EXTENDED_DIGIT",
                                                                 "APOSTROPHE"});
    static const int32_t serializedATNSegment[] = {
        4,    1,    162,  2599, 2,    0,    7,    0,    2,    1,    7,    1,    2,    2,    7,    2,    2,    3,    7,    3,    2,    4,    7,    4,    2,    5,    7,    5,    2,    6,    7,    6,
        2,    7,    7,    7,    2,    8,    7,    8,    2,    9,    7,    9,    2,    10,   7,    10,   2,    11,   7,    11,   2,    12,   7,    12,   2,    13,   7,    13,   2,    14,   7,    14,
        2,    15,   7,    15,   2,    16,   7,    16,   2,    17,   7,    17,   2,    18,   7,    18,   2,    19,   7,    19,   2,    20,   7,    20,   2,    21,   7,    21,   2,    22,   7,    22,
        2,    23,   7,    23,   2,    24,   7,    24,   2,    25,   7,    25,   2,    26,   7,    26,   2,    27,   7,    27,   2,    28,   7,    28,   2,    29,   7,    29,   2,    30,   7,    30,
        2,    31,   7,    31,   2,    32,   7,    32,   2,    33,   7,    33,   2,    34,   7,    34,   2,    35,   7,    35,   2,    36,   7,    36,   2,    37,   7,    37,   2,    38,   7,    38,
        2,    39,   7,    39,   2,    40,   7,    40,   2,    41,   7,    41,   2,    42,   7,    42,   2,    43,   7,    43,   2,    44,   7,    44,   2,    45,   7,    45,   2,    46,   7,    46,
        2,    47,   7,    47,   2,    48,   7,    48,   2,    49,   7,    49,   2,    50,   7,    50,   2,    51,   7,    51,   2,    52,   7,    52,   2,    53,   7,    53,   2,    54,   7,    54,
        2,    55,   7,    55,   2,    56,   7,    56,   2,    57,   7,    57,   2,    58,   7,    58,   2,    59,   7,    59,   2,    60,   7,    60,   2,    61,   7,    61,   2,    62,   7,    62,
        2,    63,   7,    63,   2,    64,   7,    64,   2,    65,   7,    65,   2,    66,   7,    66,   2,    67,   7,    67,   2,    68,   7,    68,   2,    69,   7,    69,   2,    70,   7,    70,
        2,    71,   7,    71,   2,    72,   7,    72,   2,    73,   7,    73,   2,    74,   7,    74,   2,    75,   7,    75,   2,    76,   7,    76,   2,    77,   7,    77,   2,    78,   7,    78,
        2,    79,   7,    79,   2,    80,   7,    80,   2,    81,   7,    81,   2,    82,   7,    82,   2,    83,   7,    83,   2,    84,   7,    84,   2,    85,   7,    85,   2,    86,   7,    86,
        2,    87,   7,    87,   2,    88,   7,    88,   2,    89,   7,    89,   2,    90,   7,    90,   2,    91,   7,    91,   2,    92,   7,    92,   2,    93,   7,    93,   2,    94,   7,    94,
        2,    95,   7,    95,   2,    96,   7,    96,   2,    97,   7,    97,   2,    98,   7,    98,   2,    99,   7,    99,   2,    100,  7,    100,  2,    101,  7,    101,  2,    102,  7,    102,
        2,    103,  7,    103,  2,    104,  7,    104,  2,    105,  7,    105,  2,    106,  7,    106,  2,    107,  7,    107,  2,    108,  7,    108,  2,    109,  7,    109,  2,    110,  7,    110,
        2,    111,  7,    111,  2,    112,  7,    112,  2,    113,  7,    113,  2,    114,  7,    114,  2,    115,  7,    115,  2,    116,  7,    116,  2,    117,  7,    117,  2,    118,  7,    118,
        2,    119,  7,    119,  2,    120,  7,    120,  2,    121,  7,    121,  2,    122,  7,    122,  2,    123,  7,    123,  2,    124,  7,    124,  2,    125,  7,    125,  2,    126,  7,    126,
        2,    127,  7,    127,  2,    128,  7,    128,  2,    129,  7,    129,  2,    130,  7,    130,  2,    131,  7,    131,  2,    132,  7,    132,  2,    133,  7,    133,  2,    134,  7,    134,
        2,    135,  7,    135,  2,    136,  7,    136,  2,    137,  7,    137,  2,    138,  7,    138,  2,    139,  7,    139,  2,    140,  7,    140,  2,    141,  7,    141,  2,    142,  7,    142,
        2,    143,  7,    143,  2,    144,  7,    144,  2,    145,  7,    145,  2,    146,  7,    146,  2,    147,  7,    147,  2,    148,  7,    148,  2,    149,  7,    149,  2,    150,  7,    150,
        2,    151,  7,    151,  2,    152,  7,    152,  2,    153,  7,    153,  2,    154,  7,    154,  2,    155,  7,    155,  2,    156,  7,    156,  2,    157,  7,    157,  2,    158,  7,    158,
        2,    159,  7,    159,  2,    160,  7,    160,  2,    161,  7,    161,  2,    162,  7,    162,  2,    163,  7,    163,  2,    164,  7,    164,  2,    165,  7,    165,  2,    166,  7,    166,
        2,    167,  7,    167,  2,    168,  7,    168,  2,    169,  7,    169,  2,    170,  7,    170,  2,    171,  7,    171,  2,    172,  7,    172,  2,    173,  7,    173,  2,    174,  7,    174,
        2,    175,  7,    175,  2,    176,  7,    176,  2,    177,  7,    177,  2,    178,  7,    178,  2,    179,  7,    179,  2,    180,  7,    180,  2,    181,  7,    181,  2,    182,  7,    182,
        2,    183,  7,    183,  2,    184,  7,    184,  2,    185,  7,    185,  2,    186,  7,    186,  2,    187,  7,    187,  2,    188,  7,    188,  2,    189,  7,    189,  2,    190,  7,    190,
        2,    191,  7,    191,  2,    192,  7,    192,  2,    193,  7,    193,  2,    194,  7,    194,  2,    195,  7,    195,  2,    196,  7,    196,  2,    197,  7,    197,  2,    198,  7,    198,
        2,    199,  7,    199,  2,    200,  7,    200,  2,    201,  7,    201,  2,    202,  7,    202,  2,    203,  7,    203,  2,    204,  7,    204,  2,    205,  7,    205,  2,    206,  7,    206,
        2,    207,  7,    207,  2,    208,  7,    208,  2,    209,  7,    209,  2,    210,  7,    210,  2,    211,  7,    211,  2,    212,  7,    212,  2,    213,  7,    213,  2,    214,  7,    214,
        2,    215,  7,    215,  2,    216,  7,    216,  2,    217,  7,    217,  2,    218,  7,    218,  2,    219,  7,    219,  2,    220,  7,    220,  2,    221,  7,    221,  2,    222,  7,    222,
        2,    223,  7,    223,  2,    224,  7,    224,  2,    225,  7,    225,  2,    226,  7,    226,  2,    227,  7,    227,  2,    228,  7,    228,  2,    229,  7,    229,  2,    230,  7,    230,
        2,    231,  7,    231,  2,    232,  7,    232,  2,    233,  7,    233,  2,    234,  7,    234,  2,    235,  7,    235,  2,    236,  7,    236,  2,    237,  7,    237,  2,    238,  7,    238,
        2,    239,  7,    239,  2,    240,  7,    240,  2,    241,  7,    241,  2,    242,  7,    242,  2,    243,  7,    243,  2,    244,  7,    244,  2,    245,  7,    245,  2,    246,  7,    246,
        2,    247,  7,    247,  2,    248,  7,    248,  2,    249,  7,    249,  2,    250,  7,    250,  2,    251,  7,    251,  2,    252,  7,    252,  2,    253,  7,    253,  2,    254,  7,    254,
        1,    0,    1,    0,    1,    1,    1,    1,    1,    1,    1,    2,    1,    2,    3,    2,    518,  8,    2,    1,    2,    1,    2,    3,    2,    522,  8,    2,    1,    2,    1,    2,
        1,    3,    1,    3,    3,    3,    528,  8,    3,    1,    4,    1,    4,    1,    5,    1,    5,    1,    5,    1,    5,    1,    5,    1,    5,    3,    5,    538,  8,    5,    1,    6,
        1,    6,    1,    7,    1,    7,    1,    7,    1,    7,    5,    7,    546,  8,    7,    10,   7,    12,   7,    549,  9,    7,    1,    7,    1,    7,    1,    8,    1,    8,    1,    8,
        1,    8,    3,    8,    557,  8,    8,    1,    8,    1,    8,    1,    8,    3,    8,    562,  8,    8,    1,    8,    1,    8,    1,    9,    1,    9,    1,    9,    3,    9,    569,  8,
        9,    1,    10,   1,    10,   3,    10,   573,  8,    10,   1,    11,   1,    11,   1,    11,   3,    11,   578,  8,    11,   1,    12,   1,    12,   1,    12,   1,    12,   1,    12,   1,
        12,   1,    12,   1,    12,   1,    12,   1,    12,   3,    12,   590,  8,    12,   1,    12,   3,    12,   593,  8,    12,   1,    12,   1,    12,   1,    13,   5,    13,   598,  8,    13,
        10,   13,   12,   13,   601,  9,    13,   1,    14,   1,    14,   1,    14,   3,    14,   606,  8,    14,   1,    14,   1,    14,   3,    14,   610,  8,    14,   1,    14,   1,    14,   3,
        14,   614,  8,    14,   1,    14,   3,    14,   617,  8,    14,   1,    14,   1,    14,   1,    14,   1,    14,   1,    14,   3,    14,   624,  8,    14,   1,    15,   5,    15,   627,  8,
        15,   10,   15,   12,   15,   630,  9,    15,   1,    16,   1,    16,   3,    16,   634,  8,    16,   1,    17,   1,    17,   3,    17,   638,  8,    17,   1,    18,   1,    18,   1,    18,
        1,    18,   3,    18,   644,  8,    18,   1,    18,   1,    18,   3,    18,   648,  8,    18,   1,    19,   3,    19,   651,  8,    19,   1,    19,   1,    19,   1,    19,   1,    20,   1,
        20,   1,    20,   3,    20,   659,  8,    20,   1,    20,   1,    20,   1,    21,   1,    21,   1,    21,   5,    21,   666,  8,    21,   10,   21,   12,   21,   669,  9,    21,   1,    22,
        1,    22,   1,    22,   1,    22,   1,    22,   1,    23,   1,    23,   1,    23,   1,    23,   1,    23,   1,    23,   1,    23,   3,    23,   683,  8,    23,   1,    24,   1,    24,   1,
        24,   1,    24,   1,    24,   1,    24,   1,    24,   1,    24,   1,    25,   1,    25,   1,    25,   1,    26,   1,    26,   3,    26,   698,  8,    26,   1,    26,   3,    26,   701,  8,
        26,   1,    26,   3,    26,   704,  8,    26,   1,    27,   1,    27,   1,    27,   5,    27,   709,  8,    27,   10,   27,   12,   27,   712,  9,    27,   1,    27,   5,    27,   715,  8,
        27,   10,   27,   12,   27,   718,  9,    27,   1,    27,   1,    27,   1,    27,   1,    27,   1,    28,   1,    28,   1,    28,   1,    28,   1,    28,   1,    28,   1,    28,   1,    28,
        1,    28,   1,    28,   1,    28,   1,    28,   1,    28,   1,    28,   1,    28,   1,    28,   1,    28,   1,    28,   1,    28,   1,    28,   1,    28,   1,    28,   3,    28,   746,  8,
        28,   1,    29,   5,    29,   749,  8,    29,   10,   29,   12,   29,   752,  9,    29,   1,    30,   1,    30,   1,    30,   1,    30,   3,    30,   758,  8,    30,   3,    30,   760,  8,
        30,   1,    30,   1,    30,   1,    30,   1,    30,   3,    30,   766,  8,    30,   3,    30,   768,  8,    30,   1,    31,   1,    31,   1,    31,   1,    31,   1,    31,   3,    31,   775,
        8,    31,   1,    31,   3,    31,   778,  8,    31,   1,    32,   1,    32,   1,    32,   1,    32,   1,    32,   1,    32,   3,    32,   786,  8,    32,   1,    32,   3,    32,   789,  8,
        32,   1,    32,   1,    32,   1,    32,   1,    32,   1,    32,   1,    32,   1,    32,   3,    32,   798,  8,    32,   1,    32,   1,    32,   1,    33,   5,    33,   803,  8,    33,   10,
        33,   12,   33,   806,  9,    33,   1,    34,   1,    34,   3,    34,   810,  8,    34,   1,    34,   3,    34,   813,  8,    34,   1,    34,   1,    34,   1,    34,   1,    35,   3,    35,
        819,  8,    35,   1,    35,   1,    35,   1,    35,   1,    35,   1,    36,   1,    36,   1,    36,   5,    36,   828,  8,    36,   10,   36,   12,   36,   831,  9,    36,   1,    37,   1,
        37,   1,    37,   1,    37,   1,    38,   3,    38,   838,  8,    38,   1,    38,   1,    38,   3,    38,   842,  8,    38,   1,    38,   1,    38,   3,    38,   846,  8,    38,   1,    38,
        1,    38,   1,    39,   3,    39,   851,  8,    39,   1,    39,   1,    39,   1,    39,   1,    39,   4,    39,   857,  8,    39,   11,   39,   12,   39,   858,  1,    39,   1,    39,   1,
        39,   3,    39,   864,  8,    39,   1,    39,   1,    39,   1,    40,   1,    40,   1,    40,   1,    40,   1,    40,   1,    41,   1,    41,   1,    41,   1,    41,   3,    41,   877,  8,
        41,   1,    42,   1,    42,   1,    42,   5,    42,   882,  8,    42,   10,   42,   12,   42,   885,  9,    42,   1,    43,   1,    43,   1,    43,   1,    43,   1,    43,   3,    43,   892,
        8,    43,   1,    43,   3,    43,   895,  8,    43,   1,    43,   1,    43,   1,    43,   1,    43,   1,    44,   1,    44,   1,    44,   3,    44,   904,  8,    44,   1,    44,   3,    44,
        907,  8,    44,   1,    44,   3,    44,   910,  8,    44,   1,    44,   1,    44,   1,    44,   3,    44,   915,  8,    44,   1,    44,   1,    44,   1,    45,   1,    45,   1,    45,   3,
        45,   922,  8,    45,   1,    45,   3,    45,   925,  8,    45,   1,    45,   1,    45,   1,    46,   1,    46,   1,    46,   1,    46,   1,    47,   1,    47,   3,    47,   935,  8,    47,
        1,    48,   1,    48,   3,    48,   939,  8,    48,   1,    49,   3,    49,   942,  8,    49,   1,    49,   3,    49,   945,  8,    49,   1,    49,   1,    49,   1,    49,   1,    50,   3,
        50,   951,  8,    50,   1,    50,   1,    50,   3,    50,   955,  8,    50,   1,    50,   3,    50,   958,  8,    50,   1,    50,   1,    50,   3,    50,   962,  8,    50,   1,    50,   1,
        50,   1,    51,   3,    51,   967,  8,    51,   1,    51,   3,    51,   970,  8,    51,   1,    51,   1,    51,   1,    51,   1,    52,   3,    52,   976,  8,    52,   1,    52,   3,    52,
        979,  8,    52,   1,    52,   1,    52,   3,    52,   983,  8,    52,   1,    53,   1,    53,   1,    54,   1,    54,   1,    54,   1,    55,   1,    55,   1,    55,   1,    55,   1,    55,
        1,    55,   1,    56,   1,    56,   1,    56,   1,    56,   1,    56,   3,    56,   1001, 8,    56,   3,    56,   1003, 8,    56,   1,    57,   1,    57,   1,    57,   1,    57,   1,    57,
        1,    57,   1,    57,   1,    57,   1,    57,   3,    57,   1014, 8,    57,   1,    57,   3,    57,   1017, 8,    57,   1,    57,   1,    57,   1,    58,   1,    58,   1,    58,   3,    58,
        1024, 8,    58,   1,    59,   5,    59,   1027, 8,    59,   10,   59,   12,   59,   1030, 9,    59,   1,    60,   1,    60,   3,    60,   1034, 8,    60,   1,    61,   1,    61,   1,    61,
        1,    61,   1,    61,   1,    62,   1,    62,   1,    62,   1,    62,   1,    62,   1,    62,   3,    62,   1047, 8,    62,   1,    62,   1,    62,   1,    63,   1,    63,   1,    63,   1,
        63,   1,    63,   1,    64,   1,    64,   1,    64,   1,    64,   1,    64,   1,    65,   1,    65,   3,    65,   1063, 8,    65,   1,    66,   5,    66,   1066, 8,    66,   10,   66,   12,
        66,   1069, 9,    66,   1,    67,   1,    67,   3,    67,   1073, 8,    67,   1,    68,   1,    68,   1,    68,   3,    68,   1078, 8,    68,   1,    68,   3,    68,   1081, 8,    68,   1,
        69,   5,    69,   1084, 8,    69,   10,   69,   12,   69,   1087, 9,    69,   1,    69,   1,    69,   1,    70,   1,    70,   1,    70,   1,    71,   1,    71,   3,    71,   1096, 8,    71,
        1,    72,   1,    72,   1,    73,   1,    73,   1,    73,   1,    73,   1,    73,   1,    73,   1,    74,   1,    74,   3,    74,   1108, 8,    74,   1,    75,   1,    75,   1,    75,   3,
        75,   1113, 8,    75,   1,    75,   1,    75,   1,    76,   1,    76,   1,    76,   1,    76,   1,    76,   1,    77,   1,    77,   1,    78,   1,    78,   1,    79,   1,    79,   1,    79,
        1,    79,   1,    79,   1,    79,   3,    79,   1132, 8,    79,   1,    79,   1,    79,   1,    79,   3,    79,   1137, 8,    79,   1,    80,   1,    80,   1,    81,   1,    81,   3,    81,
        1143, 8,    81,   1,    82,   1,    82,   1,    82,   5,    82,   1148, 8,    82,   10,   82,   12,   82,   1151, 9,    82,   1,    83,   1,    83,   1,    83,   1,    83,   1,    83,   1,
        83,   1,    83,   3,    83,   1160, 8,    83,   1,    83,   1,    83,   3,    83,   1164, 8,    83,   1,    83,   3,    83,   1167, 8,    83,   1,    83,   1,    83,   1,    84,   1,    84,
        1,    84,   1,    84,   1,    84,   1,    84,   1,    84,   1,    84,   1,    84,   1,    84,   1,    84,   1,    84,   1,    84,   1,    84,   1,    84,   1,    84,   1,    84,   1,    84,
        1,    84,   1,    84,   3,    84,   1191, 8,    84,   1,    85,   5,    85,   1194, 8,    85,   10,   85,   12,   85,   1197, 9,    85,   1,    86,   1,    86,   3,    86,   1201, 8,    86,
        1,    87,   3,    87,   1204, 8,    87,   1,    87,   3,    87,   1207, 8,    87,   1,    88,   1,    88,   1,    88,   5,    88,   1212, 8,    88,   10,   88,   12,   88,   1215, 9,    88,
        1,    88,   1,    88,   3,    88,   1219, 8,    88,   1,    89,   1,    89,   1,    89,   1,    89,   1,    90,   1,    90,   1,    90,   3,    90,   1228, 8,    90,   1,    91,   5,    91,
        1231, 8,    91,   10,   91,   12,   91,   1234, 9,    91,   1,    92,   1,    92,   1,    92,   3,    92,   1239, 8,    92,   1,    93,   1,    93,   3,    93,   1243, 8,    93,   1,    94,
        1,    94,   1,    94,   1,    94,   5,    94,   1249, 8,    94,   10,   94,   12,   94,   1252, 9,    94,   1,    94,   1,    94,   1,    95,   3,    95,   1257, 8,    95,   1,    95,   1,
        95,   3,    95,   1261, 8,    95,   1,    95,   1,    95,   3,    95,   1265, 8,    95,   1,    95,   1,    95,   1,    96,   1,    96,   1,    96,   1,    96,   5,    96,   1273, 8,    96,
        10,   96,   12,   96,   1276, 9,    96,   1,    97,   1,    97,   1,    97,   3,    97,   1281, 8,    97,   1,    97,   1,    97,   1,    97,   1,    97,   3,    97,   1287, 8,    97,   1,
        98,   1,    98,   1,    98,   1,    98,   1,    98,   3,    98,   1294, 8,    98,   1,    98,   1,    98,   1,    99,   1,    99,   1,    100,  1,    100,  3,    100,  1302, 8,    100,  1,
        100,  1,    100,  1,    100,  1,    101,  1,    101,  1,    101,  1,    101,  1,    102,  1,    102,  1,    103,  1,    103,  1,    103,  1,    103,  1,    103,  1,    103,  3,    103,  1319,
        8,    103,  1,    104,  1,    104,  1,    104,  1,    104,  1,    104,  1,    104,  3,    104,  1327, 8,    104,  1,    104,  1,    104,  1,    105,  1,    105,  1,    105,  1,    105,  5,
        105,  1335, 8,    105,  10,   105,  12,   105,  1338, 9,    105,  1,    105,  3,    105,  1341, 8,    105,  1,    105,  5,    105,  1344, 8,    105,  10,   105,  12,   105,  1347, 9,    105,
        1,    105,  1,    105,  1,    105,  3,    105,  1352, 8,    105,  1,    105,  1,    105,  1,    106,  1,    106,  1,    106,  1,    106,  3,    106,  1360, 8,    106,  1,    107,  1,    107,
        1,    107,  1,    107,  1,    107,  1,    107,  1,    108,  1,    108,  1,    108,  5,    108,  1371, 8,    108,  10,   108,  12,   108,  1374, 9,    108,  1,    109,  1,    109,  1,    109,
        1,    109,  1,    109,  1,    109,  1,    110,  1,    110,  3,    110,  1384, 8,    110,  1,    111,  1,    111,  1,    111,  5,    111,  1389, 8,    111,  10,   111,  12,   111,  1392, 9,
        111,  1,    112,  1,    112,  1,    112,  1,    112,  1,    112,  1,    112,  1,    112,  1,    112,  1,    113,  1,    113,  1,    113,  1,    113,  1,    113,  1,    113,  1,    113,  1,
        113,  1,    114,  1,    114,  1,    114,  1,    114,  1,    115,  1,    115,  1,    116,  1,    116,  1,    116,  5,    116,  1419, 8,    116,  10,   116,  12,   116,  1422, 9,    116,  1,
        117,  3,    117,  1425, 8,    117,  1,    117,  1,    117,  1,    117,  1,    117,  1,    117,  1,    117,  1,    117,  1,    117,  1,    117,  5,    117,  1436, 8,    117,  10,   117,  12,
        117,  1439, 9,    117,  1,    117,  1,    117,  3,    117,  1443, 8,    117,  1,    117,  1,    117,  1,    117,  3,    117,  1448, 8,    117,  1,    117,  1,    117,  1,    118,  1,    118,
        1,    118,  1,    118,  5,    118,  1456, 8,    118,  10,   118,  12,   118,  1459, 9,    118,  1,    118,  1,    118,  1,    119,  1,    119,  3,    119,  1465, 8,    119,  1,    120,  1,
        120,  1,    120,  1,    120,  1,    121,  3,    121,  1472, 8,    121,  1,    121,  1,    121,  1,    121,  1,    121,  1,    121,  1,    121,  1,    121,  3,    121,  1481, 8,    121,  1,
        121,  1,    121,  3,    121,  1485, 8,    121,  1,    122,  1,    122,  1,    122,  5,    122,  1490, 8,    122,  10,   122,  12,   122,  1493, 9,    122,  1,    122,  1,    122,  3,    122,
        1497, 8,    122,  1,    123,  3,    123,  1500, 8,    123,  1,    123,  1,    123,  1,    123,  3,    123,  1505, 8,    123,  1,    123,  1,    123,  1,    123,  3,    123,  1510, 8,    123,
        1,    124,  1,    124,  1,    124,  1,    124,  1,    124,  1,    124,  3,    124,  1518, 8,    124,  1,    125,  1,    125,  1,    126,  1,    126,  1,    126,  1,    126,  1,    126,  1,
        127,  1,    127,  1,    127,  5,    127,  1530, 8,    127,  10,   127,  12,   127,  1533, 9,    127,  1,    128,  1,    128,  1,    128,  5,    128,  1538, 8,    128,  10,   128,  12,   128,
        1541, 9,    128,  1,    129,  1,    129,  1,    129,  5,    129,  1546, 8,    129,  10,   129,  12,   129,  1549, 9,    129,  1,    130,  1,    130,  1,    130,  1,    130,  3,    130,  1555,
        8,    130,  1,    130,  1,    130,  1,    130,  3,    130,  1560, 8,    130,  1,    131,  1,    131,  1,    131,  3,    131,  1565, 8,    131,  1,    131,  1,    131,  3,    131,  1569, 8,
        131,  1,    131,  1,    131,  3,    131,  1573, 8,    131,  1,    132,  1,    132,  1,    132,  1,    132,  3,    132,  1579, 8,    132,  1,    132,  1,    132,  3,    132,  1583, 8,    132,
        1,    132,  1,    132,  3,    132,  1587, 8,    132,  1,    133,  1,    133,  1,    133,  1,    133,  1,    133,  1,    134,  3,    134,  1595, 8,    134,  1,    134,  1,    134,  1,    134,
        3,    134,  1600, 8,    134,  1,    134,  1,    134,  1,    134,  3,    134,  1605, 8,    134,  1,    135,  1,    135,  1,    135,  1,    135,  3,    135,  1611, 8,    135,  1,    136,  1,
        136,  1,    136,  1,    137,  1,    137,  1,    137,  1,    137,  1,    138,  1,    138,  3,    138,  1622, 8,    138,  1,    139,  1,    139,  1,    139,  1,    139,  1,    139,  3,    139,
        1629, 8,    139,  1,    140,  1,    140,  1,    141,  1,    141,  1,    141,  5,    141,  1636, 8,    141,  10,   141,  12,   141,  1639, 9,    141,  1,    142,  1,    142,  1,    143,  3,
        143,  1644, 8,    143,  1,    143,  3,    143,  1647, 8,    143,  1,    143,  1,    143,  1,    143,  1,    143,  1,    143,  3,    143,  1654, 8,    143,  1,    143,  1,    143,  1,    144,
        1,    144,  1,    145,  1,    145,  1,    146,  1,    146,  3,    146,  1664, 8,    146,  1,    146,  5,    146,  1667, 8,    146,  10,   146,  12,   146,  1670, 9,    146,  1,    147,  1,
        147,  1,    147,  1,    147,  3,    147,  1676, 8,    147,  1,    148,  1,    148,  1,    148,  5,    148,  1681, 8,    148,  10,   148,  12,   148,  1684, 9,    148,  1,    149,  1,    149,
        4,    149,  1688, 8,    149,  11,   149,  12,   149,  1689, 1,    150,  1,    150,  1,    150,  1,    150,  1,    151,  1,    151,  1,    151,  1,    151,  1,    152,  3,    152,  1701, 8,
        152,  1,    152,  1,    152,  1,    152,  1,    152,  1,    152,  1,    152,  3,    152,  1709, 8,    152,  1,    153,  1,    153,  1,    153,  1,    153,  1,    153,  1,    153,  1,    154,
        1,    154,  3,    154,  1719, 8,    154,  1,    155,  1,    155,  1,    155,  1,    155,  1,    156,  3,    156,  1726, 8,    156,  1,    156,  1,    156,  3,    156,  1730, 8,    156,  1,
        156,  1,    156,  3,    156,  1734, 8,    156,  1,    156,  1,    156,  1,    157,  1,    157,  3,    157,  1740, 8,    157,  1,    158,  1,    158,  1,    158,  1,    158,  1,    158,  1,
        158,  3,    158,  1748, 8,    158,  1,    159,  3,    159,  1751, 8,    159,  1,    159,  3,    159,  1754, 8,    159,  1,    160,  1,    160,  1,    160,  1,    160,  1,    160,  1,    160,
        1,    160,  1,    160,  3,    160,  1764, 8,    160,  1,    160,  3,    160,  1767, 8,    160,  1,    160,  1,    160,  1,    161,  1,    161,  1,    161,  1,    161,  1,    161,  1,    161,
        1,    161,  1,    161,  1,    161,  1,    161,  1,    161,  3,    161,  1782, 8,    161,  1,    162,  5,    162,  1785, 8,    162,  10,   162,  12,   162,  1788, 9,    162,  1,    163,  1,
        163,  1,    163,  1,    163,  1,    163,  1,    163,  3,    163,  1796, 8,    163,  1,    163,  3,    163,  1799, 8,    163,  1,    163,  1,    163,  1,    164,  1,    164,  1,    164,  1,
        164,  1,    164,  1,    164,  1,    164,  1,    164,  1,    164,  1,    164,  1,    164,  1,    164,  1,    164,  1,    164,  1,    164,  1,    164,  1,    164,  1,    164,  1,    164,  3,
        164,  1822, 8,    164,  1,    165,  5,    165,  1825, 8,    165,  10,   165,  12,   165,  1828, 9,    165,  1,    166,  1,    166,  1,    166,  1,    166,  1,    167,  1,    167,  1,    167,
        1,    168,  1,    168,  1,    168,  1,    168,  5,    168,  1841, 8,    168,  10,   168,  12,   168,  1844, 9,    168,  1,    168,  1,    168,  1,    168,  3,    168,  1849, 8,    168,  1,
        169,  1,    169,  1,    169,  1,    169,  1,    169,  1,    169,  1,    170,  1,    170,  1,    171,  1,    171,  1,    171,  1,    171,  1,    171,  1,    171,  1,    172,  1,    172,  1,
        172,  1,    172,  1,    172,  1,    172,  1,    172,  1,    172,  1,    172,  3,    172,  1874, 8,    172,  1,    173,  1,    173,  1,    173,  3,    173,  1879, 8,    173,  1,    174,  1,
        174,  1,    174,  1,    174,  1,    174,  1,    174,  1,    174,  1,    174,  1,    174,  1,    174,  1,    174,  1,    174,  3,    174,  1893, 8,    174,  1,    175,  5,    175,  1896, 8,
        175,  10,   175,  12,   175,  1899, 9,    175,  1,    176,  5,    176,  1902, 8,    176,  10,   176,  12,   176,  1905, 9,    176,  1,    177,  1,    177,  1,    177,  1,    177,  1,    177,
        3,    177,  1912, 8,    177,  1,    178,  3,    178,  1915, 8,    178,  1,    178,  1,    178,  1,    178,  1,    179,  1,    179,  1,    179,  1,    179,  1,    179,  1,    179,  1,    179,
        1,    179,  1,    179,  1,    179,  1,    179,  1,    179,  1,    179,  3,    179,  1933, 8,    179,  1,    180,  5,    180,  1936, 8,    180,  10,   180,  12,   180,  1939, 9,    180,  1,
        181,  3,    181,  1942, 8,    181,  1,    181,  3,    181,  1945, 8,    181,  1,    181,  1,    181,  1,    181,  1,    181,  1,    181,  3,    181,  1952, 8,    181,  1,    181,  3,    181,
        1955, 8,    181,  1,    181,  1,    181,  1,    181,  1,    181,  1,    181,  3,    181,  1962, 8,    181,  1,    181,  1,    181,  3,    181,  1966, 8,    181,  1,    181,  1,    181,  1,
        182,  5,    182,  1971, 8,    182,  10,   182,  12,   182,  1974, 9,    182,  1,    183,  1,    183,  1,    183,  1,    183,  1,    183,  1,    183,  1,    183,  3,    183,  1983, 8,    183,
        1,    184,  1,    184,  1,    184,  3,    184,  1988, 8,    184,  1,    185,  1,    185,  1,    185,  5,    185,  1993, 8,    185,  10,   185,  12,   185,  1996, 9,    185,  1,    185,  1,
        185,  3,    185,  2000, 8,    185,  1,    186,  1,    186,  1,    186,  1,    186,  1,    187,  1,    187,  3,    187,  2008, 8,    187,  1,    188,  1,    188,  1,    188,  1,    188,  3,
        188,  2014, 8,    188,  1,    189,  1,    189,  1,    189,  1,    190,  1,    190,  4,    190,  2021, 8,    190,  11,   190,  12,   190,  2022, 1,    190,  1,    190,  1,    190,  3,    190,
        2028, 8,    190,  1,    191,  1,    191,  4,    191,  2032, 8,    191,  11,   191,  12,   191,  2033, 1,    191,  1,    191,  1,    191,  3,    191,  2039, 8,    191,  1,    192,  1,    192,
        1,    192,  1,    192,  3,    192,  2045, 8,    192,  1,    193,  1,    193,  1,    194,  3,    194,  2050, 8,    194,  1,    194,  1,    194,  1,    194,  1,    194,  3,    194,  2056, 8,
        194,  1,    194,  1,    194,  1,    195,  3,    195,  2061, 8,    195,  1,    195,  1,    195,  3,    195,  2065, 8,    195,  1,    195,  1,    195,  1,    196,  1,    196,  1,    196,  1,
        196,  1,    196,  1,    196,  1,    196,  1,    197,  1,    197,  1,    197,  3,    197,  2079, 8,    197,  1,    198,  1,    198,  3,    198,  2083, 8,    198,  1,    199,  1,    199,  1,
        199,  1,    199,  1,    199,  1,    200,  1,    200,  1,    200,  1,    200,  1,    200,  1,    200,  1,    200,  1,    200,  1,    200,  1,    201,  1,    201,  1,    201,  1,    201,  1,
        201,  1,    201,  1,    201,  1,    201,  5,    201,  2107, 8,    201,  10,   201,  12,   201,  2110, 9,    201,  1,    202,  1,    202,  1,    202,  1,    203,  1,    203,  1,    203,  5,
        203,  2118, 8,    203,  10,   203,  12,   203,  2121, 9,    203,  1,    204,  5,    204,  2124, 8,    204,  10,   204,  12,   204,  2127, 9,    204,  1,    205,  1,    205,  1,    205,  1,
        205,  1,    205,  1,    205,  1,    205,  1,    205,  1,    205,  1,    205,  1,    205,  1,    205,  3,    205,  2141, 8,    205,  1,    205,  1,    205,  1,    205,  1,    205,  3,    205,
        2147, 8,    205,  1,    206,  1,    206,  1,    206,  1,    206,  3,    206,  2153, 8,    206,  1,    207,  1,    207,  1,    208,  3,    208,  2158, 8,    208,  1,    208,  1,    208,  1,
        208,  3,    208,  2163, 8,    208,  1,    208,  1,    208,  1,    208,  1,    209,  1,    209,  1,    209,  1,    209,  1,    209,  3,    209,  2173, 8,    209,  1,    209,  1,    209,  3,
        209,  2177, 8,    209,  1,    209,  1,    209,  1,    210,  1,    210,  1,    211,  1,    211,  1,    211,  5,    211,  2186, 8,    211,  10,   211,  12,   211,  2189, 9,    211,  1,    211,
        1,    211,  3,    211,  2193, 8,    211,  1,    212,  1,    212,  1,    212,  1,    212,  5,    212,  2199, 8,    212,  10,   212,  12,   212,  2202, 9,    212,  3,    212,  2204, 8,    212,
        1,    212,  1,    212,  3,    212,  2208, 8,    212,  1,    212,  1,    212,  1,    213,  3,    213,  2213, 8,    213,  1,    213,  1,    213,  1,    213,  1,    213,  5,    213,  2219, 8,
        213,  10,   213,  12,   213,  2222, 9,    213,  1,    214,  3,    214,  2225, 8,    214,  1,    214,  1,    214,  1,    214,  1,    214,  3,    214,  2231, 8,    214,  1,    214,  1,    214,
        1,    215,  1,    215,  1,    215,  1,    215,  1,    215,  1,    216,  3,    216,  2241, 8,    216,  1,    216,  1,    216,  1,    216,  1,    216,  4,    216,  2247, 8,    216,  11,   216,
        12,   216,  2248, 1,    216,  1,    216,  1,    216,  3,    216,  2254, 8,    216,  1,    216,  1,    216,  1,    217,  3,    217,  2259, 8,    217,  1,    217,  1,    217,  1,    217,  1,
        217,  1,    217,  1,    217,  1,    217,  1,    217,  1,    217,  5,    217,  2270, 8,    217,  10,   217,  12,   217,  2273, 9,    217,  1,    217,  1,    217,  3,    217,  2277, 8,    217,
        1,    217,  1,    217,  1,    217,  3,    217,  2282, 8,    217,  1,    217,  1,    217,  1,    218,  3,    218,  2287, 8,    218,  1,    218,  1,    218,  3,    218,  2291, 8,    218,  1,
        218,  1,    218,  1,    218,  1,    218,  1,    218,  1,    218,  3,    218,  2299, 8,    218,  1,    218,  1,    218,  1,    219,  1,    219,  1,    219,  1,    219,  1,    219,  3,    219,
        2308, 8,    219,  1,    219,  1,    219,  3,    219,  2312, 8,    219,  1,    220,  5,    220,  2315, 8,    220,  10,   220,  12,   220,  2318, 9,    220,  1,    221,  1,    221,  1,    221,
        1,    221,  1,    221,  1,    221,  1,    221,  3,    221,  2327, 8,    221,  1,    222,  1,    222,  1,    222,  1,    222,  1,    222,  1,    222,  1,    222,  1,    223,  1,    223,  1,
        223,  1,    223,  1,    223,  1,    223,  1,    224,  1,    224,  1,    224,  1,    224,  1,    224,  1,    224,  1,    225,  1,    225,  3,    225,  2350, 8,    225,  1,    225,  1,    225,
        1,    225,  1,    225,  1,    225,  1,    225,  3,    225,  2358, 8,    225,  1,    226,  1,    226,  1,    226,  1,    226,  1,    226,  1,    226,  1,    226,  3,    226,  2367, 8,    226,
        1,    226,  3,    226,  2370, 8,    226,  1,    226,  1,    226,  1,    227,  1,    227,  1,    227,  1,    228,  1,    228,  1,    228,  1,    228,  1,    228,  1,    228,  1,    228,  1,
        228,  1,    228,  1,    228,  1,    228,  1,    228,  1,    228,  3,    228,  2390, 8,    228,  1,    229,  5,    229,  2393, 8,    229,  10,   229,  12,   229,  2396, 9,    229,  1,    230,
        1,    230,  1,    231,  1,    231,  3,    231,  2402, 8,    231,  1,    232,  1,    232,  1,    232,  1,    232,  1,    232,  1,    232,  3,    232,  2410, 8,    232,  1,    233,  3,    233,
        2413, 8,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  3,    233,  2421, 8,    233,  1,    233,  1,    233,  1,    233,  1,    234,  5,    234,  2427, 8,
        234,  10,   234,  12,   234,  2430, 9,    234,  1,    235,  1,    235,  1,    235,  1,    235,  1,    235,  1,    235,  1,    236,  1,    236,  3,    236,  2440, 8,    236,  1,    236,  3,
        236,  2443, 8,    236,  1,    236,  3,    236,  2446, 8,    236,  1,    237,  1,    237,  1,    237,  1,    237,  3,    237,  2452, 8,    237,  1,    238,  1,    238,  3,    238,  2456, 8,
        238,  1,    239,  1,    239,  1,    239,  1,    239,  5,    239,  2462, 8,    239,  10,   239,  12,   239,  2465, 9,    239,  1,    240,  1,    240,  1,    240,  3,    240,  2470, 8,    240,
        1,    241,  1,    241,  1,    241,  1,    241,  1,    241,  1,    241,  1,    242,  1,    242,  3,    242,  2480, 8,    242,  1,    242,  1,    242,  3,    242,  2484, 8,    242,  1,    242,
        1,    242,  1,    243,  1,    243,  1,    243,  1,    244,  1,    244,  1,    244,  1,    245,  1,    245,  1,    245,  1,    245,  3,    245,  2498, 8,    245,  1,    245,  1,    245,  1,
        246,  1,    246,  1,    246,  1,    246,  3,    246,  2506, 8,    246,  1,    247,  1,    247,  1,    247,  1,    247,  1,    247,  5,    247,  2513, 8,    247,  10,   247,  12,   247,  2516,
        9,    247,  1,    247,  1,    247,  1,    247,  1,    247,  1,    248,  1,    248,  1,    248,  1,    248,  1,    248,  5,    248,  2527, 8,    248,  10,   248,  12,   248,  2530, 9,    248,
        1,    248,  1,    248,  1,    248,  1,    248,  1,    249,  1,    249,  1,    249,  1,    249,  5,    249,  2540, 8,    249,  10,   249,  12,   249,  2543, 9,    249,  1,    249,  1,    249,
        1,    250,  3,    250,  2548, 8,    250,  1,    250,  1,    250,  1,    250,  1,    250,  1,    250,  1,    251,  3,    251,  2556, 8,    251,  1,    251,  1,    251,  1,    251,  1,    251,
        1,    251,  1,    251,  3,    251,  2564, 8,    251,  1,    251,  1,    251,  1,    252,  3,    252,  2569, 8,    252,  1,    252,  1,    252,  3,    252,  2573, 8,    252,  1,    252,  3,
        252,  2576, 8,    252,  1,    252,  3,    252,  2579, 8,    252,  1,    252,  1,    252,  1,    253,  1,    253,  1,    253,  5,    253,  2586, 8,    253,  10,   253,  12,   253,  2589, 9,
        253,  1,    253,  3,    253,  2592, 8,    253,  1,    254,  1,    254,  1,    254,  3,    254,  2597, 8,    254,  1,    254,  0,    0,    255,  0,    2,    4,    6,    8,    10,   12,   14,
        16,   18,   20,   22,   24,   26,   28,   30,   32,   34,   36,   38,   40,   42,   44,   46,   48,   50,   52,   54,   56,   58,   60,   62,   64,   66,   68,   70,   72,   74,   76,   78,
        80,   82,   84,   86,   88,   90,   92,   94,   96,   98,   100,  102,  104,  106,  108,  110,  112,  114,  116,  118,  120,  122,  124,  126,  128,  130,  132,  134,  136,  138,  140,  142,
        144,  146,  148,  150,  152,  154,  156,  158,  160,  162,  164,  166,  168,  170,  172,  174,  176,  178,  180,  182,  184,  186,  188,  190,  192,  194,  196,  198,  200,  202,  204,  206,
        208,  210,  212,  214,  216,  218,  220,  222,  224,  226,  228,  230,  232,  234,  236,  238,  240,  242,  244,  246,  248,  250,  252,  254,  256,  258,  260,  262,  264,  266,  268,  270,
        272,  274,  276,  278,  280,  282,  284,  286,  288,  290,  292,  294,  296,  298,  300,  302,  304,  306,  308,  310,  312,  314,  316,  318,  320,  322,  324,  326,  328,  330,  332,  334,
        336,  338,  340,  342,  344,  346,  348,  350,  352,  354,  356,  358,  360,  362,  364,  366,  368,  370,  372,  374,  376,  378,  380,  382,  384,  386,  388,  390,  392,  394,  396,  398,
        400,  402,  404,  406,  408,  410,  412,  414,  416,  418,  420,  422,  424,  426,  428,  430,  432,  434,  436,  438,  440,  442,  444,  446,  448,  450,  452,  454,  456,  458,  460,  462,
        464,  466,  468,  470,  472,  474,  476,  478,  480,  482,  484,  486,  488,  490,  492,  494,  496,  498,  500,  502,  504,  506,  508,  0,    15,   3,    0,    112,  112,  117,  117,  158,
        158,  2,    0,    140,  140,  148,  149,  2,    0,    23,   23,   97,   97,   17,   0,    8,    8,    19,   21,   25,   25,   29,   29,   31,   31,   34,   34,   42,   42,   46,   46,   51,
        51,   64,   64,   68,   68,   71,   71,   86,   86,   92,   94,   100,  100,  102,  102,  105,  105,  1,    0,    118,  119,  2,    0,    38,   38,   63,   63,   5,    0,    7,    7,    50,
        50,   55,   55,   61,   61,   110,  111,  5,    0,    16,   16,   38,   38,   40,   40,   45,   45,   63,   63,   3,    0,    49,   49,   75,   75,   146,  147,  3,    0,    131,  132,  134,
        134,  150,  152,  3,    0,    81,   82,   87,   88,   90,   91,   2,    0,    17,   17,   78,   78,   1,    0,    148,  149,  2,    0,    31,   31,   68,   68,   2,    0,    37,   37,   70,
        70,   2797, 0,    510,  1,    0,    0,    0,    2,    512,  1,    0,    0,    0,    4,    515,  1,    0,    0,    0,    6,    527,  1,    0,    0,    0,    8,    529,  1,    0,    0,    0,
        10,   537,  1,    0,    0,    0,    12,   539,  1,    0,    0,    0,    14,   541,  1,    0,    0,    0,    16,   552,  1,    0,    0,    0,    18,   568,  1,    0,    0,    0,    20,   572,
        1,    0,    0,    0,    22,   574,  1,    0,    0,    0,    24,   579,  1,    0,    0,    0,    26,   599,  1,    0,    0,    0,    28,   623,  1,    0,    0,    0,    30,   628,  1,    0,
        0,    0,    32,   633,  1,    0,    0,    0,    34,   637,  1,    0,    0,    0,    36,   639,  1,    0,    0,    0,    38,   650,  1,    0,    0,    0,    40,   658,  1,    0,    0,    0,
        42,   662,  1,    0,    0,    0,    44,   670,  1,    0,    0,    0,    46,   682,  1,    0,    0,    0,    48,   684,  1,    0,    0,    0,    50,   692,  1,    0,    0,    0,    52,   697,
        1,    0,    0,    0,    54,   705,  1,    0,    0,    0,    56,   745,  1,    0,    0,    0,    58,   750,  1,    0,    0,    0,    60,   759,  1,    0,    0,    0,    62,   777,  1,    0,
        0,    0,    64,   779,  1,    0,    0,    0,    66,   804,  1,    0,    0,    0,    68,   807,  1,    0,    0,    0,    70,   818,  1,    0,    0,    0,    72,   824,  1,    0,    0,    0,
        74,   832,  1,    0,    0,    0,    76,   837,  1,    0,    0,    0,    78,   850,  1,    0,    0,    0,    80,   867,  1,    0,    0,    0,    82,   876,  1,    0,    0,    0,    84,   878,
        1,    0,    0,    0,    86,   886,  1,    0,    0,    0,    88,   900,  1,    0,    0,    0,    90,   918,  1,    0,    0,    0,    92,   928,  1,    0,    0,    0,    94,   934,  1,    0,
        0,    0,    96,   938,  1,    0,    0,    0,    98,   941,  1,    0,    0,    0,    100,  950,  1,    0,    0,    0,    102,  966,  1,    0,    0,    0,    104,  975,  1,    0,    0,    0,
        106,  984,  1,    0,    0,    0,    108,  986,  1,    0,    0,    0,    110,  989,  1,    0,    0,    0,    112,  995,  1,    0,    0,    0,    114,  1004, 1,    0,    0,    0,    116,  1023,
        1,    0,    0,    0,    118,  1028, 1,    0,    0,    0,    120,  1033, 1,    0,    0,    0,    122,  1035, 1,    0,    0,    0,    124,  1040, 1,    0,    0,    0,    126,  1050, 1,    0,
        0,    0,    128,  1055, 1,    0,    0,    0,    130,  1062, 1,    0,    0,    0,    132,  1067, 1,    0,    0,    0,    134,  1072, 1,    0,    0,    0,    136,  1080, 1,    0,    0,    0,
        138,  1085, 1,    0,    0,    0,    140,  1090, 1,    0,    0,    0,    142,  1095, 1,    0,    0,    0,    144,  1097, 1,    0,    0,    0,    146,  1099, 1,    0,    0,    0,    148,  1107,
        1,    0,    0,    0,    150,  1112, 1,    0,    0,    0,    152,  1116, 1,    0,    0,    0,    154,  1121, 1,    0,    0,    0,    156,  1123, 1,    0,    0,    0,    158,  1136, 1,    0,
        0,    0,    160,  1138, 1,    0,    0,    0,    162,  1140, 1,    0,    0,    0,    164,  1144, 1,    0,    0,    0,    166,  1152, 1,    0,    0,    0,    168,  1190, 1,    0,    0,    0,
        170,  1195, 1,    0,    0,    0,    172,  1198, 1,    0,    0,    0,    174,  1203, 1,    0,    0,    0,    176,  1218, 1,    0,    0,    0,    178,  1220, 1,    0,    0,    0,    180,  1227,
        1,    0,    0,    0,    182,  1232, 1,    0,    0,    0,    184,  1238, 1,    0,    0,    0,    186,  1242, 1,    0,    0,    0,    188,  1244, 1,    0,    0,    0,    190,  1256, 1,    0,
        0,    0,    192,  1268, 1,    0,    0,    0,    194,  1286, 1,    0,    0,    0,    196,  1288, 1,    0,    0,    0,    198,  1297, 1,    0,    0,    0,    200,  1301, 1,    0,    0,    0,
        202,  1306, 1,    0,    0,    0,    204,  1310, 1,    0,    0,    0,    206,  1318, 1,    0,    0,    0,    208,  1320, 1,    0,    0,    0,    210,  1330, 1,    0,    0,    0,    212,  1359,
        1,    0,    0,    0,    214,  1361, 1,    0,    0,    0,    216,  1367, 1,    0,    0,    0,    218,  1375, 1,    0,    0,    0,    220,  1383, 1,    0,    0,    0,    222,  1385, 1,    0,
        0,    0,    224,  1393, 1,    0,    0,    0,    226,  1401, 1,    0,    0,    0,    228,  1409, 1,    0,    0,    0,    230,  1413, 1,    0,    0,    0,    232,  1415, 1,    0,    0,    0,
        234,  1424, 1,    0,    0,    0,    236,  1451, 1,    0,    0,    0,    238,  1464, 1,    0,    0,    0,    240,  1466, 1,    0,    0,    0,    242,  1484, 1,    0,    0,    0,    244,  1496,
        1,    0,    0,    0,    246,  1499, 1,    0,    0,    0,    248,  1517, 1,    0,    0,    0,    250,  1519, 1,    0,    0,    0,    252,  1521, 1,    0,    0,    0,    254,  1526, 1,    0,
        0,    0,    256,  1534, 1,    0,    0,    0,    258,  1542, 1,    0,    0,    0,    260,  1550, 1,    0,    0,    0,    262,  1561, 1,    0,    0,    0,    264,  1574, 1,    0,    0,    0,
        266,  1588, 1,    0,    0,    0,    268,  1594, 1,    0,    0,    0,    270,  1610, 1,    0,    0,    0,    272,  1612, 1,    0,    0,    0,    274,  1615, 1,    0,    0,    0,    276,  1621,
        1,    0,    0,    0,    278,  1628, 1,    0,    0,    0,    280,  1630, 1,    0,    0,    0,    282,  1632, 1,    0,    0,    0,    284,  1640, 1,    0,    0,    0,    286,  1643, 1,    0,
        0,    0,    288,  1657, 1,    0,    0,    0,    290,  1659, 1,    0,    0,    0,    292,  1663, 1,    0,    0,    0,    294,  1675, 1,    0,    0,    0,    296,  1677, 1,    0,    0,    0,
        298,  1687, 1,    0,    0,    0,    300,  1691, 1,    0,    0,    0,    302,  1695, 1,    0,    0,    0,    304,  1700, 1,    0,    0,    0,    306,  1710, 1,    0,    0,    0,    308,  1718,
        1,    0,    0,    0,    310,  1720, 1,    0,    0,    0,    312,  1725, 1,    0,    0,    0,    314,  1739, 1,    0,    0,    0,    316,  1747, 1,    0,    0,    0,    318,  1750, 1,    0,
        0,    0,    320,  1755, 1,    0,    0,    0,    322,  1781, 1,    0,    0,    0,    324,  1786, 1,    0,    0,    0,    326,  1789, 1,    0,    0,    0,    328,  1821, 1,    0,    0,    0,
        330,  1826, 1,    0,    0,    0,    332,  1829, 1,    0,    0,    0,    334,  1833, 1,    0,    0,    0,    336,  1836, 1,    0,    0,    0,    338,  1850, 1,    0,    0,    0,    340,  1856,
        1,    0,    0,    0,    342,  1858, 1,    0,    0,    0,    344,  1873, 1,    0,    0,    0,    346,  1878, 1,    0,    0,    0,    348,  1892, 1,    0,    0,    0,    350,  1897, 1,    0,
        0,    0,    352,  1903, 1,    0,    0,    0,    354,  1906, 1,    0,    0,    0,    356,  1914, 1,    0,    0,    0,    358,  1932, 1,    0,    0,    0,    360,  1937, 1,    0,    0,    0,
        362,  1941, 1,    0,    0,    0,    364,  1972, 1,    0,    0,    0,    366,  1975, 1,    0,    0,    0,    368,  1987, 1,    0,    0,    0,    370,  1999, 1,    0,    0,    0,    372,  2001,
        1,    0,    0,    0,    374,  2007, 1,    0,    0,    0,    376,  2009, 1,    0,    0,    0,    378,  2015, 1,    0,    0,    0,    380,  2018, 1,    0,    0,    0,    382,  2029, 1,    0,
        0,    0,    384,  2040, 1,    0,    0,    0,    386,  2046, 1,    0,    0,    0,    388,  2049, 1,    0,    0,    0,    390,  2060, 1,    0,    0,    0,    392,  2068, 1,    0,    0,    0,
        394,  2078, 1,    0,    0,    0,    396,  2082, 1,    0,    0,    0,    398,  2084, 1,    0,    0,    0,    400,  2089, 1,    0,    0,    0,    402,  2098, 1,    0,    0,    0,    404,  2111,
        1,    0,    0,    0,    406,  2114, 1,    0,    0,    0,    408,  2125, 1,    0,    0,    0,    410,  2146, 1,    0,    0,    0,    412,  2148, 1,    0,    0,    0,    414,  2154, 1,    0,
        0,    0,    416,  2157, 1,    0,    0,    0,    418,  2167, 1,    0,    0,    0,    420,  2180, 1,    0,    0,    0,    422,  2192, 1,    0,    0,    0,    424,  2194, 1,    0,    0,    0,
        426,  2212, 1,    0,    0,    0,    428,  2224, 1,    0,    0,    0,    430,  2234, 1,    0,    0,    0,    432,  2240, 1,    0,    0,    0,    434,  2258, 1,    0,    0,    0,    436,  2286,
        1,    0,    0,    0,    438,  2311, 1,    0,    0,    0,    440,  2316, 1,    0,    0,    0,    442,  2326, 1,    0,    0,    0,    444,  2328, 1,    0,    0,    0,    446,  2335, 1,    0,
        0,    0,    448,  2341, 1,    0,    0,    0,    450,  2347, 1,    0,    0,    0,    452,  2359, 1,    0,    0,    0,    454,  2373, 1,    0,    0,    0,    456,  2389, 1,    0,    0,    0,
        458,  2394, 1,    0,    0,    0,    460,  2397, 1,    0,    0,    0,    462,  2401, 1,    0,    0,    0,    464,  2403, 1,    0,    0,    0,    466,  2412, 1,    0,    0,    0,    468,  2428,
        1,    0,    0,    0,    470,  2431, 1,    0,    0,    0,    472,  2437, 1,    0,    0,    0,    474,  2451, 1,    0,    0,    0,    476,  2455, 1,    0,    0,    0,    478,  2457, 1,    0,
        0,    0,    480,  2466, 1,    0,    0,    0,    482,  2471, 1,    0,    0,    0,    484,  2477, 1,    0,    0,    0,    486,  2487, 1,    0,    0,    0,    488,  2490, 1,    0,    0,    0,
        490,  2493, 1,    0,    0,    0,    492,  2505, 1,    0,    0,    0,    494,  2507, 1,    0,    0,    0,    496,  2521, 1,    0,    0,    0,    498,  2535, 1,    0,    0,    0,    500,  2547,
        1,    0,    0,    0,    502,  2555, 1,    0,    0,    0,    504,  2568, 1,    0,    0,    0,    506,  2591, 1,    0,    0,    0,    508,  2593, 1,    0,    0,    0,    510,  511,  7,    0,
        0,    0,    511,  1,    1,    0,    0,    0,    512,  513,  5,    2,    0,    0,    513,  514,  3,    472,  236,  0,    514,  3,    1,    0,    0,    0,    515,  517,  3,    232,  116,  0,
        516,  518,  3,    488,  244,  0,    517,  516,  1,    0,    0,    0,    517,  518,  1,    0,    0,    0,    518,  521,  1,    0,    0,    0,    519,  520,  5,    135,  0,    0,    520,  522,
        3,    192,  96,   0,    521,  519,  1,    0,    0,    0,    521,  522,  1,    0,    0,    0,    522,  523,  1,    0,    0,    0,    523,  524,  5,    3,    0,    0,    524,  5,    1,    0,
        0,    0,    525,  528,  3,    192,  96,   0,    526,  528,  5,    60,   0,    0,    527,  525,  1,    0,    0,    0,    527,  526,  1,    0,    0,    0,    528,  7,    1,    0,    0,    0,
        529,  530,  3,    42,   21,   0,    530,  9,    1,    0,    0,    0,    531,  532,  3,    292,  146,  0,    532,  533,  5,    141,  0,    0,    533,  534,  3,    6,    3,    0,    534,  535,
        5,    142,  0,    0,    535,  538,  1,    0,    0,    0,    536,  538,  3,    6,    3,    0,    537,  531,  1,    0,    0,    0,    537,  536,  1,    0,    0,    0,    538,  11,   1,    0,
        0,    0,    539,  540,  7,    1,    0,    0,    540,  13,   1,    0,    0,    0,    541,  542,  5,    141,  0,    0,    542,  547,  3,    150,  75,   0,    543,  544,  5,    139,  0,    0,
        544,  546,  3,    150,  75,   0,    545,  543,  1,    0,    0,    0,    546,  549,  1,    0,    0,    0,    547,  545,  1,    0,    0,    0,    547,  548,  1,    0,    0,    0,    548,  550,
        1,    0,    0,    0,    549,  547,  1,    0,    0,    0,    550,  551,  5,    142,  0,    0,    551,  15,   1,    0,    0,    0,    552,  553,  5,    5,    0,    0,    553,  556,  3,    18,
        9,    0,    554,  555,  5,    145,  0,    0,    555,  557,  3,    20,   10,   0,    556,  554,  1,    0,    0,    0,    556,  557,  1,    0,    0,    0,    557,  558,  1,    0,    0,    0,
        558,  559,  5,    41,   0,    0,    559,  561,  3,    292,  146,  0,    560,  562,  3,    424,  212,  0,    561,  560,  1,    0,    0,    0,    561,  562,  1,    0,    0,    0,    562,  563,
        1,    0,    0,    0,    563,  564,  5,    138,  0,    0,    564,  17,   1,    0,    0,    0,    565,  569,  3,    230,  115,  0,    566,  569,  5,    126,  0,    0,    567,  569,  5,    127,
        0,    0,    568,  565,  1,    0,    0,    0,    568,  566,  1,    0,    0,    0,    568,  567,  1,    0,    0,    0,    569,  19,   1,    0,    0,    0,    570,  573,  3,    450,  225,  0,
        571,  573,  3,    472,  236,  0,    572,  570,  1,    0,    0,    0,    572,  571,  1,    0,    0,    0,    573,  21,   1,    0,    0,    0,    574,  577,  5,    52,   0,    0,    575,  578,
        3,    366,  183,  0,    576,  578,  3,    472,  236,  0,    577,  575,  1,    0,    0,    0,    577,  576,  1,    0,    0,    0,    578,  23,   1,    0,    0,    0,    579,  580,  5,    8,
        0,    0,    580,  581,  3,    230,  115,  0,    581,  582,  5,    58,   0,    0,    582,  583,  3,    230,  115,  0,    583,  584,  5,    41,   0,    0,    584,  585,  3,    26,   13,   0,
        585,  586,  5,    12,   0,    0,    586,  587,  3,    30,   15,   0,    587,  589,  5,    24,   0,    0,    588,  590,  5,    8,    0,    0,    589,  588,  1,    0,    0,    0,    589,  590,
        1,    0,    0,    0,    590,  592,  1,    0,    0,    0,    591,  593,  3,    230,  115,  0,    592,  591,  1,    0,    0,    0,    592,  593,  1,    0,    0,    0,    593,  594,  1,    0,
        0,    0,    594,  595,  5,    138,  0,    0,    595,  25,   1,    0,    0,    0,    596,  598,  3,    56,   28,   0,    597,  596,  1,    0,    0,    0,    598,  601,  1,    0,    0,    0,
        599,  597,  1,    0,    0,    0,    599,  600,  1,    0,    0,    0,    600,  27,   1,    0,    0,    0,    601,  599,  1,    0,    0,    0,    602,  624,  3,    64,   32,   0,    603,  624,
        3,    362,  181,  0,    604,  606,  3,    272,  136,  0,    605,  604,  1,    0,    0,    0,    605,  606,  1,    0,    0,    0,    606,  607,  1,    0,    0,    0,    607,  624,  3,    102,
        51,   0,    608,  610,  3,    272,  136,  0,    609,  608,  1,    0,    0,    0,    609,  610,  1,    0,    0,    0,    610,  611,  1,    0,    0,    0,    611,  624,  3,    98,   49,   0,
        612,  614,  3,    272,  136,  0,    613,  612,  1,    0,    0,    0,    613,  614,  1,    0,    0,    0,    614,  616,  1,    0,    0,    0,    615,  617,  5,    66,   0,    0,    616,  615,
        1,    0,    0,    0,    616,  617,  1,    0,    0,    0,    617,  618,  1,    0,    0,    0,    618,  624,  3,    104,  52,   0,    619,  624,  3,    90,   45,   0,    620,  624,  3,    210,
        105,  0,    621,  624,  3,    100,  50,   0,    622,  624,  3,    438,  219,  0,    623,  602,  1,    0,    0,    0,    623,  603,  1,    0,    0,    0,    623,  605,  1,    0,    0,    0,
        623,  609,  1,    0,    0,    0,    623,  613,  1,    0,    0,    0,    623,  619,  1,    0,    0,    0,    623,  620,  1,    0,    0,    0,    623,  621,  1,    0,    0,    0,    623,  622,
        1,    0,    0,    0,    624,  29,   1,    0,    0,    0,    625,  627,  3,    28,   14,   0,    626,  625,  1,    0,    0,    0,    627,  630,  1,    0,    0,    0,    628,  626,  1,    0,
        0,    0,    628,  629,  1,    0,    0,    0,    629,  31,   1,    0,    0,    0,    630,  628,  1,    0,    0,    0,    631,  634,  3,    496,  248,  0,    632,  634,  3,    128,  64,   0,
        633,  631,  1,    0,    0,    0,    633,  632,  1,    0,    0,    0,    634,  33,   1,    0,    0,    0,    635,  638,  3,    494,  247,  0,    636,  638,  3,    126,  63,   0,    637,  635,
        1,    0,    0,    0,    637,  636,  1,    0,    0,    0,    638,  35,   1,    0,    0,    0,    639,  640,  5,    10,   0,    0,    640,  643,  3,    106,  53,   0,    641,  642,  5,    79,
        0,    0,    642,  644,  3,    192,  96,   0,    643,  641,  1,    0,    0,    0,    643,  644,  1,    0,    0,    0,    644,  647,  1,    0,    0,    0,    645,  646,  5,    84,   0,    0,
        646,  648,  3,    192,  96,   0,    647,  645,  1,    0,    0,    0,    647,  648,  1,    0,    0,    0,    648,  37,   1,    0,    0,    0,    649,  651,  3,    272,  136,  0,    650,  649,
        1,    0,    0,    0,    650,  651,  1,    0,    0,    0,    651,  652,  1,    0,    0,    0,    652,  653,  3,    36,   18,   0,    653,  654,  5,    138,  0,    0,    654,  39,   1,    0,
        0,    0,    655,  656,  3,    206,  103,  0,    656,  657,  5,    133,  0,    0,    657,  659,  1,    0,    0,    0,    658,  655,  1,    0,    0,    0,    658,  659,  1,    0,    0,    0,
        659,  660,  1,    0,    0,    0,    660,  661,  3,    10,   5,    0,    661,  41,   1,    0,    0,    0,    662,  667,  3,    40,   20,   0,    663,  664,  5,    139,  0,    0,    664,  666,
        3,    40,   20,   0,    665,  663,  1,    0,    0,    0,    666,  669,  1,    0,    0,    0,    667,  665,  1,    0,    0,    0,    667,  668,  1,    0,    0,    0,    668,  43,   1,    0,
        0,    0,    669,  667,  1,    0,    0,    0,    670,  671,  5,    11,   0,    0,    671,  672,  3,    272,  136,  0,    672,  673,  3,    292,  146,  0,    673,  674,  5,    138,  0,    0,
        674,  45,   1,    0,    0,    0,    675,  683,  3,    230,  115,  0,    676,  683,  5,    72,   0,    0,    677,  683,  5,    73,   0,    0,    678,  683,  5,    3,    0,    0,    679,  683,
        5,    96,   0,    0,    680,  683,  5,    77,   0,    0,    681,  683,  5,    98,   0,    0,    682,  675,  1,    0,    0,    0,    682,  676,  1,    0,    0,    0,    682,  677,  1,    0,
        0,    0,    682,  678,  1,    0,    0,    0,    682,  679,  1,    0,    0,    0,    682,  680,  1,    0,    0,    0,    682,  681,  1,    0,    0,    0,    683,  47,   1,    0,    0,    0,
        684,  685,  5,    11,   0,    0,    685,  686,  3,    46,   23,   0,    686,  687,  5,    58,   0,    0,    687,  688,  3,    178,  89,   0,    688,  689,  5,    41,   0,    0,    689,  690,
        3,    192,  96,   0,    690,  691,  5,    138,  0,    0,    691,  49,   1,    0,    0,    0,    692,  693,  3,    230,  115,  0,    693,  694,  5,    138,  0,    0,    694,  51,   1,    0,
        0,    0,    695,  696,  5,    104,  0,    0,    696,  698,  3,    158,  79,   0,    697,  695,  1,    0,    0,    0,    697,  698,  1,    0,    0,    0,    698,  700,  1,    0,    0,    0,
        699,  701,  3,    218,  109,  0,    700,  699,  1,    0,    0,    0,    700,  701,  1,    0,    0,    0,    701,  703,  1,    0,    0,    0,    702,  704,  3,    342,  171,  0,    703,  702,
        1,    0,    0,    0,    703,  704,  1,    0,    0,    0,    704,  53,   1,    0,    0,    0,    705,  706,  5,    30,   0,    0,    706,  710,  3,    62,   31,   0,    707,  709,  3,    498,
        249,  0,    708,  707,  1,    0,    0,    0,    709,  712,  1,    0,    0,    0,    710,  708,  1,    0,    0,    0,    710,  711,  1,    0,    0,    0,    711,  716,  1,    0,    0,    0,
        712,  710,  1,    0,    0,    0,    713,  715,  3,    120,  60,   0,    714,  713,  1,    0,    0,    0,    715,  718,  1,    0,    0,    0,    716,  714,  1,    0,    0,    0,    716,  717,
        1,    0,    0,    0,    717,  719,  1,    0,    0,    0,    718,  716,  1,    0,    0,    0,    719,  720,  5,    24,   0,    0,    720,  721,  5,    30,   0,    0,    721,  722,  5,    138,
        0,    0,    722,  55,   1,    0,    0,    0,    723,  746,  3,    454,  227,  0,    724,  746,  3,    452,  226,  0,    725,  746,  3,    490,  245,  0,    726,  746,  3,    470,  235,  0,
        727,  746,  3,    124,  62,   0,    728,  746,  3,    418,  209,  0,    729,  746,  3,    502,  251,  0,    730,  746,  3,    196,  98,   0,    731,  746,  3,    16,   8,    0,    732,  746,
        3,    88,   44,   0,    733,  746,  3,    44,   22,   0,    734,  746,  3,    48,   24,   0,    735,  746,  3,    122,  61,   0,    736,  746,  3,    146,  73,   0,    737,  746,  3,    446,
        223,  0,    738,  746,  3,    498,  249,  0,    739,  746,  3,    226,  113,  0,    740,  746,  3,    224,  112,  0,    741,  746,  3,    306,  153,  0,    742,  746,  3,    448,  224,  0,
        743,  746,  3,    368,  184,  0,    744,  746,  3,    482,  241,  0,    745,  723,  1,    0,    0,    0,    745,  724,  1,    0,    0,    0,    745,  725,  1,    0,    0,    0,    745,  726,
        1,    0,    0,    0,    745,  727,  1,    0,    0,    0,    745,  728,  1,    0,    0,    0,    745,  729,  1,    0,    0,    0,    745,  730,  1,    0,    0,    0,    745,  731,  1,    0,
        0,    0,    745,  732,  1,    0,    0,    0,    745,  733,  1,    0,    0,    0,    745,  734,  1,    0,    0,    0,    745,  735,  1,    0,    0,    0,    745,  736,  1,    0,    0,    0,
        745,  737,  1,    0,    0,    0,    745,  738,  1,    0,    0,    0,    745,  739,  1,    0,    0,    0,    745,  740,  1,    0,    0,    0,    745,  741,  1,    0,    0,    0,    745,  742,
        1,    0,    0,    0,    745,  743,  1,    0,    0,    0,    745,  744,  1,    0,    0,    0,    746,  57,   1,    0,    0,    0,    747,  749,  3,    56,   28,   0,    748,  747,  1,    0,
        0,    0,    749,  752,  1,    0,    0,    0,    750,  748,  1,    0,    0,    0,    750,  751,  1,    0,    0,    0,    751,  59,   1,    0,    0,    0,    752,  750,  1,    0,    0,    0,
        753,  757,  3,    214,  107,  0,    754,  755,  3,    218,  109,  0,    755,  756,  5,    138,  0,    0,    756,  758,  1,    0,    0,    0,    757,  754,  1,    0,    0,    0,    757,  758,
        1,    0,    0,    0,    758,  760,  1,    0,    0,    0,    759,  753,  1,    0,    0,    0,    759,  760,  1,    0,    0,    0,    760,  767,  1,    0,    0,    0,    761,  765,  3,    338,
        169,  0,    762,  763,  3,    342,  171,  0,    763,  764,  5,    138,  0,    0,    764,  766,  1,    0,    0,    0,    765,  762,  1,    0,    0,    0,    765,  766,  1,    0,    0,    0,
        766,  768,  1,    0,    0,    0,    767,  761,  1,    0,    0,    0,    767,  768,  1,    0,    0,    0,    768,  61,   1,    0,    0,    0,    769,  774,  3,    230,  115,  0,    770,  771,
        5,    141,  0,    0,    771,  772,  3,    238,  119,  0,    772,  773,  5,    142,  0,    0,    773,  775,  1,    0,    0,    0,    774,  770,  1,    0,    0,    0,    774,  775,  1,    0,
        0,    0,    775,  778,  1,    0,    0,    0,    776,  778,  3,    292,  146,  0,    777,  769,  1,    0,    0,    0,    777,  776,  1,    0,    0,    0,    778,  63,   1,    0,    0,    0,
        779,  780,  3,    272,  136,  0,    780,  785,  5,    13,   0,    0,    781,  782,  5,    141,  0,    0,    782,  783,  3,    192,  96,   0,    783,  784,  5,    142,  0,    0,    784,  786,
        1,    0,    0,    0,    785,  781,  1,    0,    0,    0,    785,  786,  1,    0,    0,    0,    786,  788,  1,    0,    0,    0,    787,  789,  5,    41,   0,    0,    788,  787,  1,    0,
        0,    0,    788,  789,  1,    0,    0,    0,    789,  790,  1,    0,    0,    0,    790,  791,  3,    60,   30,   0,    791,  792,  3,    58,   29,   0,    792,  793,  5,    12,   0,    0,
        793,  794,  3,    66,   33,   0,    794,  795,  5,    24,   0,    0,    795,  797,  5,    13,   0,    0,    796,  798,  3,    230,  115,  0,    797,  796,  1,    0,    0,    0,    797,  798,
        1,    0,    0,    0,    798,  799,  1,    0,    0,    0,    799,  800,  5,    138,  0,    0,    800,  65,   1,    0,    0,    0,    801,  803,  3,    28,   14,   0,    802,  801,  1,    0,
        0,    0,    803,  806,  1,    0,    0,    0,    804,  802,  1,    0,    0,    0,    804,  805,  1,    0,    0,    0,    805,  67,   1,    0,    0,    0,    806,  804,  1,    0,    0,    0,
        807,  809,  5,    71,   0,    0,    808,  810,  3,    4,    2,    0,    809,  808,  1,    0,    0,    0,    809,  810,  1,    0,    0,    0,    810,  812,  1,    0,    0,    0,    811,  813,
        3,    484,  242,  0,    812,  811,  1,    0,    0,    0,    812,  813,  1,    0,    0,    0,    813,  814,  1,    0,    0,    0,    814,  815,  3,    480,  240,  0,    815,  816,  5,    138,
        0,    0,    816,  69,   1,    0,    0,    0,    817,  819,  3,    74,   37,   0,    818,  817,  1,    0,    0,    0,    818,  819,  1,    0,    0,    0,    819,  820,  1,    0,    0,    0,
        820,  821,  3,    292,  146,  0,    821,  822,  5,    133,  0,    0,    822,  823,  3,    192,  96,   0,    823,  71,   1,    0,    0,    0,    824,  829,  3,    70,   35,   0,    825,  826,
        5,    139,  0,    0,    826,  828,  3,    70,   35,   0,    827,  825,  1,    0,    0,    0,    828,  831,  1,    0,    0,    0,    829,  827,  1,    0,    0,    0,    829,  830,  1,    0,
        0,    0,    830,  73,   1,    0,    0,    0,    831,  829,  1,    0,    0,    0,    832,  833,  5,    30,   0,    0,    833,  834,  3,    292,  146,  0,    834,  835,  5,    104,  0,    0,
        835,  75,   1,    0,    0,    0,    836,  838,  3,    272,  136,  0,    837,  836,  1,    0,    0,    0,    837,  838,  1,    0,    0,    0,    838,  839,  1,    0,    0,    0,    839,  841,
        5,    15,   0,    0,    840,  842,  3,    72,   36,   0,    841,  840,  1,    0,    0,    0,    841,  842,  1,    0,    0,    0,    842,  845,  1,    0,    0,    0,    843,  844,  5,    108,
        0,    0,    844,  846,  3,    106,  53,   0,    845,  843,  1,    0,    0,    0,    845,  846,  1,    0,    0,    0,    846,  847,  1,    0,    0,    0,    847,  848,  5,    138,  0,    0,
        848,  77,   1,    0,    0,    0,    849,  851,  3,    272,  136,  0,    850,  849,  1,    0,    0,    0,    850,  851,  1,    0,    0,    0,    851,  852,  1,    0,    0,    0,    852,  853,
        5,    18,   0,    0,    853,  854,  3,    192,  96,   0,    854,  856,  5,    41,   0,    0,    855,  857,  3,    80,   40,   0,    856,  855,  1,    0,    0,    0,    857,  858,  1,    0,
        0,    0,    858,  856,  1,    0,    0,    0,    858,  859,  1,    0,    0,    0,    859,  860,  1,    0,    0,    0,    860,  861,  5,    24,   0,    0,    861,  863,  5,    18,   0,    0,
        862,  864,  3,    230,  115,  0,    863,  862,  1,    0,    0,    0,    863,  864,  1,    0,    0,    0,    864,  865,  1,    0,    0,    0,    865,  866,  5,    138,  0,    0,    866,  79,
        1,    0,    0,    0,    867,  868,  5,    108,  0,    0,    868,  869,  3,    84,   42,   0,    869,  870,  5,    133,  0,    0,    870,  871,  3,    408,  204,  0,    871,  81,   1,    0,
        0,    0,    872,  877,  3,    230,  115,  0,    873,  877,  3,    148,  74,   0,    874,  877,  3,    426,  213,  0,    875,  877,  5,    62,   0,    0,    876,  872,  1,    0,    0,    0,
        876,  873,  1,    0,    0,    0,    876,  874,  1,    0,    0,    0,    876,  875,  1,    0,    0,    0,    877,  83,   1,    0,    0,    0,    878,  883,  3,    82,   41,   0,    879,  880,
        5,    153,  0,    0,    880,  882,  3,    82,   41,   0,    881,  879,  1,    0,    0,    0,    882,  885,  1,    0,    0,    0,    883,  881,  1,    0,    0,    0,    883,  884,  1,    0,
        0,    0,    884,  85,   1,    0,    0,    0,    885,  883,  1,    0,    0,    0,    886,  887,  5,    30,   0,    0,    887,  891,  3,    92,   46,   0,    888,  889,  3,    52,   26,   0,
        889,  890,  5,    138,  0,    0,    890,  892,  1,    0,    0,    0,    891,  888,  1,    0,    0,    0,    891,  892,  1,    0,    0,    0,    892,  894,  1,    0,    0,    0,    893,  895,
        3,    54,   27,   0,    894,  893,  1,    0,    0,    0,    894,  895,  1,    0,    0,    0,    895,  896,  1,    0,    0,    0,    896,  897,  5,    24,   0,    0,    897,  898,  5,    30,
        0,    0,    898,  899,  5,    138,  0,    0,    899,  87,   1,    0,    0,    0,    900,  901,  5,    19,   0,    0,    901,  903,  3,    230,  115,  0,    902,  904,  5,    41,   0,    0,
        903,  902,  1,    0,    0,    0,    903,  904,  1,    0,    0,    0,    904,  906,  1,    0,    0,    0,    905,  907,  3,    214,  107,  0,    906,  905,  1,    0,    0,    0,    906,  907,
        1,    0,    0,    0,    907,  909,  1,    0,    0,    0,    908,  910,  3,    338,  169,  0,    909,  908,  1,    0,    0,    0,    909,  910,  1,    0,    0,    0,    910,  911,  1,    0,
        0,    0,    911,  912,  5,    24,   0,    0,    912,  914,  5,    19,   0,    0,    913,  915,  3,    230,  115,  0,    914,  913,  1,    0,    0,    0,    914,  915,  1,    0,    0,    0,
        915,  916,  1,    0,    0,    0,    916,  917,  5,    138,  0,    0,    917,  89,   1,    0,    0,    0,    918,  919,  3,    272,  136,  0,    919,  921,  3,    242,  121,  0,    920,  922,
        3,    218,  109,  0,    921,  920,  1,    0,    0,    0,    921,  922,  1,    0,    0,    0,    922,  924,  1,    0,    0,    0,    923,  925,  3,    342,  171,  0,    924,  923,  1,    0,
        0,    0,    924,  925,  1,    0,    0,    0,    925,  926,  1,    0,    0,    0,    926,  927,  5,    138,  0,    0,    927,  91,   1,    0,    0,    0,    928,  929,  3,    244,  122,  0,
        929,  930,  5,    145,  0,    0,    930,  931,  3,    292,  146,  0,    931,  93,   1,    0,    0,    0,    932,  935,  3,    32,   16,   0,    933,  935,  3,    380,  190,  0,    934,  932,
        1,    0,    0,    0,    934,  933,  1,    0,    0,    0,    935,  95,   1,    0,    0,    0,    936,  939,  3,    34,   17,   0,    937,  939,  3,    382,  191,  0,    938,  936,  1,    0,
        0,    0,    938,  937,  1,    0,    0,    0,    939,  97,   1,    0,    0,    0,    940,  942,  3,    272,  136,  0,    941,  940,  1,    0,    0,    0,    941,  942,  1,    0,    0,    0,
        942,  944,  1,    0,    0,    0,    943,  945,  5,    66,   0,    0,    944,  943,  1,    0,    0,    0,    944,  945,  1,    0,    0,    0,    945,  946,  1,    0,    0,    0,    946,  947,
        3,    36,   18,   0,    947,  948,  5,    138,  0,    0,    948,  99,   1,    0,    0,    0,    949,  951,  3,    272,  136,  0,    950,  949,  1,    0,    0,    0,    950,  951,  1,    0,
        0,    0,    951,  952,  1,    0,    0,    0,    952,  954,  5,    15,   0,    0,    953,  955,  3,    72,   36,   0,    954,  953,  1,    0,    0,    0,    954,  955,  1,    0,    0,    0,
        955,  957,  1,    0,    0,    0,    956,  958,  3,    404,  202,  0,    957,  956,  1,    0,    0,    0,    957,  958,  1,    0,    0,    0,    958,  961,  1,    0,    0,    0,    959,  960,
        5,    108,  0,    0,    960,  962,  3,    106,  53,   0,    961,  959,  1,    0,    0,    0,    961,  962,  1,    0,    0,    0,    962,  963,  1,    0,    0,    0,    963,  964,  5,    138,
        0,    0,    964,  101,  1,    0,    0,    0,    965,  967,  3,    272,  136,  0,    966,  965,  1,    0,    0,    0,    966,  967,  1,    0,    0,    0,    967,  969,  1,    0,    0,    0,
        968,  970,  5,    66,   0,    0,    969,  968,  1,    0,    0,    0,    969,  970,  1,    0,    0,    0,    970,  971,  1,    0,    0,    0,    971,  972,  3,    354,  177,  0,    972,  973,
        5,    138,  0,    0,    973,  103,  1,    0,    0,    0,    974,  976,  3,    272,  136,  0,    975,  974,  1,    0,    0,    0,    975,  976,  1,    0,    0,    0,    976,  978,  1,    0,
        0,    0,    977,  979,  5,    66,   0,    0,    978,  977,  1,    0,    0,    0,    978,  979,  1,    0,    0,    0,    979,  982,  1,    0,    0,    0,    980,  983,  3,    110,  55,   0,
        981,  983,  3,    400,  200,  0,    982,  980,  1,    0,    0,    0,    982,  981,  1,    0,    0,    0,    983,  105,  1,    0,    0,    0,    984,  985,  3,    192,  96,   0,    985,  107,
        1,    0,    0,    0,    986,  987,  5,    103,  0,    0,    987,  988,  3,    106,  53,   0,    988,  109,  1,    0,    0,    0,    989,  990,  3,    476,  238,  0,    990,  991,  5,    131,
        0,    0,    991,  992,  3,    318,  159,  0,    992,  993,  3,    112,  56,   0,    993,  994,  5,    138,  0,    0,    994,  111,  1,    0,    0,    0,    995,  1002, 3,    506,  253,  0,
        996,  997,  5,    108,  0,    0,    997,  1000, 3,    106,  53,   0,    998,  999,  5,    26,   0,    0,    999,  1001, 3,    112,  56,   0,    1000, 998,  1,    0,    0,    0,    1000, 1001,
        1,    0,    0,    0,    1001, 1003, 1,    0,    0,    0,    1002, 996,  1,    0,    0,    0,    1002, 1003, 1,    0,    0,    0,    1003, 113,  1,    0,    0,    0,    1004, 1005, 5,    20,
        0,    0,    1005, 1006, 3,    230,  115,  0,    1006, 1007, 5,    58,   0,    0,    1007, 1008, 3,    292,  146,  0,    1008, 1009, 5,    41,   0,    0,    1009, 1010, 3,    118,  59,   0,
        1010, 1011, 3,    54,   27,   0,    1011, 1013, 5,    24,   0,    0,    1012, 1014, 5,    20,   0,    0,    1013, 1012, 1,    0,    0,    0,    1013, 1014, 1,    0,    0,    0,    1014, 1016,
        1,    0,    0,    0,    1015, 1017, 3,    230,  115,  0,    1016, 1015, 1,    0,    0,    0,    1016, 1017, 1,    0,    0,    0,    1017, 1018, 1,    0,    0,    0,    1018, 1019, 5,    138,
        0,    0,    1019, 115,  1,    0,    0,    0,    1020, 1024, 3,    498,  249,  0,    1021, 1024, 3,    48,   24,   0,    1022, 1024, 3,    224,  112,  0,    1023, 1020, 1,    0,    0,    0,
        1023, 1021, 1,    0,    0,    0,    1023, 1022, 1,    0,    0,    0,    1024, 117,  1,    0,    0,    0,    1025, 1027, 3,    116,  58,   0,    1026, 1025, 1,    0,    0,    0,    1027, 1030,
        1,    0,    0,    0,    1028, 1026, 1,    0,    0,    0,    1028, 1029, 1,    0,    0,    0,    1029, 119,  1,    0,    0,    0,    1030, 1028, 1,    0,    0,    0,    1031, 1034, 3,    54,
        27,   0,    1032, 1034, 3,    86,   43,   0,    1033, 1031, 1,    0,    0,    0,    1033, 1032, 1,    0,    0,    0,    1034, 121,  1,    0,    0,    0,    1035, 1036, 5,    30,   0,    0,
        1036, 1037, 3,    92,   46,   0,    1037, 1038, 3,    52,   26,   0,    1038, 1039, 5,    138,  0,    0,    1039, 123,  1,    0,    0,    0,    1040, 1041, 5,    21,   0,    0,    1041, 1042,
        3,    232,  116,  0,    1042, 1043, 5,    145,  0,    0,    1043, 1046, 3,    472,  236,  0,    1044, 1045, 5,    135,  0,    0,    1045, 1047, 3,    192,  96,   0,    1046, 1044, 1,    0,
        0,    0,    1046, 1047, 1,    0,    0,    0,    1047, 1048, 1,    0,    0,    0,    1048, 1049, 5,    138,  0,    0,    1049, 125,  1,    0,    0,    0,    1050, 1051, 5,    9,    0,    0,
        1051, 1052, 3,    236,  118,  0,    1052, 1053, 5,    58,   0,    0,    1053, 1054, 3,    472,  236,  0,    1054, 127,  1,    0,    0,    0,    1055, 1056, 5,    9,    0,    0,    1056, 1057,
        3,    236,  118,  0,    1057, 1058, 5,    58,   0,    0,    1058, 1059, 3,    450,  225,  0,    1059, 129,  1,    0,    0,    0,    1060, 1063, 3,    378,  189,  0,    1061, 1063, 3,    236,
        118,  0,    1062, 1060, 1,    0,    0,    0,    1062, 1061, 1,    0,    0,    0,    1063, 131,  1,    0,    0,    0,    1064, 1066, 3,    134,  67,   0,    1065, 1064, 1,    0,    0,    0,
        1066, 1069, 1,    0,    0,    0,    1067, 1065, 1,    0,    0,    0,    1067, 1068, 1,    0,    0,    0,    1068, 133,  1,    0,    0,    0,    1069, 1067, 1,    0,    0,    0,    1070, 1073,
        3,    274,  137,  0,    1071, 1073, 3,    498,  249,  0,    1072, 1070, 1,    0,    0,    0,    1072, 1071, 1,    0,    0,    0,    1073, 135,  1,    0,    0,    0,    1074, 1081, 5,    99,
        0,    0,    1075, 1076, 5,    74,   0,    0,    1076, 1078, 3,    192,  96,   0,    1077, 1075, 1,    0,    0,    0,    1077, 1078, 1,    0,    0,    0,    1078, 1079, 1,    0,    0,    0,
        1079, 1081, 5,    39,   0,    0,    1080, 1074, 1,    0,    0,    0,    1080, 1077, 1,    0,    0,    0,    1081, 137,  1,    0,    0,    0,    1082, 1084, 3,    140,  70,   0,    1083, 1082,
        1,    0,    0,    0,    1084, 1087, 1,    0,    0,    0,    1085, 1083, 1,    0,    0,    0,    1085, 1086, 1,    0,    0,    0,    1086, 1088, 1,    0,    0,    0,    1087, 1085, 1,    0,
        0,    0,    1088, 1089, 5,    0,    0,    1,    1089, 139,  1,    0,    0,    0,    1090, 1091, 3,    132,  66,   0,    1091, 1092, 3,    276,  138,  0,    1092, 141,  1,    0,    0,    0,
        1093, 1096, 3,    230,  115,  0,    1094, 1096, 5,    127,  0,    0,    1095, 1093, 1,    0,    0,    0,    1095, 1094, 1,    0,    0,    0,    1096, 143,  1,    0,    0,    0,    1097, 1098,
        7,    2,    0,    0,    1098, 145,  1,    0,    0,    0,    1099, 1100, 5,    22,   0,    0,    1100, 1101, 3,    228,  114,  0,    1101, 1102, 5,    4,    0,    0,    1102, 1103, 3,    192,
        96,   0,    1103, 1104, 5,    138,  0,    0,    1104, 147,  1,    0,    0,    0,    1105, 1108, 3,    374,  187,  0,    1106, 1108, 3,    472,  236,  0,    1107, 1105, 1,    0,    0,    0,
        1107, 1106, 1,    0,    0,    0,    1108, 149,  1,    0,    0,    0,    1109, 1110, 3,    84,   42,   0,    1110, 1111, 5,    133,  0,    0,    1111, 1113, 1,    0,    0,    0,    1112, 1109,
        1,    0,    0,    0,    1112, 1113, 1,    0,    0,    0,    1113, 1114, 1,    0,    0,    0,    1114, 1115, 3,    192,  96,   0,    1115, 151,  1,    0,    0,    0,    1116, 1117, 3,    232,
        116,  0,    1117, 1118, 5,    145,  0,    0,    1118, 1119, 3,    156,  78,   0,    1119, 1120, 5,    138,  0,    0,    1120, 153,  1,    0,    0,    0,    1121, 1122, 3,    450,  225,  0,
        1122, 155,  1,    0,    0,    0,    1123, 1124, 3,    472,  236,  0,    1124, 157,  1,    0,    0,    0,    1125, 1126, 5,    25,   0,    0,    1126, 1131, 3,    292,  146,  0,    1127, 1128,
        5,    141,  0,    0,    1128, 1129, 3,    230,  115,  0,    1129, 1130, 5,    142,  0,    0,    1130, 1132, 1,    0,    0,    0,    1131, 1127, 1,    0,    0,    0,    1131, 1132, 1,    0,
        0,    0,    1132, 1137, 1,    0,    0,    0,    1133, 1134, 5,    20,   0,    0,    1134, 1137, 3,    292,  146,  0,    1135, 1137, 5,    60,   0,    0,    1136, 1125, 1,    0,    0,    0,
        1136, 1133, 1,    0,    0,    0,    1136, 1135, 1,    0,    0,    0,    1137, 159,  1,    0,    0,    0,    1138, 1139, 7,    3,    0,    0,    1139, 161,  1,    0,    0,    0,    1140, 1142,
        3,    160,  80,   0,    1141, 1143, 5,    136,  0,    0,    1142, 1141, 1,    0,    0,    0,    1142, 1143, 1,    0,    0,    0,    1143, 163,  1,    0,    0,    0,    1144, 1149, 3,    162,
        81,   0,    1145, 1146, 5,    139,  0,    0,    1146, 1148, 3,    162,  81,   0,    1147, 1145, 1,    0,    0,    0,    1148, 1151, 1,    0,    0,    0,    1149, 1147, 1,    0,    0,    0,
        1149, 1150, 1,    0,    0,    0,    1150, 165,  1,    0,    0,    0,    1151, 1149, 1,    0,    0,    0,    1152, 1153, 5,    25,   0,    0,    1153, 1154, 3,    230,  115,  0,    1154, 1155,
        5,    41,   0,    0,    1155, 1156, 3,    174,  87,   0,    1156, 1159, 3,    170,  85,   0,    1157, 1158, 5,    12,   0,    0,    1158, 1160, 3,    182,  91,   0,    1159, 1157, 1,    0,
        0,    0,    1159, 1160, 1,    0,    0,    0,    1160, 1161, 1,    0,    0,    0,    1161, 1163, 5,    24,   0,    0,    1162, 1164, 5,    25,   0,    0,    1163, 1162, 1,    0,    0,    0,
        1163, 1164, 1,    0,    0,    0,    1164, 1166, 1,    0,    0,    0,    1165, 1167, 3,    230,  115,  0,    1166, 1165, 1,    0,    0,    0,    1166, 1167, 1,    0,    0,    0,    1167, 1168,
        1,    0,    0,    0,    1168, 1169, 5,    138,  0,    0,    1169, 167,  1,    0,    0,    0,    1170, 1191, 3,    454,  227,  0,    1171, 1191, 3,    452,  226,  0,    1172, 1191, 3,    490,
        245,  0,    1173, 1191, 3,    470,  235,  0,    1174, 1191, 3,    124,  62,   0,    1175, 1191, 3,    418,  209,  0,    1176, 1191, 3,    502,  251,  0,    1177, 1191, 3,    196,  98,   0,
        1178, 1191, 3,    16,   8,    0,    1179, 1191, 3,    44,   22,   0,    1180, 1191, 3,    48,   24,   0,    1181, 1191, 3,    146,  73,   0,    1182, 1191, 3,    446,  223,  0,    1183, 1191,
        3,    498,  249,  0,    1184, 1191, 3,    226,  113,  0,    1185, 1191, 3,    224,  112,  0,    1186, 1191, 3,    306,  153,  0,    1187, 1191, 3,    448,  224,  0,    1188, 1191, 3,    368,
        184,  0,    1189, 1191, 3,    482,  241,  0,    1190, 1170, 1,    0,    0,    0,    1190, 1171, 1,    0,    0,    0,    1190, 1172, 1,    0,    0,    0,    1190, 1173, 1,    0,    0,    0,
        1190, 1174, 1,    0,    0,    0,    1190, 1175, 1,    0,    0,    0,    1190, 1176, 1,    0,    0,    0,    1190, 1177, 1,    0,    0,    0,    1190, 1178, 1,    0,    0,    0,    1190, 1179,
        1,    0,    0,    0,    1190, 1180, 1,    0,    0,    0,    1190, 1181, 1,    0,    0,    0,    1190, 1182, 1,    0,    0,    0,    1190, 1183, 1,    0,    0,    0,    1190, 1184, 1,    0,
        0,    0,    1190, 1185, 1,    0,    0,    0,    1190, 1186, 1,    0,    0,    0,    1190, 1187, 1,    0,    0,    0,    1190, 1188, 1,    0,    0,    0,    1190, 1189, 1,    0,    0,    0,
        1191, 169,  1,    0,    0,    0,    1192, 1194, 3,    168,  84,   0,    1193, 1192, 1,    0,    0,    0,    1194, 1197, 1,    0,    0,    0,    1195, 1193, 1,    0,    0,    0,    1195, 1196,
        1,    0,    0,    0,    1196, 171,  1,    0,    0,    0,    1197, 1195, 1,    0,    0,    0,    1198, 1200, 3,    184,  92,   0,    1199, 1201, 3,    424,  212,  0,    1200, 1199, 1,    0,
        0,    0,    1200, 1201, 1,    0,    0,    0,    1201, 173,  1,    0,    0,    0,    1202, 1204, 3,    214,  107,  0,    1203, 1202, 1,    0,    0,    0,    1203, 1204, 1,    0,    0,    0,
        1204, 1206, 1,    0,    0,    0,    1205, 1207, 3,    338,  169,  0,    1206, 1205, 1,    0,    0,    0,    1206, 1207, 1,    0,    0,    0,    1207, 175,  1,    0,    0,    0,    1208, 1213,
        3,    172,  86,   0,    1209, 1210, 5,    139,  0,    0,    1210, 1212, 3,    172,  86,   0,    1211, 1209, 1,    0,    0,    0,    1212, 1215, 1,    0,    0,    0,    1213, 1211, 1,    0,
        0,    0,    1213, 1214, 1,    0,    0,    0,    1214, 1219, 1,    0,    0,    0,    1215, 1213, 1,    0,    0,    0,    1216, 1219, 5,    62,   0,    0,    1217, 1219, 5,    6,    0,    0,
        1218, 1208, 1,    0,    0,    0,    1218, 1216, 1,    0,    0,    0,    1218, 1217, 1,    0,    0,    0,    1219, 177,  1,    0,    0,    0,    1220, 1221, 3,    176,  88,   0,    1221, 1222,
        5,    145,  0,    0,    1222, 1223, 3,    160,  80,   0,    1223, 179,  1,    0,    0,    0,    1224, 1228, 3,    98,   49,   0,    1225, 1228, 3,    362,  181,  0,    1226, 1228, 3,    102,
        51,   0,    1227, 1224, 1,    0,    0,    0,    1227, 1225, 1,    0,    0,    0,    1227, 1226, 1,    0,    0,    0,    1228, 181,  1,    0,    0,    0,    1229, 1231, 3,    180,  90,   0,
        1230, 1229, 1,    0,    0,    0,    1231, 1234, 1,    0,    0,    0,    1232, 1230, 1,    0,    0,    0,    1232, 1233, 1,    0,    0,    0,    1233, 183,  1,    0,    0,    0,    1234, 1232,
        1,    0,    0,    0,    1235, 1239, 3,    230,  115,  0,    1236, 1239, 5,    126,  0,    0,    1237, 1239, 5,    127,  0,    0,    1238, 1235, 1,    0,    0,    0,    1238, 1236, 1,    0,
        0,    0,    1238, 1237, 1,    0,    0,    0,    1239, 185,  1,    0,    0,    0,    1240, 1243, 3,    230,  115,  0,    1241, 1243, 5,    126,  0,    0,    1242, 1240, 1,    0,    0,    0,
        1242, 1241, 1,    0,    0,    0,    1243, 187,  1,    0,    0,    0,    1244, 1245, 5,    141,  0,    0,    1245, 1250, 3,    186,  93,   0,    1246, 1247, 5,    139,  0,    0,    1247, 1249,
        3,    186,  93,   0,    1248, 1246, 1,    0,    0,    0,    1249, 1252, 1,    0,    0,    0,    1250, 1248, 1,    0,    0,    0,    1250, 1251, 1,    0,    0,    0,    1251, 1253, 1,    0,
        0,    0,    1252, 1250, 1,    0,    0,    0,    1253, 1254, 5,    142,  0,    0,    1254, 189,  1,    0,    0,    0,    1255, 1257, 3,    272,  136,  0,    1256, 1255, 1,    0,    0,    0,
        1256, 1257, 1,    0,    0,    0,    1257, 1258, 1,    0,    0,    0,    1258, 1260, 5,    28,   0,    0,    1259, 1261, 3,    230,  115,  0,    1260, 1259, 1,    0,    0,    0,    1260, 1261,
        1,    0,    0,    0,    1261, 1264, 1,    0,    0,    0,    1262, 1263, 5,    108,  0,    0,    1263, 1265, 3,    106,  53,   0,    1264, 1262, 1,    0,    0,    0,    1264, 1265, 1,    0,
        0,    0,    1265, 1266, 1,    0,    0,    0,    1266, 1267, 5,    138,  0,    0,    1267, 191,  1,    0,    0,    0,    1268, 1274, 3,    384,  192,  0,    1269, 1270, 3,    284,  142,  0,
        1270, 1271, 3,    384,  192,  0,    1271, 1273, 1,    0,    0,    0,    1272, 1269, 1,    0,    0,    0,    1273, 1276, 1,    0,    0,    0,    1274, 1272, 1,    0,    0,    0,    1274, 1275,
        1,    0,    0,    0,    1275, 193,  1,    0,    0,    0,    1276, 1274, 1,    0,    0,    0,    1277, 1280, 3,    344,  172,  0,    1278, 1279, 5,    129,  0,    0,    1279, 1281, 3,    344,
        172,  0,    1280, 1278, 1,    0,    0,    0,    1280, 1281, 1,    0,    0,    0,    1281, 1287, 1,    0,    0,    0,    1282, 1283, 5,    1,    0,    0,    1283, 1287, 3,    344,  172,  0,
        1284, 1285, 5,    56,   0,    0,    1285, 1287, 3,    344,  172,  0,    1286, 1277, 1,    0,    0,    0,    1286, 1282, 1,    0,    0,    0,    1286, 1284, 1,    0,    0,    0,    1287, 195,
        1,    0,    0,    0,    1288, 1289, 5,    29,   0,    0,    1289, 1290, 3,    232,  116,  0,    1290, 1291, 5,    145,  0,    0,    1291, 1293, 3,    472,  236,  0,    1292, 1294, 3,    200,
        100,  0,    1293, 1292, 1,    0,    0,    0,    1293, 1294, 1,    0,    0,    0,    1294, 1295, 1,    0,    0,    0,    1295, 1296, 5,    138,  0,    0,    1296, 197,  1,    0,    0,    0,
        1297, 1298, 3,    192,  96,   0,    1298, 199,  1,    0,    0,    0,    1299, 1300, 5,    60,   0,    0,    1300, 1302, 3,    192,  96,   0,    1301, 1299, 1,    0,    0,    0,    1301, 1302,
        1,    0,    0,    0,    1302, 1303, 1,    0,    0,    0,    1303, 1304, 5,    41,   0,    0,    1304, 1305, 3,    198,  99,   0,    1305, 201,  1,    0,    0,    0,    1306, 1307, 5,    29,
        0,    0,    1307, 1308, 5,    58,   0,    0,    1308, 1309, 3,    472,  236,  0,    1309, 203,  1,    0,    0,    0,    1310, 1311, 3,    258,  129,  0,    1311, 205,  1,    0,    0,    0,
        1312, 1319, 3,    230,  115,  0,    1313, 1314, 3,    230,  115,  0,    1314, 1315, 5,    141,  0,    0,    1315, 1316, 3,    376,  188,  0,    1316, 1317, 5,    142,  0,    0,    1317, 1319,
        1,    0,    0,    0,    1318, 1312, 1,    0,    0,    0,    1318, 1313, 1,    0,    0,    0,    1319, 207,  1,    0,    0,    0,    1320, 1321, 5,    71,   0,    0,    1321, 1322, 3,    232,
        116,  0,    1322, 1323, 5,    145,  0,    0,    1323, 1326, 3,    472,  236,  0,    1324, 1325, 5,    135,  0,    0,    1325, 1327, 3,    192,  96,   0,    1326, 1324, 1,    0,    0,    0,
        1326, 1327, 1,    0,    0,    0,    1327, 1328, 1,    0,    0,    0,    1328, 1329, 5,    138,  0,    0,    1329, 209,  1,    0,    0,    0,    1330, 1331, 3,    272,  136,  0,    1331, 1332,
        3,    212,  106,  0,    1332, 1340, 5,    32,   0,    0,    1333, 1335, 3,    56,   28,   0,    1334, 1333, 1,    0,    0,    0,    1335, 1338, 1,    0,    0,    0,    1336, 1334, 1,    0,
        0,    0,    1336, 1337, 1,    0,    0,    0,    1337, 1339, 1,    0,    0,    0,    1338, 1336, 1,    0,    0,    0,    1339, 1341, 5,    12,   0,    0,    1340, 1336, 1,    0,    0,    0,
        1340, 1341, 1,    0,    0,    0,    1341, 1345, 1,    0,    0,    0,    1342, 1344, 3,    28,   14,   0,    1343, 1342, 1,    0,    0,    0,    1344, 1347, 1,    0,    0,    0,    1345, 1343,
        1,    0,    0,    0,    1345, 1346, 1,    0,    0,    0,    1346, 1348, 1,    0,    0,    0,    1347, 1345, 1,    0,    0,    0,    1348, 1349, 5,    24,   0,    0,    1349, 1351, 5,    32,
        0,    0,    1350, 1352, 3,    230,  115,  0,    1351, 1350, 1,    0,    0,    0,    1351, 1352, 1,    0,    0,    0,    1352, 1353, 1,    0,    0,    0,    1353, 1354, 5,    138,  0,    0,
        1354, 211,  1,    0,    0,    0,    1355, 1356, 5,    30,   0,    0,    1356, 1360, 3,    332,  166,  0,    1357, 1358, 5,    36,   0,    0,    1358, 1360, 3,    106,  53,   0,    1359, 1355,
        1,    0,    0,    0,    1359, 1357, 1,    0,    0,    0,    1360, 213,  1,    0,    0,    0,    1361, 1362, 5,    33,   0,    0,    1362, 1363, 5,    141,  0,    0,    1363, 1364, 3,    216,
        108,  0,    1364, 1365, 5,    142,  0,    0,    1365, 1366, 5,    138,  0,    0,    1366, 215,  1,    0,    0,    0,    1367, 1372, 3,    246,  123,  0,    1368, 1369, 5,    138,  0,    0,
        1369, 1371, 3,    246,  123,  0,    1370, 1368, 1,    0,    0,    0,    1371, 1374, 1,    0,    0,    0,    1372, 1370, 1,    0,    0,    0,    1372, 1373, 1,    0,    0,    0,    1373, 217,
        1,    0,    0,    0,    1374, 1372, 1,    0,    0,    0,    1375, 1376, 5,    33,   0,    0,    1376, 1377, 5,    48,   0,    0,    1377, 1378, 5,    141,  0,    0,    1378, 1379, 3,    42,
        21,   0,    1379, 1380, 5,    142,  0,    0,    1380, 219,  1,    0,    0,    0,    1381, 1384, 3,    292,  146,  0,    1382, 1384, 5,    126,  0,    0,    1383, 1381, 1,    0,    0,    0,
        1383, 1382, 1,    0,    0,    0,    1384, 221,  1,    0,    0,    0,    1385, 1390, 3,    220,  110,  0,    1386, 1387, 5,    139,  0,    0,    1387, 1389, 3,    220,  110,  0,    1388, 1386,
        1,    0,    0,    0,    1389, 1392, 1,    0,    0,    0,    1390, 1388, 1,    0,    0,    0,    1390, 1391, 1,    0,    0,    0,    1391, 223,  1,    0,    0,    0,    1392, 1390, 1,    0,
        0,    0,    1393, 1394, 5,    34,   0,    0,    1394, 1395, 3,    272,  136,  0,    1395, 1396, 3,    292,  146,  0,    1396, 1397, 5,    141,  0,    0,    1397, 1398, 3,    222,  111,  0,
        1398, 1399, 5,    142,  0,    0,    1399, 1400, 5,    138,  0,    0,    1400, 225,  1,    0,    0,    0,    1401, 1402, 5,    34,   0,    0,    1402, 1403, 3,    230,  115,  0,    1403, 1404,
        5,    41,   0,    0,    1404, 1405, 5,    141,  0,    0,    1405, 1406, 3,    164,  82,   0,    1406, 1407, 5,    142,  0,    0,    1407, 1408, 5,    138,  0,    0,    1408, 227,  1,    0,
        0,    0,    1409, 1410, 3,    422,  211,  0,    1410, 1411, 5,    145,  0,    0,    1411, 1412, 3,    292,  146,  0,    1412, 229,  1,    0,    0,    0,    1413, 1414, 7,    4,    0,    0,
        1414, 231,  1,    0,    0,    0,    1415, 1420, 3,    230,  115,  0,    1416, 1417, 5,    139,  0,    0,    1417, 1419, 3,    230,  115,  0,    1418, 1416, 1,    0,    0,    0,    1419, 1422,
        1,    0,    0,    0,    1420, 1418, 1,    0,    0,    0,    1420, 1421, 1,    0,    0,    0,    1421, 233,  1,    0,    0,    0,    1422, 1420, 1,    0,    0,    0,    1423, 1425, 3,    272,
        136,  0,    1424, 1423, 1,    0,    0,    0,    1424, 1425, 1,    0,    0,    0,    1425, 1426, 1,    0,    0,    0,    1426, 1427, 5,    36,   0,    0,    1427, 1428, 3,    106,  53,   0,
        1428, 1429, 5,    95,   0,    0,    1429, 1437, 3,    408,  204,  0,    1430, 1431, 5,    27,   0,    0,    1431, 1432, 3,    106,  53,   0,    1432, 1433, 5,    95,   0,    0,    1433, 1434,
        3,    408,  204,  0,    1434, 1436, 1,    0,    0,    0,    1435, 1430, 1,    0,    0,    0,    1436, 1439, 1,    0,    0,    0,    1437, 1435, 1,    0,    0,    0,    1437, 1438, 1,    0,
        0,    0,    1438, 1442, 1,    0,    0,    0,    1439, 1437, 1,    0,    0,    0,    1440, 1441, 5,    26,   0,    0,    1441, 1443, 3,    408,  204,  0,    1442, 1440, 1,    0,    0,    0,
        1442, 1443, 1,    0,    0,    0,    1443, 1444, 1,    0,    0,    0,    1444, 1445, 5,    24,   0,    0,    1445, 1447, 5,    36,   0,    0,    1446, 1448, 3,    230,  115,  0,    1447, 1446,
        1,    0,    0,    0,    1447, 1448, 1,    0,    0,    0,    1448, 1449, 1,    0,    0,    0,    1449, 1450, 5,    138,  0,    0,    1450, 235,  1,    0,    0,    0,    1451, 1452, 5,    141,
        0,    0,    1452, 1457, 3,    148,  74,   0,    1453, 1454, 5,    139,  0,    0,    1454, 1456, 3,    148,  74,   0,    1455, 1453, 1,    0,    0,    0,    1456, 1459, 1,    0,    0,    0,
        1457, 1455, 1,    0,    0,    0,    1457, 1458, 1,    0,    0,    0,    1458, 1460, 1,    0,    0,    0,    1459, 1457, 1,    0,    0,    0,    1460, 1461, 5,    142,  0,    0,    1461, 237,
        1,    0,    0,    0,    1462, 1465, 3,    148,  74,   0,    1463, 1465, 3,    192,  96,   0,    1464, 1462, 1,    0,    0,    0,    1464, 1463, 1,    0,    0,    0,    1465, 239,  1,    0,
        0,    0,    1466, 1467, 3,    292,  146,  0,    1467, 1468, 5,    72,   0,    0,    1468, 1469, 5,    136,  0,    0,    1469, 241,  1,    0,    0,    0,    1470, 1472, 5,    19,   0,    0,
        1471, 1470, 1,    0,    0,    0,    1471, 1472, 1,    0,    0,    0,    1472, 1473, 1,    0,    0,    0,    1473, 1485, 3,    292,  146,  0,    1474, 1475, 5,    25,   0,    0,    1475, 1480,
        3,    292,  146,  0,    1476, 1477, 5,    141,  0,    0,    1477, 1478, 3,    230,  115,  0,    1478, 1479, 5,    142,  0,    0,    1479, 1481, 1,    0,    0,    0,    1480, 1476, 1,    0,
        0,    0,    1480, 1481, 1,    0,    0,    0,    1481, 1485, 1,    0,    0,    0,    1482, 1483, 5,    20,   0,    0,    1483, 1485, 3,    292,  146,  0,    1484, 1471, 1,    0,    0,    0,
        1484, 1474, 1,    0,    0,    0,    1484, 1482, 1,    0,    0,    0,    1485, 243,  1,    0,    0,    0,    1486, 1491, 3,    230,  115,  0,    1487, 1488, 5,    139,  0,    0,    1488, 1490,
        3,    230,  115,  0,    1489, 1487, 1,    0,    0,    0,    1490, 1493, 1,    0,    0,    0,    1491, 1489, 1,    0,    0,    0,    1491, 1492, 1,    0,    0,    0,    1492, 1497, 1,    0,
        0,    0,    1493, 1491, 1,    0,    0,    0,    1494, 1497, 5,    62,   0,    0,    1495, 1497, 5,    6,    0,    0,    1496, 1486, 1,    0,    0,    0,    1496, 1494, 1,    0,    0,    0,
        1496, 1495, 1,    0,    0,    0,    1497, 245,  1,    0,    0,    0,    1498, 1500, 5,    21,   0,    0,    1499, 1498, 1,    0,    0,    0,    1499, 1500, 1,    0,    0,    0,    1500, 1501,
        1,    0,    0,    0,    1501, 1502, 3,    232,  116,  0,    1502, 1504, 5,    145,  0,    0,    1503, 1505, 5,    38,   0,    0,    1504, 1503, 1,    0,    0,    0,    1504, 1505, 1,    0,
        0,    0,    1505, 1506, 1,    0,    0,    0,    1506, 1509, 3,    472,  236,  0,    1507, 1508, 5,    135,  0,    0,    1508, 1510, 3,    192,  96,   0,    1509, 1507, 1,    0,    0,    0,
        1509, 1510, 1,    0,    0,    0,    1510, 247,  1,    0,    0,    0,    1511, 1518, 3,    246,  123,  0,    1512, 1518, 3,    264,  132,  0,    1513, 1518, 3,    268,  134,  0,    1514, 1518,
        3,    252,  126,  0,    1515, 1518, 3,    266,  133,  0,    1516, 1518, 3,    260,  130,  0,    1517, 1511, 1,    0,    0,    0,    1517, 1512, 1,    0,    0,    0,    1517, 1513, 1,    0,
        0,    0,    1517, 1514, 1,    0,    0,    0,    1517, 1515, 1,    0,    0,    0,    1517, 1516, 1,    0,    0,    0,    1518, 249,  1,    0,    0,    0,    1519, 1520, 3,    248,  124,  0,
        1520, 251,  1,    0,    0,    0,    1521, 1522, 5,    29,   0,    0,    1522, 1523, 3,    232,  116,  0,    1523, 1524, 5,    145,  0,    0,    1524, 1525, 3,    472,  236,  0,    1525, 253,
        1,    0,    0,    0,    1526, 1531, 3,    264,  132,  0,    1527, 1528, 5,    138,  0,    0,    1528, 1530, 3,    264,  132,  0,    1529, 1527, 1,    0,    0,    0,    1530, 1533, 1,    0,
        0,    0,    1531, 1529, 1,    0,    0,    0,    1531, 1532, 1,    0,    0,    0,    1532, 255,  1,    0,    0,    0,    1533, 1531, 1,    0,    0,    0,    1534, 1539, 3,    262,  131,  0,
        1535, 1536, 5,    138,  0,    0,    1536, 1538, 3,    262,  131,  0,    1537, 1535, 1,    0,    0,    0,    1538, 1541, 1,    0,    0,    0,    1539, 1537, 1,    0,    0,    0,    1539, 1540,
        1,    0,    0,    0,    1540, 257,  1,    0,    0,    0,    1541, 1539, 1,    0,    0,    0,    1542, 1547, 3,    250,  125,  0,    1543, 1544, 5,    138,  0,    0,    1544, 1546, 3,    250,
        125,  0,    1545, 1543, 1,    0,    0,    0,    1546, 1549, 1,    0,    0,    0,    1547, 1545, 1,    0,    0,    0,    1547, 1548, 1,    0,    0,    0,    1548, 259,  1,    0,    0,    0,
        1549, 1547, 1,    0,    0,    0,    1550, 1551, 5,    71,   0,    0,    1551, 1552, 3,    232,  116,  0,    1552, 1554, 5,    145,  0,    0,    1553, 1555, 7,    5,    0,    0,    1554, 1553,
        1,    0,    0,    0,    1554, 1555, 1,    0,    0,    0,    1555, 1556, 1,    0,    0,    0,    1556, 1559, 3,    472,  236,  0,    1557, 1558, 5,    135,  0,    0,    1558, 1560, 3,    192,
        96,   0,    1559, 1557, 1,    0,    0,    0,    1559, 1560, 1,    0,    0,    0,    1560, 261,  1,    0,    0,    0,    1561, 1562, 3,    232,  116,  0,    1562, 1564, 5,    145,  0,    0,
        1563, 1565, 3,    288,  144,  0,    1564, 1563, 1,    0,    0,    0,    1564, 1565, 1,    0,    0,    0,    1565, 1566, 1,    0,    0,    0,    1566, 1568, 3,    472,  236,  0,    1567, 1569,
        5,    17,   0,    0,    1568, 1567, 1,    0,    0,    0,    1568, 1569, 1,    0,    0,    0,    1569, 1572, 1,    0,    0,    0,    1570, 1571, 5,    135,  0,    0,    1571, 1573, 3,    192,
        96,   0,    1572, 1570, 1,    0,    0,    0,    1572, 1573, 1,    0,    0,    0,    1573, 263,  1,    0,    0,    0,    1574, 1575, 5,    86,   0,    0,    1575, 1576, 3,    232,  116,  0,
        1576, 1578, 5,    145,  0,    0,    1577, 1579, 3,    288,  144,  0,    1578, 1577, 1,    0,    0,    0,    1578, 1579, 1,    0,    0,    0,    1579, 1580, 1,    0,    0,    0,    1580, 1582,
        3,    472,  236,  0,    1581, 1583, 5,    17,   0,    0,    1582, 1581, 1,    0,    0,    0,    1582, 1583, 1,    0,    0,    0,    1583, 1586, 1,    0,    0,    0,    1584, 1585, 5,    135,
        0,    0,    1585, 1587, 3,    192,  96,   0,    1586, 1584, 1,    0,    0,    0,    1586, 1587, 1,    0,    0,    0,    1587, 265,  1,    0,    0,    0,    1588, 1589, 5,    94,   0,    0,
        1589, 1590, 3,    232,  116,  0,    1590, 1591, 5,    145,  0,    0,    1591, 1592, 3,    450,  225,  0,    1592, 267,  1,    0,    0,    0,    1593, 1595, 5,    105,  0,    0,    1594, 1593,
        1,    0,    0,    0,    1594, 1595, 1,    0,    0,    0,    1595, 1596, 1,    0,    0,    0,    1596, 1597, 3,    232,  116,  0,    1597, 1599, 5,    145,  0,    0,    1598, 1600, 3,    288,
        144,  0,    1599, 1598, 1,    0,    0,    0,    1599, 1600, 1,    0,    0,    0,    1600, 1601, 1,    0,    0,    0,    1601, 1604, 3,    472,  236,  0,    1602, 1603, 5,    135,  0,    0,
        1603, 1605, 3,    192,  96,   0,    1604, 1602, 1,    0,    0,    0,    1604, 1605, 1,    0,    0,    0,    1605, 269,  1,    0,    0,    0,    1606, 1607, 5,    109,  0,    0,    1607, 1611,
        3,    106,  53,   0,    1608, 1609, 5,    30,   0,    0,    1609, 1611, 3,    332,  166,  0,    1610, 1606, 1,    0,    0,    0,    1610, 1608, 1,    0,    0,    0,    1611, 271,  1,    0,
        0,    0,    1612, 1613, 3,    230,  115,  0,    1613, 1614, 5,    145,  0,    0,    1614, 273,  1,    0,    0,    0,    1615, 1616, 5,    43,   0,    0,    1616, 1617, 3,    282,  141,  0,
        1617, 1618, 5,    138,  0,    0,    1618, 275,  1,    0,    0,    0,    1619, 1622, 3,    396,  198,  0,    1620, 1622, 3,    346,  173,  0,    1621, 1619, 1,    0,    0,    0,    1621, 1620,
        1,    0,    0,    0,    1622, 277,  1,    0,    0,    0,    1623, 1629, 5,    57,   0,    0,    1624, 1629, 5,    113,  0,    0,    1625, 1629, 5,    127,  0,    0,    1626, 1629, 3,    186,
        93,   0,    1627, 1629, 3,    314,  157,  0,    1628, 1623, 1,    0,    0,    0,    1628, 1624, 1,    0,    0,    0,    1628, 1625, 1,    0,    0,    0,    1628, 1626, 1,    0,    0,    0,
        1628, 1627, 1,    0,    0,    0,    1629, 279,  1,    0,    0,    0,    1630, 1631, 3,    230,  115,  0,    1631, 281,  1,    0,    0,    0,    1632, 1637, 3,    280,  140,  0,    1633, 1634,
        5,    139,  0,    0,    1634, 1636, 3,    280,  140,  0,    1635, 1633, 1,    0,    0,    0,    1636, 1639, 1,    0,    0,    0,    1637, 1635, 1,    0,    0,    0,    1637, 1638, 1,    0,
        0,    0,    1638, 283,  1,    0,    0,    0,    1639, 1637, 1,    0,    0,    0,    1640, 1641, 7,    6,    0,    0,    1641, 285,  1,    0,    0,    0,    1642, 1644, 3,    272,  136,  0,
        1643, 1642, 1,    0,    0,    0,    1643, 1644, 1,    0,    0,    0,    1644, 1646, 1,    0,    0,    0,    1645, 1647, 3,    270,  135,  0,    1646, 1645, 1,    0,    0,    0,    1646, 1647,
        1,    0,    0,    0,    1647, 1648, 1,    0,    0,    0,    1648, 1649, 5,    47,   0,    0,    1649, 1650, 3,    408,  204,  0,    1650, 1651, 5,    24,   0,    0,    1651, 1653, 5,    47,
        0,    0,    1652, 1654, 3,    230,  115,  0,    1653, 1652, 1,    0,    0,    0,    1653, 1654, 1,    0,    0,    0,    1654, 1655, 1,    0,    0,    0,    1655, 1656, 5,    138,  0,    0,
        1656, 287,  1,    0,    0,    0,    1657, 1658, 7,    7,    0,    0,    1658, 289,  1,    0,    0,    0,    1659, 1660, 7,    8,    0,    0,    1660, 291,  1,    0,    0,    0,    1661, 1664,
        3,    230,  115,  0,    1662, 1664, 5,    127,  0,    0,    1663, 1661, 1,    0,    0,    0,    1663, 1662, 1,    0,    0,    0,    1664, 1668, 1,    0,    0,    0,    1665, 1667, 3,    294,
        147,  0,    1666, 1665, 1,    0,    0,    0,    1667, 1670, 1,    0,    0,    0,    1668, 1666, 1,    0,    0,    0,    1668, 1669, 1,    0,    0,    0,    1669, 293,  1,    0,    0,    0,
        1670, 1668, 1,    0,    0,    0,    1671, 1676, 3,    298,  149,  0,    1672, 1676, 3,    300,  150,  0,    1673, 1676, 3,    302,  151,  0,    1674, 1676, 3,    304,  152,  0,    1675, 1671,
        1,    0,    0,    0,    1675, 1672, 1,    0,    0,    0,    1675, 1673, 1,    0,    0,    0,    1675, 1674, 1,    0,    0,    0,    1676, 295,  1,    0,    0,    0,    1677, 1682, 3,    230,
        115,  0,    1678, 1679, 5,    154,  0,    0,    1679, 1681, 3,    474,  237,  0,    1680, 1678, 1,    0,    0,    0,    1681, 1684, 1,    0,    0,    0,    1682, 1680, 1,    0,    0,    0,
        1682, 1683, 1,    0,    0,    0,    1683, 297,  1,    0,    0,    0,    1684, 1682, 1,    0,    0,    0,    1685, 1686, 5,    154,  0,    0,    1686, 1688, 3,    474,  237,  0,    1687, 1685,
        1,    0,    0,    0,    1688, 1689, 1,    0,    0,    0,    1689, 1687, 1,    0,    0,    0,    1689, 1690, 1,    0,    0,    0,    1690, 299,  1,    0,    0,    0,    1691, 1692, 5,    141,
        0,    0,    1692, 1693, 3,    8,    4,    0,    1693, 1694, 5,    142,  0,    0,    1694, 301,  1,    0,    0,    0,    1695, 1696, 5,    141,  0,    0,    1696, 1697, 3,    148,  74,   0,
        1697, 1698, 5,    142,  0,    0,    1698, 303,  1,    0,    0,    0,    1699, 1701, 3,    424,  212,  0,    1700, 1699, 1,    0,    0,    0,    1700, 1701, 1,    0,    0,    0,    1701, 1702,
        1,    0,    0,    0,    1702, 1703, 5,    162,  0,    0,    1703, 1708, 3,    46,   23,   0,    1704, 1705, 5,    141,  0,    0,    1705, 1706, 3,    192,  96,   0,    1706, 1707, 5,    142,
        0,    0,    1707, 1709, 1,    0,    0,    0,    1708, 1704, 1,    0,    0,    0,    1708, 1709, 1,    0,    0,    0,    1709, 305,  1,    0,    0,    0,    1710, 1711, 5,    51,   0,    0,
        1711, 1712, 3,    230,  115,  0,    1712, 1713, 5,    41,   0,    0,    1713, 1714, 3,    308,  154,  0,    1714, 1715, 5,    138,  0,    0,    1715, 307,  1,    0,    0,    0,    1716, 1719,
        3,    392,  196,  0,    1717, 1719, 3,    94,   47,   0,    1718, 1716, 1,    0,    0,    0,    1718, 1717, 1,    0,    0,    0,    1719, 309,  1,    0,    0,    0,    1720, 1721, 3,    232,
        116,  0,    1721, 1722, 5,    145,  0,    0,    1722, 1723, 3,    154,  77,   0,    1723, 311,  1,    0,    0,    0,    1724, 1726, 3,    272,  136,  0,    1725, 1724, 1,    0,    0,    0,
        1725, 1726, 1,    0,    0,    0,    1726, 1727, 1,    0,    0,    0,    1727, 1729, 5,    53,   0,    0,    1728, 1730, 3,    230,  115,  0,    1729, 1728, 1,    0,    0,    0,    1729, 1730,
        1,    0,    0,    0,    1730, 1733, 1,    0,    0,    0,    1731, 1732, 5,    108,  0,    0,    1732, 1734, 3,    106,  53,   0,    1733, 1731, 1,    0,    0,    0,    1733, 1734, 1,    0,
        0,    0,    1734, 1735, 1,    0,    0,    0,    1735, 1736, 5,    138,  0,    0,    1736, 313,  1,    0,    0,    0,    1737, 1740, 3,    0,    0,    0,    1738, 1740, 3,    334,  167,  0,
        1739, 1737, 1,    0,    0,    0,    1739, 1738, 1,    0,    0,    0,    1740, 315,  1,    0,    0,    0,    1741, 1748, 3,    124,  62,   0,    1742, 1748, 3,    418,  209,  0,    1743, 1748,
        3,    502,  251,  0,    1744, 1748, 3,    196,  98,   0,    1745, 1748, 3,    482,  241,  0,    1746, 1748, 3,    368,  184,  0,    1747, 1741, 1,    0,    0,    0,    1747, 1742, 1,    0,
        0,    0,    1747, 1743, 1,    0,    0,    0,    1747, 1744, 1,    0,    0,    0,    1747, 1745, 1,    0,    0,    0,    1747, 1746, 1,    0,    0,    0,    1748, 317,  1,    0,    0,    0,
        1749, 1751, 5,    35,   0,    0,    1750, 1749, 1,    0,    0,    0,    1750, 1751, 1,    0,    0,    0,    1751, 1753, 1,    0,    0,    0,    1752, 1754, 3,    136,  68,   0,    1753, 1752,
        1,    0,    0,    0,    1753, 1754, 1,    0,    0,    0,    1754, 319,  1,    0,    0,    0,    1755, 1756, 5,    64,   0,    0,    1756, 1757, 5,    14,   0,    0,    1757, 1758, 3,    230,
        115,  0,    1758, 1759, 5,    41,   0,    0,    1759, 1760, 3,    324,  162,  0,    1760, 1763, 5,    24,   0,    0,    1761, 1762, 5,    64,   0,    0,    1762, 1764, 5,    14,   0,    0,
        1763, 1761, 1,    0,    0,    0,    1763, 1764, 1,    0,    0,    0,    1764, 1766, 1,    0,    0,    0,    1765, 1767, 3,    230,  115,  0,    1766, 1765, 1,    0,    0,    0,    1766, 1767,
        1,    0,    0,    0,    1767, 1768, 1,    0,    0,    0,    1768, 1769, 5,    138,  0,    0,    1769, 321,  1,    0,    0,    0,    1770, 1782, 3,    454,  227,  0,    1771, 1782, 3,    452,
        226,  0,    1772, 1782, 3,    490,  245,  0,    1773, 1782, 3,    470,  235,  0,    1774, 1782, 3,    124,  62,   0,    1775, 1782, 3,    502,  251,  0,    1776, 1782, 3,    196,  98,   0,
        1777, 1782, 3,    16,   8,    0,    1778, 1782, 3,    498,  249,  0,    1779, 1782, 3,    226,  113,  0,    1780, 1782, 3,    224,  112,  0,    1781, 1770, 1,    0,    0,    0,    1781, 1771,
        1,    0,    0,    0,    1781, 1772, 1,    0,    0,    0,    1781, 1773, 1,    0,    0,    0,    1781, 1774, 1,    0,    0,    0,    1781, 1775, 1,    0,    0,    0,    1781, 1776, 1,    0,
        0,    0,    1781, 1777, 1,    0,    0,    0,    1781, 1778, 1,    0,    0,    0,    1781, 1779, 1,    0,    0,    0,    1781, 1780, 1,    0,    0,    0,    1782, 323,  1,    0,    0,    0,
        1783, 1785, 3,    322,  161,  0,    1784, 1783, 1,    0,    0,    0,    1785, 1788, 1,    0,    0,    0,    1786, 1784, 1,    0,    0,    0,    1786, 1787, 1,    0,    0,    0,    1787, 325,
        1,    0,    0,    0,    1788, 1786, 1,    0,    0,    0,    1789, 1790, 5,    64,   0,    0,    1790, 1791, 3,    230,  115,  0,    1791, 1792, 5,    41,   0,    0,    1792, 1793, 3,    330,
        165,  0,    1793, 1795, 5,    24,   0,    0,    1794, 1796, 5,    64,   0,    0,    1795, 1794, 1,    0,    0,    0,    1795, 1796, 1,    0,    0,    0,    1796, 1798, 1,    0,    0,    0,
        1797, 1799, 3,    230,  115,  0,    1798, 1797, 1,    0,    0,    0,    1798, 1799, 1,    0,    0,    0,    1799, 1800, 1,    0,    0,    0,    1800, 1801, 5,    138,  0,    0,    1801, 327,
        1,    0,    0,    0,    1802, 1822, 3,    454,  227,  0,    1803, 1822, 3,    452,  226,  0,    1804, 1822, 3,    490,  245,  0,    1805, 1822, 3,    470,  235,  0,    1806, 1822, 3,    124,
        62,   0,    1807, 1822, 3,    418,  209,  0,    1808, 1822, 3,    502,  251,  0,    1809, 1822, 3,    196,  98,   0,    1810, 1822, 3,    16,   8,    0,    1811, 1822, 3,    88,   44,   0,
        1812, 1822, 3,    44,   22,   0,    1813, 1822, 3,    48,   24,   0,    1814, 1822, 3,    146,  73,   0,    1815, 1822, 3,    498,  249,  0,    1816, 1822, 3,    226,  113,  0,    1817, 1822,
        3,    224,  112,  0,    1818, 1822, 3,    306,  153,  0,    1819, 1822, 3,    448,  224,  0,    1820, 1822, 3,    482,  241,  0,    1821, 1802, 1,    0,    0,    0,    1821, 1803, 1,    0,
        0,    0,    1821, 1804, 1,    0,    0,    0,    1821, 1805, 1,    0,    0,    0,    1821, 1806, 1,    0,    0,    0,    1821, 1807, 1,    0,    0,    0,    1821, 1808, 1,    0,    0,    0,
        1821, 1809, 1,    0,    0,    0,    1821, 1810, 1,    0,    0,    0,    1821, 1811, 1,    0,    0,    0,    1821, 1812, 1,    0,    0,    0,    1821, 1813, 1,    0,    0,    0,    1821, 1814,
        1,    0,    0,    0,    1821, 1815, 1,    0,    0,    0,    1821, 1816, 1,    0,    0,    0,    1821, 1817, 1,    0,    0,    0,    1821, 1818, 1,    0,    0,    0,    1821, 1819, 1,    0,
        0,    0,    1821, 1820, 1,    0,    0,    0,    1822, 329,  1,    0,    0,    0,    1823, 1825, 3,    328,  164,  0,    1824, 1823, 1,    0,    0,    0,    1825, 1828, 1,    0,    0,    0,
        1826, 1824, 1,    0,    0,    0,    1826, 1827, 1,    0,    0,    0,    1827, 331,  1,    0,    0,    0,    1828, 1826, 1,    0,    0,    0,    1829, 1830, 3,    230,  115,  0,    1830, 1831,
        5,    38,   0,    0,    1831, 1832, 3,    148,  74,   0,    1832, 333,  1,    0,    0,    0,    1833, 1834, 3,    0,    0,    0,    1834, 1835, 3,    230,  115,  0,    1835, 335,  1,    0,
        0,    0,    1836, 1837, 3,    378,  189,  0,    1837, 1838, 5,    102,  0,    0,    1838, 1842, 3,    50,   25,   0,    1839, 1841, 3,    398,  199,  0,    1840, 1839, 1,    0,    0,    0,
        1841, 1844, 1,    0,    0,    0,    1842, 1840, 1,    0,    0,    0,    1842, 1843, 1,    0,    0,    0,    1843, 1845, 1,    0,    0,    0,    1844, 1842, 1,    0,    0,    0,    1845, 1846,
        5,    24,   0,    0,    1846, 1848, 5,    102,  0,    0,    1847, 1849, 3,    230,  115,  0,    1848, 1847, 1,    0,    0,    0,    1848, 1849, 1,    0,    0,    0,    1849, 337,  1,    0,
        0,    0,    1850, 1851, 5,    65,   0,    0,    1851, 1852, 5,    141,  0,    0,    1852, 1853, 3,    340,  170,  0,    1853, 1854, 5,    142,  0,    0,    1854, 1855, 5,    138,  0,    0,
        1855, 339,  1,    0,    0,    0,    1856, 1857, 3,    256,  128,  0,    1857, 341,  1,    0,    0,    0,    1858, 1859, 5,    65,   0,    0,    1859, 1860, 5,    48,   0,    0,    1860, 1861,
        5,    141,  0,    0,    1861, 1862, 3,    42,   21,   0,    1862, 1863, 5,    142,  0,    0,    1863, 343,  1,    0,    0,    0,    1864, 1874, 3,    278,  139,  0,    1865, 1874, 3,    366,
        183,  0,    1866, 1867, 5,    141,  0,    0,    1867, 1868, 3,    192,  96,   0,    1868, 1869, 5,    142,  0,    0,    1869, 1874, 1,    0,    0,    0,    1870, 1874, 3,    22,   11,   0,
        1871, 1874, 3,    14,   7,    0,    1872, 1874, 3,    292,  146,  0,    1873, 1864, 1,    0,    0,    0,    1873, 1865, 1,    0,    0,    0,    1873, 1866, 1,    0,    0,    0,    1873, 1870,
        1,    0,    0,    0,    1873, 1871, 1,    0,    0,    0,    1873, 1872, 1,    0,    0,    0,    1874, 345,  1,    0,    0,    0,    1875, 1879, 3,    166,  83,   0,    1876, 1879, 3,    114,
        57,   0,    1877, 1879, 3,    326,  163,  0,    1878, 1875, 1,    0,    0,    0,    1878, 1876, 1,    0,    0,    0,    1878, 1877, 1,    0,    0,    0,    1879, 347,  1,    0,    0,    0,
        1880, 1893, 3,    454,  227,  0,    1881, 1893, 3,    452,  226,  0,    1882, 1893, 3,    490,  245,  0,    1883, 1893, 3,    470,  235,  0,    1884, 1893, 3,    124,  62,   0,    1885, 1893,
        3,    502,  251,  0,    1886, 1893, 3,    16,   8,    0,    1887, 1893, 3,    44,   22,   0,    1888, 1893, 3,    48,   24,   0,    1889, 1893, 3,    498,  249,  0,    1890, 1893, 3,    226,
        113,  0,    1891, 1893, 3,    224,  112,  0,    1892, 1880, 1,    0,    0,    0,    1892, 1881, 1,    0,    0,    0,    1892, 1882, 1,    0,    0,    0,    1892, 1883, 1,    0,    0,    0,
        1892, 1884, 1,    0,    0,    0,    1892, 1885, 1,    0,    0,    0,    1892, 1886, 1,    0,    0,    0,    1892, 1887, 1,    0,    0,    0,    1892, 1888, 1,    0,    0,    0,    1892, 1889,
        1,    0,    0,    0,    1892, 1890, 1,    0,    0,    0,    1892, 1891, 1,    0,    0,    0,    1893, 349,  1,    0,    0,    0,    1894, 1896, 3,    348,  174,  0,    1895, 1894, 1,    0,
        0,    0,    1896, 1899, 1,    0,    0,    0,    1897, 1895, 1,    0,    0,    0,    1897, 1898, 1,    0,    0,    0,    1898, 351,  1,    0,    0,    0,    1899, 1897, 1,    0,    0,    0,
        1900, 1902, 3,    410,  205,  0,    1901, 1900, 1,    0,    0,    0,    1902, 1905, 1,    0,    0,    0,    1903, 1901, 1,    0,    0,    0,    1903, 1904, 1,    0,    0,    0,    1904, 353,
        1,    0,    0,    0,    1905, 1903, 1,    0,    0,    0,    1906, 1911, 3,    296,  148,  0,    1907, 1908, 5,    141,  0,    0,    1908, 1909, 3,    8,    4,    0,    1909, 1910, 5,    142,
        0,    0,    1910, 1912, 1,    0,    0,    0,    1911, 1907, 1,    0,    0,    0,    1911, 1912, 1,    0,    0,    0,    1912, 355,  1,    0,    0,    0,    1913, 1915, 3,    272,  136,  0,
        1914, 1913, 1,    0,    0,    0,    1914, 1915, 1,    0,    0,    0,    1915, 1916, 1,    0,    0,    0,    1916, 1917, 3,    354,  177,  0,    1917, 1918, 5,    138,  0,    0,    1918, 357,
        1,    0,    0,    0,    1919, 1933, 3,    454,  227,  0,    1920, 1933, 3,    452,  226,  0,    1921, 1933, 3,    490,  245,  0,    1922, 1933, 3,    470,  235,  0,    1923, 1933, 3,    124,
        62,   0,    1924, 1933, 3,    502,  251,  0,    1925, 1933, 3,    196,  98,   0,    1926, 1933, 3,    16,   8,    0,    1927, 1933, 3,    44,   22,   0,    1928, 1933, 3,    48,   24,   0,
        1929, 1933, 3,    498,  249,  0,    1930, 1933, 3,    226,  113,  0,    1931, 1933, 3,    224,  112,  0,    1932, 1919, 1,    0,    0,    0,    1932, 1920, 1,    0,    0,    0,    1932, 1921,
        1,    0,    0,    0,    1932, 1922, 1,    0,    0,    0,    1932, 1923, 1,    0,    0,    0,    1932, 1924, 1,    0,    0,    0,    1932, 1925, 1,    0,    0,    0,    1932, 1926, 1,    0,
        0,    0,    1932, 1927, 1,    0,    0,    0,    1932, 1928, 1,    0,    0,    0,    1932, 1929, 1,    0,    0,    0,    1932, 1930, 1,    0,    0,    0,    1932, 1931, 1,    0,    0,    0,
        1933, 359,  1,    0,    0,    0,    1934, 1936, 3,    358,  179,  0,    1935, 1934, 1,    0,    0,    0,    1936, 1939, 1,    0,    0,    0,    1937, 1935, 1,    0,    0,    0,    1937, 1938,
        1,    0,    0,    0,    1938, 361,  1,    0,    0,    0,    1939, 1937, 1,    0,    0,    0,    1940, 1942, 3,    272,  136,  0,    1941, 1940, 1,    0,    0,    0,    1941, 1942, 1,    0,
        0,    0,    1942, 1944, 1,    0,    0,    0,    1943, 1945, 5,    66,   0,    0,    1944, 1943, 1,    0,    0,    0,    1944, 1945, 1,    0,    0,    0,    1945, 1946, 1,    0,    0,    0,
        1946, 1951, 5,    67,   0,    0,    1947, 1948, 5,    141,  0,    0,    1948, 1949, 3,    406,  203,  0,    1949, 1950, 5,    142,  0,    0,    1950, 1952, 1,    0,    0,    0,    1951, 1947,
        1,    0,    0,    0,    1951, 1952, 1,    0,    0,    0,    1952, 1954, 1,    0,    0,    0,    1953, 1955, 5,    41,   0,    0,    1954, 1953, 1,    0,    0,    0,    1954, 1955, 1,    0,
        0,    0,    1955, 1956, 1,    0,    0,    0,    1956, 1957, 3,    360,  180,  0,    1957, 1958, 5,    12,   0,    0,    1958, 1959, 3,    364,  182,  0,    1959, 1961, 5,    24,   0,    0,
        1960, 1962, 5,    66,   0,    0,    1961, 1960, 1,    0,    0,    0,    1961, 1962, 1,    0,    0,    0,    1962, 1963, 1,    0,    0,    0,    1963, 1965, 5,    67,   0,    0,    1964, 1966,
        3,    230,  115,  0,    1965, 1964, 1,    0,    0,    0,    1965, 1966, 1,    0,    0,    0,    1966, 1967, 1,    0,    0,    0,    1967, 1968, 5,    138,  0,    0,    1968, 363,  1,    0,
        0,    0,    1969, 1971, 3,    410,  205,  0,    1970, 1969, 1,    0,    0,    0,    1971, 1974, 1,    0,    0,    0,    1972, 1970, 1,    0,    0,    0,    1972, 1973, 1,    0,    0,    0,
        1973, 365,  1,    0,    0,    0,    1974, 1972, 1,    0,    0,    0,    1975, 1976, 3,    472,  236,  0,    1976, 1982, 5,    162,  0,    0,    1977, 1983, 3,    14,   7,    0,    1978, 1979,
        5,    141,  0,    0,    1979, 1980, 3,    192,  96,   0,    1980, 1981, 5,    142,  0,    0,    1981, 1983, 1,    0,    0,    0,    1982, 1977, 1,    0,    0,    0,    1982, 1978, 1,    0,
        0,    0,    1983, 367,  1,    0,    0,    0,    1984, 1988, 3,    208,  104,  0,    1985, 1988, 3,    68,   34,   0,    1986, 1988, 3,    444,  222,  0,    1987, 1984, 1,    0,    0,    0,
        1987, 1985, 1,    0,    0,    0,    1987, 1986, 1,    0,    0,    0,    1988, 369,  1,    0,    0,    0,    1989, 1994, 3,    292,  146,  0,    1990, 1991, 5,    139,  0,    0,    1991, 1993,
        3,    292,  146,  0,    1992, 1990, 1,    0,    0,    0,    1993, 1996, 1,    0,    0,    0,    1994, 1992, 1,    0,    0,    0,    1994, 1995, 1,    0,    0,    0,    1995, 2000, 1,    0,
        0,    0,    1996, 1994, 1,    0,    0,    0,    1997, 2000, 5,    62,   0,    0,    1998, 2000, 5,    6,    0,    0,    1999, 1989, 1,    0,    0,    0,    1999, 1997, 1,    0,    0,    0,
        1999, 1998, 1,    0,    0,    0,    2000, 371,  1,    0,    0,    0,    2001, 2002, 3,    370,  185,  0,    2002, 2003, 5,    145,  0,    0,    2003, 2004, 3,    292,  146,  0,    2004, 373,
        1,    0,    0,    0,    2005, 2008, 3,    376,  188,  0,    2006, 2008, 3,    292,  146,  0,    2007, 2005, 1,    0,    0,    0,    2007, 2006, 1,    0,    0,    0,    2008, 375,  1,    0,
        0,    0,    2009, 2013, 3,    426,  213,  0,    2010, 2011, 3,    144,  72,   0,    2011, 2012, 3,    426,  213,  0,    2012, 2014, 1,    0,    0,    0,    2013, 2010, 1,    0,    0,    0,
        2013, 2014, 1,    0,    0,    0,    2014, 377,  1,    0,    0,    0,    2015, 2016, 5,    72,   0,    0,    2016, 2017, 3,    374,  187,  0,    2017, 379,  1,    0,    0,    0,    2018, 2020,
        5,    76,   0,    0,    2019, 2021, 3,    310,  155,  0,    2020, 2019, 1,    0,    0,    0,    2021, 2022, 1,    0,    0,    0,    2022, 2020, 1,    0,    0,    0,    2022, 2023, 1,    0,
        0,    0,    2023, 2024, 1,    0,    0,    0,    2024, 2025, 5,    24,   0,    0,    2025, 2027, 5,    76,   0,    0,    2026, 2028, 3,    230,  115,  0,    2027, 2026, 1,    0,    0,    0,
        2027, 2028, 1,    0,    0,    0,    2028, 381,  1,    0,    0,    0,    2029, 2031, 5,    76,   0,    0,    2030, 2032, 3,    152,  76,   0,    2031, 2030, 1,    0,    0,    0,    2032, 2033,
        1,    0,    0,    0,    2033, 2031, 1,    0,    0,    0,    2033, 2034, 1,    0,    0,    0,    2034, 2035, 1,    0,    0,    0,    2035, 2036, 5,    24,   0,    0,    2036, 2038, 5,    76,
        0,    0,    2037, 2039, 3,    230,  115,  0,    2038, 2037, 1,    0,    0,    0,    2038, 2039, 1,    0,    0,    0,    2039, 383,  1,    0,    0,    0,    2040, 2044, 3,    412,  206,  0,
        2041, 2042, 3,    386,  193,  0,    2042, 2043, 3,    412,  206,  0,    2043, 2045, 1,    0,    0,    0,    2044, 2041, 1,    0,    0,    0,    2044, 2045, 1,    0,    0,    0,    2045, 385,
        1,    0,    0,    0,    2046, 2047, 7,    9,    0,    0,    2047, 387,  1,    0,    0,    0,    2048, 2050, 3,    272,  136,  0,    2049, 2048, 1,    0,    0,    0,    2049, 2050, 1,    0,
        0,    0,    2050, 2051, 1,    0,    0,    0,    2051, 2052, 5,    79,   0,    0,    2052, 2055, 3,    192,  96,   0,    2053, 2054, 5,    84,   0,    0,    2054, 2056, 3,    192,  96,   0,
        2055, 2053, 1,    0,    0,    0,    2055, 2056, 1,    0,    0,    0,    2056, 2057, 1,    0,    0,    0,    2057, 2058, 5,    138,  0,    0,    2058, 389,  1,    0,    0,    0,    2059, 2061,
        3,    272,  136,  0,    2060, 2059, 1,    0,    0,    0,    2060, 2061, 1,    0,    0,    0,    2061, 2062, 1,    0,    0,    0,    2062, 2064, 5,    80,   0,    0,    2063, 2065, 3,    192,
        96,   0,    2064, 2063, 1,    0,    0,    0,    2064, 2065, 1,    0,    0,    0,    2065, 2066, 1,    0,    0,    0,    2066, 2067, 5,    138,  0,    0,    2067, 391,  1,    0,    0,    0,
        2068, 2069, 3,    292,  146,  0,    2069, 2070, 5,    3,    0,    0,    2070, 2071, 3,    292,  146,  0,    2071, 2072, 5,    96,   0,    0,    2072, 2073, 3,    292,  146,  0,    2073, 2074,
        5,    77,   0,    0,    2074, 393,  1,    0,    0,    0,    2075, 2079, 3,    336,  168,  0,    2076, 2079, 3,    188,  94,   0,    2077, 2079, 3,    378,  189,  0,    2078, 2075, 1,    0,
        0,    0,    2078, 2076, 1,    0,    0,    0,    2078, 2077, 1,    0,    0,    0,    2079, 395,  1,    0,    0,    0,    2080, 2083, 3,    24,   12,   0,    2081, 2083, 3,    320,  160,  0,
        2082, 2080, 1,    0,    0,    0,    2082, 2081, 1,    0,    0,    0,    2083, 397,  1,    0,    0,    0,    2084, 2085, 3,    230,  115,  0,    2085, 2086, 5,    152,  0,    0,    2086, 2087,
        3,    334,  167,  0,    2087, 2088, 5,    138,  0,    0,    2088, 399,  1,    0,    0,    0,    2089, 2090, 5,    107,  0,    0,    2090, 2091, 3,    192,  96,   0,    2091, 2092, 5,    83,
        0,    0,    2092, 2093, 3,    476,  238,  0,    2093, 2094, 5,    131,  0,    0,    2094, 2095, 3,    318,  159,  0,    2095, 2096, 3,    402,  201,  0,    2096, 2097, 5,    138,  0,    0,
        2097, 401,  1,    0,    0,    0,    2098, 2099, 3,    506,  253,  0,    2099, 2100, 5,    108,  0,    0,    2100, 2108, 3,    84,   42,   0,    2101, 2102, 5,    139,  0,    0,    2102, 2103,
        3,    506,  253,  0,    2103, 2104, 5,    108,  0,    0,    2104, 2105, 3,    84,   42,   0,    2105, 2107, 1,    0,    0,    0,    2106, 2101, 1,    0,    0,    0,    2107, 2110, 1,    0,
        0,    0,    2108, 2106, 1,    0,    0,    0,    2108, 2109, 1,    0,    0,    0,    2109, 403,  1,    0,    0,    0,    2110, 2108, 1,    0,    0,    0,    2111, 2112, 5,    59,   0,    0,
        2112, 2113, 3,    406,  203,  0,    2113, 405,  1,    0,    0,    0,    2114, 2119, 3,    292,  146,  0,    2115, 2116, 5,    139,  0,    0,    2116, 2118, 3,    292,  146,  0,    2117, 2115,
        1,    0,    0,    0,    2118, 2121, 1,    0,    0,    0,    2119, 2117, 1,    0,    0,    0,    2119, 2120, 1,    0,    0,    0,    2120, 407,  1,    0,    0,    0,    2121, 2119, 1,    0,
        0,    0,    2122, 2124, 3,    410,  205,  0,    2123, 2122, 1,    0,    0,    0,    2124, 2127, 1,    0,    0,    0,    2125, 2123, 1,    0,    0,    0,    2125, 2126, 1,    0,    0,    0,
        2126, 409,  1,    0,    0,    0,    2127, 2125, 1,    0,    0,    0,    2128, 2147, 3,    504,  252,  0,    2129, 2147, 3,    38,   19,   0,    2130, 2147, 3,    388,  194,  0,    2131, 2147,
        3,    416,  208,  0,    2132, 2147, 3,    500,  250,  0,    2133, 2147, 3,    234,  117,  0,    2134, 2147, 3,    78,   39,   0,    2135, 2147, 3,    286,  143,  0,    2136, 2147, 3,    312,
        156,  0,    2137, 2147, 3,    190,  95,   0,    2138, 2147, 3,    390,  195,  0,    2139, 2141, 3,    272,  136,  0,    2140, 2139, 1,    0,    0,    0,    2140, 2141, 1,    0,    0,    0,
        2141, 2142, 1,    0,    0,    0,    2142, 2143, 5,    57,   0,    0,    2143, 2147, 5,    138,  0,    0,    2144, 2147, 3,    76,   38,   0,    2145, 2147, 3,    356,  178,  0,    2146, 2128,
        1,    0,    0,    0,    2146, 2129, 1,    0,    0,    0,    2146, 2130, 1,    0,    0,    0,    2146, 2131, 1,    0,    0,    0,    2146, 2132, 1,    0,    0,    0,    2146, 2133, 1,    0,
        0,    0,    2146, 2134, 1,    0,    0,    0,    2146, 2135, 1,    0,    0,    0,    2146, 2136, 1,    0,    0,    0,    2146, 2137, 1,    0,    0,    0,    2146, 2138, 1,    0,    0,    0,
        2146, 2140, 1,    0,    0,    0,    2146, 2144, 1,    0,    0,    0,    2146, 2145, 1,    0,    0,    0,    2147, 411,  1,    0,    0,    0,    2148, 2152, 3,    426,  213,  0,    2149, 2150,
        3,    414,  207,  0,    2150, 2151, 3,    426,  213,  0,    2151, 2153, 1,    0,    0,    0,    2152, 2149, 1,    0,    0,    0,    2152, 2153, 1,    0,    0,    0,    2153, 413,  1,    0,
        0,    0,    2154, 2155, 7,    10,   0,    0,    2155, 415,  1,    0,    0,    0,    2156, 2158, 3,    272,  136,  0,    2157, 2156, 1,    0,    0,    0,    2157, 2158, 1,    0,    0,    0,
        2158, 2159, 1,    0,    0,    0,    2159, 2160, 3,    476,  238,  0,    2160, 2162, 5,    131,  0,    0,    2161, 2163, 3,    136,  68,   0,    2162, 2161, 1,    0,    0,    0,    2162, 2163,
        1,    0,    0,    0,    2163, 2164, 1,    0,    0,    0,    2164, 2165, 3,    506,  253,  0,    2165, 2166, 5,    138,  0,    0,    2166, 417,  1,    0,    0,    0,    2167, 2168, 5,    86,
        0,    0,    2168, 2169, 3,    232,  116,  0,    2169, 2170, 5,    145,  0,    0,    2170, 2172, 3,    472,  236,  0,    2171, 2173, 3,    420,  210,  0,    2172, 2171, 1,    0,    0,    0,
        2172, 2173, 1,    0,    0,    0,    2173, 2176, 1,    0,    0,    0,    2174, 2175, 5,    135,  0,    0,    2175, 2177, 3,    192,  96,   0,    2176, 2174, 1,    0,    0,    0,    2176, 2177,
        1,    0,    0,    0,    2177, 2178, 1,    0,    0,    0,    2178, 2179, 5,    138,  0,    0,    2179, 419,  1,    0,    0,    0,    2180, 2181, 7,    11,   0,    0,    2181, 421,  1,    0,
        0,    0,    2182, 2187, 3,    292,  146,  0,    2183, 2184, 5,    139,  0,    0,    2184, 2186, 3,    292,  146,  0,    2185, 2183, 1,    0,    0,    0,    2186, 2189, 1,    0,    0,    0,
        2187, 2185, 1,    0,    0,    0,    2187, 2188, 1,    0,    0,    0,    2188, 2193, 1,    0,    0,    0,    2189, 2187, 1,    0,    0,    0,    2190, 2193, 5,    62,   0,    0,    2191, 2193,
        5,    6,    0,    0,    2192, 2182, 1,    0,    0,    0,    2192, 2190, 1,    0,    0,    0,    2192, 2191, 1,    0,    0,    0,    2193, 423,  1,    0,    0,    0,    2194, 2203, 5,    143,
        0,    0,    2195, 2200, 3,    292,  146,  0,    2196, 2197, 5,    139,  0,    0,    2197, 2199, 3,    292,  146,  0,    2198, 2196, 1,    0,    0,    0,    2199, 2202, 1,    0,    0,    0,
        2200, 2198, 1,    0,    0,    0,    2200, 2201, 1,    0,    0,    0,    2201, 2204, 1,    0,    0,    0,    2202, 2200, 1,    0,    0,    0,    2203, 2195, 1,    0,    0,    0,    2203, 2204,
        1,    0,    0,    0,    2204, 2207, 1,    0,    0,    0,    2205, 2206, 5,    80,   0,    0,    2206, 2208, 3,    292,  146,  0,    2207, 2205, 1,    0,    0,    0,    2207, 2208, 1,    0,
        0,    0,    2208, 2209, 1,    0,    0,    0,    2209, 2210, 5,    144,  0,    0,    2210, 425,  1,    0,    0,    0,    2211, 2213, 7,    12,   0,    0,    2212, 2211, 1,    0,    0,    0,
        2212, 2213, 1,    0,    0,    0,    2213, 2214, 1,    0,    0,    0,    2214, 2220, 3,    478,  239,  0,    2215, 2216, 3,    12,   6,    0,    2216, 2217, 3,    478,  239,  0,    2217, 2219,
        1,    0,    0,    0,    2218, 2215, 1,    0,    0,    0,    2219, 2222, 1,    0,    0,    0,    2220, 2218, 1,    0,    0,    0,    2220, 2221, 1,    0,    0,    0,    2221, 427,  1,    0,
        0,    0,    2222, 2220, 1,    0,    0,    0,    2223, 2225, 3,    272,  136,  0,    2224, 2223, 1,    0,    0,    0,    2224, 2225, 1,    0,    0,    0,    2225, 2226, 1,    0,    0,    0,
        2226, 2227, 3,    426,  213,  0,    2227, 2228, 5,    130,  0,    0,    2228, 2230, 3,    426,  213,  0,    2229, 2231, 3,    488,  244,  0,    2230, 2229, 1,    0,    0,    0,    2230, 2231,
        1,    0,    0,    0,    2231, 2232, 1,    0,    0,    0,    2232, 2233, 5,    138,  0,    0,    2233, 429,  1,    0,    0,    0,    2234, 2235, 5,    108,  0,    0,    2235, 2236, 3,    84,
        42,   0,    2236, 2237, 5,    133,  0,    0,    2237, 2238, 3,    440,  220,  0,    2238, 431,  1,    0,    0,    0,    2239, 2241, 3,    272,  136,  0,    2240, 2239, 1,    0,    0,    0,
        2240, 2241, 1,    0,    0,    0,    2241, 2242, 1,    0,    0,    0,    2242, 2243, 5,    18,   0,    0,    2243, 2244, 3,    192,  96,   0,    2244, 2246, 5,    104,  0,    0,    2245, 2247,
        3,    430,  215,  0,    2246, 2245, 1,    0,    0,    0,    2247, 2248, 1,    0,    0,    0,    2248, 2246, 1,    0,    0,    0,    2248, 2249, 1,    0,    0,    0,    2249, 2250, 1,    0,
        0,    0,    2250, 2251, 5,    24,   0,    0,    2251, 2253, 5,    18,   0,    0,    2252, 2254, 3,    230,  115,  0,    2253, 2252, 1,    0,    0,    0,    2253, 2254, 1,    0,    0,    0,
        2254, 2255, 1,    0,    0,    0,    2255, 2256, 5,    138,  0,    0,    2256, 433,  1,    0,    0,    0,    2257, 2259, 3,    272,  136,  0,    2258, 2257, 1,    0,    0,    0,    2258, 2259,
        1,    0,    0,    0,    2259, 2260, 1,    0,    0,    0,    2260, 2261, 5,    36,   0,    0,    2261, 2262, 3,    106,  53,   0,    2262, 2263, 5,    104,  0,    0,    2263, 2271, 3,    440,
        220,  0,    2264, 2265, 5,    27,   0,    0,    2265, 2266, 3,    106,  53,   0,    2266, 2267, 5,    104,  0,    0,    2267, 2268, 3,    440,  220,  0,    2268, 2270, 1,    0,    0,    0,
        2269, 2264, 1,    0,    0,    0,    2270, 2273, 1,    0,    0,    0,    2271, 2269, 1,    0,    0,    0,    2271, 2272, 1,    0,    0,    0,    2272, 2276, 1,    0,    0,    0,    2273, 2271,
        1,    0,    0,    0,    2274, 2275, 5,    26,   0,    0,    2275, 2277, 3,    440,  220,  0,    2276, 2274, 1,    0,    0,    0,    2276, 2277, 1,    0,    0,    0,    2277, 2278, 1,    0,
        0,    0,    2278, 2279, 5,    24,   0,    0,    2279, 2281, 5,    104,  0,    0,    2280, 2282, 3,    230,  115,  0,    2281, 2280, 1,    0,    0,    0,    2281, 2282, 1,    0,    0,    0,
        2282, 2283, 1,    0,    0,    0,    2283, 2284, 5,    138,  0,    0,    2284, 435,  1,    0,    0,    0,    2285, 2287, 3,    272,  136,  0,    2286, 2285, 1,    0,    0,    0,    2286, 2287,
        1,    0,    0,    0,    2287, 2288, 1,    0,    0,    0,    2288, 2290, 5,    69,   0,    0,    2289, 2291, 5,    41,   0,    0,    2290, 2289, 1,    0,    0,    0,    2290, 2291, 1,    0,
        0,    0,    2291, 2292, 1,    0,    0,    0,    2292, 2293, 3,    350,  175,  0,    2293, 2294, 5,    12,   0,    0,    2294, 2295, 3,    352,  176,  0,    2295, 2296, 5,    24,   0,    0,
        2296, 2298, 5,    69,   0,    0,    2297, 2299, 3,    230,  115,  0,    2298, 2297, 1,    0,    0,    0,    2298, 2299, 1,    0,    0,    0,    2299, 2300, 1,    0,    0,    0,    2300, 2301,
        5,    138,  0,    0,    2301, 437,  1,    0,    0,    0,    2302, 2312, 3,    428,  214,  0,    2303, 2312, 3,    434,  217,  0,    2304, 2312, 3,    432,  216,  0,    2305, 2312, 3,    436,
        218,  0,    2306, 2308, 3,    272,  136,  0,    2307, 2306, 1,    0,    0,    0,    2307, 2308, 1,    0,    0,    0,    2308, 2309, 1,    0,    0,    0,    2309, 2310, 5,    57,   0,    0,
        2310, 2312, 5,    138,  0,    0,    2311, 2302, 1,    0,    0,    0,    2311, 2303, 1,    0,    0,    0,    2311, 2304, 1,    0,    0,    0,    2311, 2305, 1,    0,    0,    0,    2311, 2307,
        1,    0,    0,    0,    2312, 439,  1,    0,    0,    0,    2313, 2315, 3,    438,  219,  0,    2314, 2313, 1,    0,    0,    0,    2315, 2318, 1,    0,    0,    0,    2316, 2314, 1,    0,
        0,    0,    2316, 2317, 1,    0,    0,    0,    2317, 441,  1,    0,    0,    0,    2318, 2316, 1,    0,    0,    0,    2319, 2320, 5,    89,   0,    0,    2320, 2321, 3,    426,  213,  0,
        2321, 2322, 5,    139,  0,    0,    2322, 2323, 3,    426,  213,  0,    2323, 2327, 1,    0,    0,    0,    2324, 2325, 5,    54,   0,    0,    2325, 2327, 3,    426,  213,  0,    2326, 2319,
        1,    0,    0,    0,    2326, 2324, 1,    0,    0,    0,    2327, 443,  1,    0,    0,    0,    2328, 2329, 5,    71,   0,    0,    2329, 2330, 3,    232,  116,  0,    2330, 2331, 5,    145,
        0,    0,    2331, 2332, 3,    472,  236,  0,    2332, 2333, 3,    442,  221,  0,    2333, 2334, 5,    138,  0,    0,    2334, 445,  1,    0,    0,    0,    2335, 2336, 5,    44,   0,    0,
        2336, 2337, 3,    372,  186,  0,    2337, 2338, 5,    107,  0,    0,    2338, 2339, 3,    192,  96,   0,    2339, 2340, 5,    138,  0,    0,    2340, 447,  1,    0,    0,    0,    2341, 2342,
        5,    92,   0,    0,    2342, 2343, 3,    230,  115,  0,    2343, 2344, 5,    41,   0,    0,    2344, 2345, 3,    450,  225,  0,    2345, 2346, 5,    138,  0,    0,    2346, 449,  1,    0,
        0,    0,    2347, 2349, 3,    292,  146,  0,    2348, 2350, 3,    236,  118,  0,    2349, 2348, 1,    0,    0,    0,    2349, 2350, 1,    0,    0,    0,    2350, 2357, 1,    0,    0,    0,
        2351, 2352, 5,    98,   0,    0,    2352, 2353, 3,    192,  96,   0,    2353, 2354, 5,    3,    0,    0,    2354, 2355, 3,    192,  96,   0,    2355, 2356, 5,    96,   0,    0,    2356, 2358,
        1,    0,    0,    0,    2357, 2351, 1,    0,    0,    0,    2357, 2358, 1,    0,    0,    0,    2358, 451,  1,    0,    0,    0,    2359, 2360, 3,    462,  231,  0,    2360, 2361, 5,    41,
        0,    0,    2361, 2362, 3,    458,  229,  0,    2362, 2363, 5,    12,   0,    0,    2363, 2364, 3,    468,  234,  0,    2364, 2366, 5,    24,   0,    0,    2365, 2367, 3,    460,  230,  0,
        2366, 2365, 1,    0,    0,    0,    2366, 2367, 1,    0,    0,    0,    2367, 2369, 1,    0,    0,    0,    2368, 2370, 3,    142,  71,   0,    2369, 2368, 1,    0,    0,    0,    2369, 2370,
        1,    0,    0,    0,    2370, 2371, 1,    0,    0,    0,    2371, 2372, 5,    138,  0,    0,    2372, 453,  1,    0,    0,    0,    2373, 2374, 3,    462,  231,  0,    2374, 2375, 5,    138,
        0,    0,    2375, 455,  1,    0,    0,    0,    2376, 2390, 3,    454,  227,  0,    2377, 2390, 3,    452,  226,  0,    2378, 2390, 3,    490,  245,  0,    2379, 2390, 3,    470,  235,  0,
        2380, 2390, 3,    124,  62,   0,    2381, 2390, 3,    502,  251,  0,    2382, 2390, 3,    196,  98,   0,    2383, 2390, 3,    16,   8,    0,    2384, 2390, 3,    44,   22,   0,    2385, 2390,
        3,    48,   24,   0,    2386, 2390, 3,    498,  249,  0,    2387, 2390, 3,    226,  113,  0,    2388, 2390, 3,    224,  112,  0,    2389, 2376, 1,    0,    0,    0,    2389, 2377, 1,    0,
        0,    0,    2389, 2378, 1,    0,    0,    0,    2389, 2379, 1,    0,    0,    0,    2389, 2380, 1,    0,    0,    0,    2389, 2381, 1,    0,    0,    0,    2389, 2382, 1,    0,    0,    0,
        2389, 2383, 1,    0,    0,    0,    2389, 2384, 1,    0,    0,    0,    2389, 2385, 1,    0,    0,    0,    2389, 2386, 1,    0,    0,    0,    2389, 2387, 1,    0,    0,    0,    2389, 2388,
        1,    0,    0,    0,    2390, 457,  1,    0,    0,    0,    2391, 2393, 3,    456,  228,  0,    2392, 2391, 1,    0,    0,    0,    2393, 2396, 1,    0,    0,    0,    2394, 2392, 1,    0,
        0,    0,    2394, 2395, 1,    0,    0,    0,    2395, 459,  1,    0,    0,    0,    2396, 2394, 1,    0,    0,    0,    2397, 2398, 7,    13,   0,    0,    2398, 461,  1,    0,    0,    0,
        2399, 2402, 3,    464,  232,  0,    2400, 2402, 3,    466,  233,  0,    2401, 2399, 1,    0,    0,    0,    2401, 2400, 1,    0,    0,    0,    2402, 463,  1,    0,    0,    0,    2403, 2404,
        5,    68,   0,    0,    2404, 2409, 3,    142,  71,   0,    2405, 2406, 5,    141,  0,    0,    2406, 2407, 3,    204,  102,  0,    2407, 2408, 5,    142,  0,    0,    2408, 2410, 1,    0,
        0,    0,    2409, 2405, 1,    0,    0,    0,    2409, 2410, 1,    0,    0,    0,    2410, 465,  1,    0,    0,    0,    2411, 2413, 7,    14,   0,    0,    2412, 2411, 1,    0,    0,    0,
        2412, 2413, 1,    0,    0,    0,    2413, 2414, 1,    0,    0,    0,    2414, 2415, 5,    31,   0,    0,    2415, 2420, 3,    142,  71,   0,    2416, 2417, 5,    141,  0,    0,    2417, 2418,
        3,    204,  102,  0,    2418, 2419, 5,    142,  0,    0,    2419, 2421, 1,    0,    0,    0,    2420, 2416, 1,    0,    0,    0,    2420, 2421, 1,    0,    0,    0,    2421, 2422, 1,    0,
        0,    0,    2422, 2423, 5,    80,   0,    0,    2423, 2424, 3,    472,  236,  0,    2424, 467,  1,    0,    0,    0,    2425, 2427, 3,    410,  205,  0,    2426, 2425, 1,    0,    0,    0,
        2427, 2430, 1,    0,    0,    0,    2428, 2426, 1,    0,    0,    0,    2428, 2429, 1,    0,    0,    0,    2429, 469,  1,    0,    0,    0,    2430, 2428, 1,    0,    0,    0,    2431, 2432,
        5,    93,   0,    0,    2432, 2433, 3,    230,  115,  0,    2433, 2434, 5,    41,   0,    0,    2434, 2435, 3,    472,  236,  0,    2435, 2436, 5,    138,  0,    0,    2436, 471,  1,    0,
        0,    0,    2437, 2439, 3,    296,  148,  0,    2438, 2440, 3,    296,  148,  0,    2439, 2438, 1,    0,    0,    0,    2439, 2440, 1,    0,    0,    0,    2440, 2442, 1,    0,    0,    0,
        2441, 2443, 3,    130,  65,   0,    2442, 2441, 1,    0,    0,    0,    2442, 2443, 1,    0,    0,    0,    2443, 2445, 1,    0,    0,    0,    2444, 2446, 3,    488,  244,  0,    2445, 2444,
        1,    0,    0,    0,    2445, 2446, 1,    0,    0,    0,    2446, 473,  1,    0,    0,    0,    2447, 2452, 3,    230,  115,  0,    2448, 2452, 5,    126,  0,    0,    2449, 2452, 5,    127,
        0,    0,    2450, 2452, 5,    6,    0,    0,    2451, 2447, 1,    0,    0,    0,    2451, 2448, 1,    0,    0,    0,    2451, 2449, 1,    0,    0,    0,    2451, 2450, 1,    0,    0,    0,
        2452, 475,  1,    0,    0,    0,    2453, 2456, 3,    292,  146,  0,    2454, 2456, 3,    14,   7,    0,    2455, 2453, 1,    0,    0,    0,    2455, 2454, 1,    0,    0,    0,    2456, 477,
        1,    0,    0,    0,    2457, 2463, 3,    194,  97,   0,    2458, 2459, 3,    290,  145,  0,    2459, 2460, 3,    194,  97,   0,    2460, 2462, 1,    0,    0,    0,    2461, 2458, 1,    0,
        0,    0,    2462, 2465, 1,    0,    0,    0,    2463, 2461, 1,    0,    0,    0,    2463, 2464, 1,    0,    0,    0,    2464, 479,  1,    0,    0,    0,    2465, 2463, 1,    0,    0,    0,
        2466, 2469, 3,    292,  146,  0,    2467, 2468, 5,    97,   0,    0,    2468, 2470, 3,    292,  146,  0,    2469, 2467, 1,    0,    0,    0,    2469, 2470, 1,    0,    0,    0,    2470, 481,
        1,    0,    0,    0,    2471, 2472, 5,    94,   0,    0,    2472, 2473, 3,    232,  116,  0,    2473, 2474, 5,    145,  0,    0,    2474, 2475, 3,    450,  225,  0,    2475, 2476, 5,    138,
        0,    0,    2476, 483,  1,    0,    0,    0,    2477, 2479, 3,    232,  116,  0,    2478, 2480, 3,    488,  244,  0,    2479, 2478, 1,    0,    0,    0,    2479, 2480, 1,    0,    0,    0,
        2480, 2483, 1,    0,    0,    0,    2481, 2482, 5,    135,  0,    0,    2482, 2484, 3,    192,  96,   0,    2483, 2481, 1,    0,    0,    0,    2483, 2484, 1,    0,    0,    0,    2484, 2485,
        1,    0,    0,    0,    2485, 2486, 5,    96,   0,    0,    2486, 485,  1,    0,    0,    0,    2487, 2488, 5,    30,   0,    0,    2488, 2489, 3,    192,  96,   0,    2489, 487,  1,    0,
        0,    0,    2490, 2491, 5,    98,   0,    0,    2491, 2492, 3,    192,  96,   0,    2492, 489,  1,    0,    0,    0,    2493, 2494, 5,    100,  0,    0,    2494, 2497, 3,    230,  115,  0,
        2495, 2496, 5,    41,   0,    0,    2496, 2498, 3,    492,  246,  0,    2497, 2495, 1,    0,    0,    0,    2497, 2498, 1,    0,    0,    0,    2498, 2499, 1,    0,    0,    0,    2499, 2500,
        5,    138,  0,    0,    2500, 491,  1,    0,    0,    0,    2501, 2506, 3,    394,  197,  0,    2502, 2506, 3,    96,   48,   0,    2503, 2506, 3,    2,    1,    0,    2504, 2506, 3,    202,
        101,  0,    2505, 2501, 1,    0,    0,    0,    2505, 2502, 1,    0,    0,    0,    2505, 2503, 1,    0,    0,    0,    2505, 2504, 1,    0,    0,    0,    2506, 493,  1,    0,    0,    0,
        2507, 2508, 5,    9,    0,    0,    2508, 2509, 5,    141,  0,    0,    2509, 2514, 3,    240,  120,  0,    2510, 2511, 5,    139,  0,    0,    2511, 2513, 3,    240,  120,  0,    2512, 2510,
        1,    0,    0,    0,    2513, 2516, 1,    0,    0,    0,    2514, 2512, 1,    0,    0,    0,    2514, 2515, 1,    0,    0,    0,    2515, 2517, 1,    0,    0,    0,    2516, 2514, 1,    0,
        0,    0,    2517, 2518, 5,    142,  0,    0,    2518, 2519, 5,    58,   0,    0,    2519, 2520, 3,    472,  236,  0,    2520, 495,  1,    0,    0,    0,    2521, 2522, 5,    9,    0,    0,
        2522, 2523, 5,    141,  0,    0,    2523, 2528, 3,    240,  120,  0,    2524, 2525, 5,    139,  0,    0,    2525, 2527, 3,    240,  120,  0,    2526, 2524, 1,    0,    0,    0,    2527, 2530,
        1,    0,    0,    0,    2528, 2526, 1,    0,    0,    0,    2528, 2529, 1,    0,    0,    0,    2529, 2531, 1,    0,    0,    0,    2530, 2528, 1,    0,    0,    0,    2531, 2532, 5,    142,
        0,    0,    2532, 2533, 5,    58,   0,    0,    2533, 2534, 3,    450,  225,  0,    2534, 497,  1,    0,    0,    0,    2535, 2536, 5,    104,  0,    0,    2536, 2541, 3,    296,  148,  0,
        2537, 2538, 5,    139,  0,    0,    2538, 2540, 3,    296,  148,  0,    2539, 2537, 1,    0,    0,    0,    2540, 2543, 1,    0,    0,    0,    2541, 2539, 1,    0,    0,    0,    2541, 2542,
        1,    0,    0,    0,    2542, 2544, 1,    0,    0,    0,    2543, 2541, 1,    0,    0,    0,    2544, 2545, 5,    138,  0,    0,    2545, 499,  1,    0,    0,    0,    2546, 2548, 3,    272,
        136,  0,    2547, 2546, 1,    0,    0,    0,    2547, 2548, 1,    0,    0,    0,    2548, 2549, 1,    0,    0,    0,    2549, 2550, 3,    476,  238,  0,    2550, 2551, 5,    135,  0,    0,
        2551, 2552, 3,    192,  96,   0,    2552, 2553, 5,    138,  0,    0,    2553, 501,  1,    0,    0,    0,    2554, 2556, 5,    85,   0,    0,    2555, 2554, 1,    0,    0,    0,    2555, 2556,
        1,    0,    0,    0,    2556, 2557, 1,    0,    0,    0,    2557, 2558, 5,    105,  0,    0,    2558, 2559, 3,    232,  116,  0,    2559, 2560, 5,    145,  0,    0,    2560, 2563, 3,    472,
        236,  0,    2561, 2562, 5,    135,  0,    0,    2562, 2564, 3,    192,  96,   0,    2563, 2561, 1,    0,    0,    0,    2563, 2564, 1,    0,    0,    0,    2564, 2565, 1,    0,    0,    0,
        2565, 2566, 5,    138,  0,    0,    2566, 503,  1,    0,    0,    0,    2567, 2569, 3,    272,  136,  0,    2568, 2567, 1,    0,    0,    0,    2568, 2569, 1,    0,    0,    0,    2569, 2570,
        1,    0,    0,    0,    2570, 2572, 5,    106,  0,    0,    2571, 2573, 3,    404,  202,  0,    2572, 2571, 1,    0,    0,    0,    2572, 2573, 1,    0,    0,    0,    2573, 2575, 1,    0,
        0,    0,    2574, 2576, 3,    108,  54,   0,    2575, 2574, 1,    0,    0,    0,    2575, 2576, 1,    0,    0,    0,    2576, 2578, 1,    0,    0,    0,    2577, 2579, 3,    486,  243,  0,
        2578, 2577, 1,    0,    0,    0,    2578, 2579, 1,    0,    0,    0,    2579, 2580, 1,    0,    0,    0,    2580, 2581, 5,    138,  0,    0,    2581, 505,  1,    0,    0,    0,    2582, 2587,
        3,    508,  254,  0,    2583, 2584, 5,    139,  0,    0,    2584, 2586, 3,    508,  254,  0,    2585, 2583, 1,    0,    0,    0,    2586, 2589, 1,    0,    0,    0,    2587, 2585, 1,    0,
        0,    0,    2587, 2588, 1,    0,    0,    0,    2588, 2592, 1,    0,    0,    0,    2589, 2587, 1,    0,    0,    0,    2590, 2592, 5,    101,  0,    0,    2591, 2582, 1,    0,    0,    0,
        2591, 2590, 1,    0,    0,    0,    2592, 507,  1,    0,    0,    0,    2593, 2596, 3,    192,  96,   0,    2594, 2595, 5,    4,    0,    0,    2595, 2597, 3,    192,  96,   0,    2596, 2594,
        1,    0,    0,    0,    2596, 2597, 1,    0,    0,    0,    2597, 509,  1,    0,    0,    0,    294,  517,  521,  527,  537,  547,  556,  561,  568,  572,  577,  589,  592,  599,  605,  609,
        613,  616,  623,  628,  633,  637,  643,  647,  650,  658,  667,  682,  697,  700,  703,  710,  716,  745,  750,  757,  759,  765,  767,  774,  777,  785,  788,  797,  804,  809,  812,  818,
        829,  837,  841,  845,  850,  858,  863,  876,  883,  891,  894,  903,  906,  909,  914,  921,  924,  934,  938,  941,  944,  950,  954,  957,  961,  966,  969,  975,  978,  982,  1000, 1002,
        1013, 1016, 1023, 1028, 1033, 1046, 1062, 1067, 1072, 1077, 1080, 1085, 1095, 1107, 1112, 1131, 1136, 1142, 1149, 1159, 1163, 1166, 1190, 1195, 1200, 1203, 1206, 1213, 1218, 1227, 1232, 1238,
        1242, 1250, 1256, 1260, 1264, 1274, 1280, 1286, 1293, 1301, 1318, 1326, 1336, 1340, 1345, 1351, 1359, 1372, 1383, 1390, 1420, 1424, 1437, 1442, 1447, 1457, 1464, 1471, 1480, 1484, 1491, 1496,
        1499, 1504, 1509, 1517, 1531, 1539, 1547, 1554, 1559, 1564, 1568, 1572, 1578, 1582, 1586, 1594, 1599, 1604, 1610, 1621, 1628, 1637, 1643, 1646, 1653, 1663, 1668, 1675, 1682, 1689, 1700, 1708,
        1718, 1725, 1729, 1733, 1739, 1747, 1750, 1753, 1763, 1766, 1781, 1786, 1795, 1798, 1821, 1826, 1842, 1848, 1873, 1878, 1892, 1897, 1903, 1911, 1914, 1932, 1937, 1941, 1944, 1951, 1954, 1961,
        1965, 1972, 1982, 1987, 1994, 1999, 2007, 2013, 2022, 2027, 2033, 2038, 2044, 2049, 2055, 2060, 2064, 2078, 2082, 2108, 2119, 2125, 2140, 2146, 2152, 2157, 2162, 2172, 2176, 2187, 2192, 2200,
        2203, 2207, 2212, 2220, 2224, 2230, 2240, 2248, 2253, 2258, 2271, 2276, 2281, 2286, 2290, 2298, 2307, 2311, 2316, 2326, 2349, 2357, 2366, 2369, 2389, 2394, 2401, 2409, 2412, 2420, 2428, 2439,
        2442, 2445, 2451, 2455, 2463, 2469, 2479, 2483, 2497, 2505, 2514, 2528, 2541, 2547, 2555, 2563, 2568, 2572, 2575, 2578, 2587, 2591, 2596};
    staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

    antlr4::atn::ATNDeserializer deserializer;
    staticData->atn = deserializer.deserialize(staticData->serializedATN);

    const size_t count = staticData->atn->getNumberOfDecisions();
    staticData->decisionToDFA.reserve(count);
    for (size_t i = 0; i < count; i++)
    {
        staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
    }
    vhdlParserStaticData = std::move(staticData);
}

} // namespace

VHDLParser::VHDLParser(TokenStream *input) : VHDLParser(input, antlr4::atn::ParserATNSimulatorOptions())
{
}

VHDLParser::VHDLParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input)
{
    VHDLParser::initialize();
    _interpreter = new atn::ParserATNSimulator(this, *vhdlParserStaticData->atn, vhdlParserStaticData->decisionToDFA, vhdlParserStaticData->sharedContextCache, options);
}

VHDLParser::~VHDLParser()
{
    delete _interpreter;
}

const atn::ATN &VHDLParser::getATN() const
{
    return *vhdlParserStaticData->atn;
}

std::string VHDLParser::getGrammarFileName() const
{
    return "VHDL.g4";
}

const std::vector<std::string> &VHDLParser::getRuleNames() const
{
    return vhdlParserStaticData->ruleNames;
}

const dfa::Vocabulary &VHDLParser::getVocabulary() const
{
    return vhdlParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView VHDLParser::getSerializedATN() const
{
    return vhdlParserStaticData->serializedATN;
}

//----------------- Abstract_literalContext
//------------------------------------------------------------------

VHDLParser::Abstract_literalContext::Abstract_literalContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Abstract_literalContext::INTEGER()
{
    return getToken(VHDLParser::INTEGER, 0);
}

tree::TerminalNode *VHDLParser::Abstract_literalContext::REAL_LITERAL()
{
    return getToken(VHDLParser::REAL_LITERAL, 0);
}

tree::TerminalNode *VHDLParser::Abstract_literalContext::BASE_LITERAL()
{
    return getToken(VHDLParser::BASE_LITERAL, 0);
}

size_t VHDLParser::Abstract_literalContext::getRuleIndex() const
{
    return VHDLParser::RuleAbstract_literal;
}

void VHDLParser::Abstract_literalContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAbstract_literal(this);
}

void VHDLParser::Abstract_literalContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAbstract_literal(this);
}

std::any VHDLParser::Abstract_literalContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAbstract_literal(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Abstract_literalContext *VHDLParser::abstract_literal()
{
    Abstract_literalContext *_localctx = _tracker.createInstance<Abstract_literalContext>(_ctx, getState());
    enterRule(_localctx, 0, VHDLParser::RuleAbstract_literal);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(510);
        _la = _input->LA(1);
        if (!(((((_la - 112) & ~0x3fULL) == 0) && ((1ULL << (_la - 112)) & 70368744177697) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Access_type_definitionContext
//------------------------------------------------------------------

VHDLParser::Access_type_definitionContext::Access_type_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Access_type_definitionContext::ACCESS()
{
    return getToken(VHDLParser::ACCESS, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Access_type_definitionContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

size_t VHDLParser::Access_type_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleAccess_type_definition;
}

void VHDLParser::Access_type_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAccess_type_definition(this);
}

void VHDLParser::Access_type_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAccess_type_definition(this);
}

std::any VHDLParser::Access_type_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAccess_type_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Access_type_definitionContext *VHDLParser::access_type_definition()
{
    Access_type_definitionContext *_localctx = _tracker.createInstance<Access_type_definitionContext>(_ctx, getState());
    enterRule(_localctx, 2, VHDLParser::RuleAccess_type_definition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(512);
        match(VHDLParser::ACCESS);
        setState(513);
        subtype_indication();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Across_aspectContext
//------------------------------------------------------------------

VHDLParser::Across_aspectContext::Across_aspectContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Identifier_listContext *VHDLParser::Across_aspectContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Across_aspectContext::ACROSS()
{
    return getToken(VHDLParser::ACROSS, 0);
}

VHDLParser::Tolerance_aspectContext *VHDLParser::Across_aspectContext::tolerance_aspect()
{
    return getRuleContext<VHDLParser::Tolerance_aspectContext>(0);
}

tree::TerminalNode *VHDLParser::Across_aspectContext::VARASGN()
{
    return getToken(VHDLParser::VARASGN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Across_aspectContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::Across_aspectContext::getRuleIndex() const
{
    return VHDLParser::RuleAcross_aspect;
}

void VHDLParser::Across_aspectContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAcross_aspect(this);
}

void VHDLParser::Across_aspectContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAcross_aspect(this);
}

std::any VHDLParser::Across_aspectContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAcross_aspect(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Across_aspectContext *VHDLParser::across_aspect()
{
    Across_aspectContext *_localctx = _tracker.createInstance<Across_aspectContext>(_ctx, getState());
    enterRule(_localctx, 4, VHDLParser::RuleAcross_aspect);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(515);
        identifier_list();
        setState(517);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::TOLERANCE)
        {
            setState(516);
            tolerance_aspect();
        }
        setState(521);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::VARASGN)
        {
            setState(519);
            match(VHDLParser::VARASGN);
            setState(520);
            expression();
        }
        setState(523);
        match(VHDLParser::ACROSS);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Actual_designatorContext
//------------------------------------------------------------------

VHDLParser::Actual_designatorContext::Actual_designatorContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::ExpressionContext *VHDLParser::Actual_designatorContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

tree::TerminalNode *VHDLParser::Actual_designatorContext::OPEN()
{
    return getToken(VHDLParser::OPEN, 0);
}

size_t VHDLParser::Actual_designatorContext::getRuleIndex() const
{
    return VHDLParser::RuleActual_designator;
}

void VHDLParser::Actual_designatorContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterActual_designator(this);
}

void VHDLParser::Actual_designatorContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitActual_designator(this);
}

std::any VHDLParser::Actual_designatorContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitActual_designator(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Actual_designatorContext *VHDLParser::actual_designator()
{
    Actual_designatorContext *_localctx = _tracker.createInstance<Actual_designatorContext>(_ctx, getState());
    enterRule(_localctx, 6, VHDLParser::RuleActual_designator);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(527);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::ABS:
        case VHDLParser::NEW:
        case VHDLParser::NOT:
        case VHDLParser::NULL_:
        case VHDLParser::BASE_LITERAL:
        case VHDLParser::BIT_STRING_LITERAL:
        case VHDLParser::REAL_LITERAL:
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER:
        case VHDLParser::CHARACTER_LITERAL:
        case VHDLParser::STRING_LITERAL:
        case VHDLParser::LPAREN:
        case VHDLParser::PLUS:
        case VHDLParser::MINUS:
        case VHDLParser::INTEGER: {
            enterOuterAlt(_localctx, 1);
            setState(525);
            expression();
            break;
        }

        case VHDLParser::OPEN: {
            enterOuterAlt(_localctx, 2);
            setState(526);
            match(VHDLParser::OPEN);
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Actual_parameter_partContext
//------------------------------------------------------------------

VHDLParser::Actual_parameter_partContext::Actual_parameter_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Association_listContext *VHDLParser::Actual_parameter_partContext::association_list()
{
    return getRuleContext<VHDLParser::Association_listContext>(0);
}

size_t VHDLParser::Actual_parameter_partContext::getRuleIndex() const
{
    return VHDLParser::RuleActual_parameter_part;
}

void VHDLParser::Actual_parameter_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterActual_parameter_part(this);
}

void VHDLParser::Actual_parameter_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitActual_parameter_part(this);
}

std::any VHDLParser::Actual_parameter_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitActual_parameter_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Actual_parameter_partContext *VHDLParser::actual_parameter_part()
{
    Actual_parameter_partContext *_localctx = _tracker.createInstance<Actual_parameter_partContext>(_ctx, getState());
    enterRule(_localctx, 8, VHDLParser::RuleActual_parameter_part);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(529);
        association_list();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Actual_partContext
//------------------------------------------------------------------

VHDLParser::Actual_partContext::Actual_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::NameContext *VHDLParser::Actual_partContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

tree::TerminalNode *VHDLParser::Actual_partContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::Actual_designatorContext *VHDLParser::Actual_partContext::actual_designator()
{
    return getRuleContext<VHDLParser::Actual_designatorContext>(0);
}

tree::TerminalNode *VHDLParser::Actual_partContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

size_t VHDLParser::Actual_partContext::getRuleIndex() const
{
    return VHDLParser::RuleActual_part;
}

void VHDLParser::Actual_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterActual_part(this);
}

void VHDLParser::Actual_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitActual_part(this);
}

std::any VHDLParser::Actual_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitActual_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Actual_partContext *VHDLParser::actual_part()
{
    Actual_partContext *_localctx = _tracker.createInstance<Actual_partContext>(_ctx, getState());
    enterRule(_localctx, 10, VHDLParser::RuleActual_part);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(537);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(531);
            name();
            setState(532);
            match(VHDLParser::LPAREN);
            setState(533);
            actual_designator();
            setState(534);
            match(VHDLParser::RPAREN);
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(536);
            actual_designator();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Adding_operatorContext
//------------------------------------------------------------------

VHDLParser::Adding_operatorContext::Adding_operatorContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Adding_operatorContext::PLUS()
{
    return getToken(VHDLParser::PLUS, 0);
}

tree::TerminalNode *VHDLParser::Adding_operatorContext::MINUS()
{
    return getToken(VHDLParser::MINUS, 0);
}

tree::TerminalNode *VHDLParser::Adding_operatorContext::AMPERSAND()
{
    return getToken(VHDLParser::AMPERSAND, 0);
}

size_t VHDLParser::Adding_operatorContext::getRuleIndex() const
{
    return VHDLParser::RuleAdding_operator;
}

void VHDLParser::Adding_operatorContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAdding_operator(this);
}

void VHDLParser::Adding_operatorContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAdding_operator(this);
}

std::any VHDLParser::Adding_operatorContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAdding_operator(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Adding_operatorContext *VHDLParser::adding_operator()
{
    Adding_operatorContext *_localctx = _tracker.createInstance<Adding_operatorContext>(_ctx, getState());
    enterRule(_localctx, 12, VHDLParser::RuleAdding_operator);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(539);
        _la = _input->LA(1);
        if (!(((((_la - 140) & ~0x3fULL) == 0) && ((1ULL << (_la - 140)) & 769) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- AggregateContext
//------------------------------------------------------------------

VHDLParser::AggregateContext::AggregateContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::AggregateContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

std::vector<VHDLParser::Element_associationContext *> VHDLParser::AggregateContext::element_association()
{
    return getRuleContexts<VHDLParser::Element_associationContext>();
}

VHDLParser::Element_associationContext *VHDLParser::AggregateContext::element_association(size_t i)
{
    return getRuleContext<VHDLParser::Element_associationContext>(i);
}

tree::TerminalNode *VHDLParser::AggregateContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

std::vector<tree::TerminalNode *> VHDLParser::AggregateContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::AggregateContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

size_t VHDLParser::AggregateContext::getRuleIndex() const
{
    return VHDLParser::RuleAggregate;
}

void VHDLParser::AggregateContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAggregate(this);
}

void VHDLParser::AggregateContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAggregate(this);
}

std::any VHDLParser::AggregateContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAggregate(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::AggregateContext *VHDLParser::aggregate()
{
    AggregateContext *_localctx = _tracker.createInstance<AggregateContext>(_ctx, getState());
    enterRule(_localctx, 14, VHDLParser::RuleAggregate);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(541);
        match(VHDLParser::LPAREN);
        setState(542);
        element_association();
        setState(547);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::COMMA)
        {
            setState(543);
            match(VHDLParser::COMMA);
            setState(544);
            element_association();
            setState(549);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(550);
        match(VHDLParser::RPAREN);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Alias_declarationContext
//------------------------------------------------------------------

VHDLParser::Alias_declarationContext::Alias_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Alias_declarationContext::ALIAS()
{
    return getToken(VHDLParser::ALIAS, 0);
}

VHDLParser::Alias_designatorContext *VHDLParser::Alias_declarationContext::alias_designator()
{
    return getRuleContext<VHDLParser::Alias_designatorContext>(0);
}

tree::TerminalNode *VHDLParser::Alias_declarationContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::NameContext *VHDLParser::Alias_declarationContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

tree::TerminalNode *VHDLParser::Alias_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

tree::TerminalNode *VHDLParser::Alias_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Alias_indicationContext *VHDLParser::Alias_declarationContext::alias_indication()
{
    return getRuleContext<VHDLParser::Alias_indicationContext>(0);
}

VHDLParser::SignatureContext *VHDLParser::Alias_declarationContext::signature()
{
    return getRuleContext<VHDLParser::SignatureContext>(0);
}

size_t VHDLParser::Alias_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleAlias_declaration;
}

void VHDLParser::Alias_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAlias_declaration(this);
}

void VHDLParser::Alias_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAlias_declaration(this);
}

std::any VHDLParser::Alias_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAlias_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Alias_declarationContext *VHDLParser::alias_declaration()
{
    Alias_declarationContext *_localctx = _tracker.createInstance<Alias_declarationContext>(_ctx, getState());
    enterRule(_localctx, 16, VHDLParser::RuleAlias_declaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(552);
        match(VHDLParser::ALIAS);
        setState(553);
        alias_designator();
        setState(556);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::COLON)
        {
            setState(554);
            match(VHDLParser::COLON);
            setState(555);
            alias_indication();
        }
        setState(558);
        match(VHDLParser::IS);
        setState(559);
        name();
        setState(561);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::LBRACKET)
        {
            setState(560);
            signature();
        }
        setState(563);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Alias_designatorContext
//------------------------------------------------------------------

VHDLParser::Alias_designatorContext::Alias_designatorContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::IdentifierContext *VHDLParser::Alias_designatorContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Alias_designatorContext::CHARACTER_LITERAL()
{
    return getToken(VHDLParser::CHARACTER_LITERAL, 0);
}

tree::TerminalNode *VHDLParser::Alias_designatorContext::STRING_LITERAL()
{
    return getToken(VHDLParser::STRING_LITERAL, 0);
}

size_t VHDLParser::Alias_designatorContext::getRuleIndex() const
{
    return VHDLParser::RuleAlias_designator;
}

void VHDLParser::Alias_designatorContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAlias_designator(this);
}

void VHDLParser::Alias_designatorContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAlias_designator(this);
}

std::any VHDLParser::Alias_designatorContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAlias_designator(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Alias_designatorContext *VHDLParser::alias_designator()
{
    Alias_designatorContext *_localctx = _tracker.createInstance<Alias_designatorContext>(_ctx, getState());
    enterRule(_localctx, 18, VHDLParser::RuleAlias_designator);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(568);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER: {
            enterOuterAlt(_localctx, 1);
            setState(565);
            identifier();
            break;
        }

        case VHDLParser::CHARACTER_LITERAL: {
            enterOuterAlt(_localctx, 2);
            setState(566);
            match(VHDLParser::CHARACTER_LITERAL);
            break;
        }

        case VHDLParser::STRING_LITERAL: {
            enterOuterAlt(_localctx, 3);
            setState(567);
            match(VHDLParser::STRING_LITERAL);
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Alias_indicationContext
//------------------------------------------------------------------

VHDLParser::Alias_indicationContext::Alias_indicationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Subnature_indicationContext *VHDLParser::Alias_indicationContext::subnature_indication()
{
    return getRuleContext<VHDLParser::Subnature_indicationContext>(0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Alias_indicationContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

size_t VHDLParser::Alias_indicationContext::getRuleIndex() const
{
    return VHDLParser::RuleAlias_indication;
}

void VHDLParser::Alias_indicationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAlias_indication(this);
}

void VHDLParser::Alias_indicationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAlias_indication(this);
}

std::any VHDLParser::Alias_indicationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAlias_indication(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Alias_indicationContext *VHDLParser::alias_indication()
{
    Alias_indicationContext *_localctx = _tracker.createInstance<Alias_indicationContext>(_ctx, getState());
    enterRule(_localctx, 20, VHDLParser::RuleAlias_indication);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(572);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(570);
            subnature_indication();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(571);
            subtype_indication();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- AllocatorContext
//------------------------------------------------------------------

VHDLParser::AllocatorContext::AllocatorContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::AllocatorContext::NEW()
{
    return getToken(VHDLParser::NEW, 0);
}

VHDLParser::Qualified_expressionContext *VHDLParser::AllocatorContext::qualified_expression()
{
    return getRuleContext<VHDLParser::Qualified_expressionContext>(0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::AllocatorContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

size_t VHDLParser::AllocatorContext::getRuleIndex() const
{
    return VHDLParser::RuleAllocator;
}

void VHDLParser::AllocatorContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAllocator(this);
}

void VHDLParser::AllocatorContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAllocator(this);
}

std::any VHDLParser::AllocatorContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAllocator(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::AllocatorContext *VHDLParser::allocator()
{
    AllocatorContext *_localctx = _tracker.createInstance<AllocatorContext>(_ctx, getState());
    enterRule(_localctx, 22, VHDLParser::RuleAllocator);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(574);
        match(VHDLParser::NEW);
        setState(577);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx))
        {
        case 1: {
            setState(575);
            qualified_expression();
            break;
        }

        case 2: {
            setState(576);
            subtype_indication();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Architecture_bodyContext
//------------------------------------------------------------------

VHDLParser::Architecture_bodyContext::Architecture_bodyContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::Architecture_bodyContext::ARCHITECTURE()
{
    return getTokens(VHDLParser::ARCHITECTURE);
}

tree::TerminalNode *VHDLParser::Architecture_bodyContext::ARCHITECTURE(size_t i)
{
    return getToken(VHDLParser::ARCHITECTURE, i);
}

std::vector<VHDLParser::IdentifierContext *> VHDLParser::Architecture_bodyContext::identifier()
{
    return getRuleContexts<VHDLParser::IdentifierContext>();
}

VHDLParser::IdentifierContext *VHDLParser::Architecture_bodyContext::identifier(size_t i)
{
    return getRuleContext<VHDLParser::IdentifierContext>(i);
}

tree::TerminalNode *VHDLParser::Architecture_bodyContext::OF()
{
    return getToken(VHDLParser::OF, 0);
}

tree::TerminalNode *VHDLParser::Architecture_bodyContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::Architecture_declarative_partContext *VHDLParser::Architecture_bodyContext::architecture_declarative_part()
{
    return getRuleContext<VHDLParser::Architecture_declarative_partContext>(0);
}

tree::TerminalNode *VHDLParser::Architecture_bodyContext::BEGIN()
{
    return getToken(VHDLParser::BEGIN, 0);
}

VHDLParser::Architecture_statement_partContext *VHDLParser::Architecture_bodyContext::architecture_statement_part()
{
    return getRuleContext<VHDLParser::Architecture_statement_partContext>(0);
}

tree::TerminalNode *VHDLParser::Architecture_bodyContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::Architecture_bodyContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Architecture_bodyContext::getRuleIndex() const
{
    return VHDLParser::RuleArchitecture_body;
}

void VHDLParser::Architecture_bodyContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterArchitecture_body(this);
}

void VHDLParser::Architecture_bodyContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitArchitecture_body(this);
}

std::any VHDLParser::Architecture_bodyContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitArchitecture_body(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Architecture_bodyContext *VHDLParser::architecture_body()
{
    Architecture_bodyContext *_localctx = _tracker.createInstance<Architecture_bodyContext>(_ctx, getState());
    enterRule(_localctx, 24, VHDLParser::RuleArchitecture_body);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(579);
        match(VHDLParser::ARCHITECTURE);
        setState(580);
        identifier();
        setState(581);
        match(VHDLParser::OF);
        setState(582);
        identifier();
        setState(583);
        match(VHDLParser::IS);
        setState(584);
        architecture_declarative_part();
        setState(585);
        match(VHDLParser::BEGIN);
        setState(586);
        architecture_statement_part();
        setState(587);
        match(VHDLParser::END);
        setState(589);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::ARCHITECTURE)
        {
            setState(588);
            match(VHDLParser::ARCHITECTURE);
        }
        setState(592);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(591);
            identifier();
        }
        setState(594);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Architecture_declarative_partContext
//------------------------------------------------------------------

VHDLParser::Architecture_declarative_partContext::Architecture_declarative_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Block_declarative_itemContext *> VHDLParser::Architecture_declarative_partContext::block_declarative_item()
{
    return getRuleContexts<VHDLParser::Block_declarative_itemContext>();
}

VHDLParser::Block_declarative_itemContext *VHDLParser::Architecture_declarative_partContext::block_declarative_item(size_t i)
{
    return getRuleContext<VHDLParser::Block_declarative_itemContext>(i);
}

size_t VHDLParser::Architecture_declarative_partContext::getRuleIndex() const
{
    return VHDLParser::RuleArchitecture_declarative_part;
}

void VHDLParser::Architecture_declarative_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterArchitecture_declarative_part(this);
}

void VHDLParser::Architecture_declarative_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitArchitecture_declarative_part(this);
}

std::any VHDLParser::Architecture_declarative_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitArchitecture_declarative_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Architecture_declarative_partContext *VHDLParser::architecture_declarative_part()
{
    Architecture_declarative_partContext *_localctx = _tracker.createInstance<Architecture_declarative_partContext>(_ctx, getState());
    enterRule(_localctx, 26, VHDLParser::RuleArchitecture_declarative_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(599);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 2269550383466528) != 0) || ((((_la - 68) & ~0x3fULL) == 0) && ((1ULL << (_la - 68)) & 210571231245) != 0))
        {
            setState(596);
            block_declarative_item();
            setState(601);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Architecture_statementContext
//------------------------------------------------------------------

VHDLParser::Architecture_statementContext::Architecture_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Block_statementContext *VHDLParser::Architecture_statementContext::block_statement()
{
    return getRuleContext<VHDLParser::Block_statementContext>(0);
}

VHDLParser::Process_statementContext *VHDLParser::Architecture_statementContext::process_statement()
{
    return getRuleContext<VHDLParser::Process_statementContext>(0);
}

VHDLParser::Concurrent_procedure_call_statementContext *VHDLParser::Architecture_statementContext::concurrent_procedure_call_statement()
{
    return getRuleContext<VHDLParser::Concurrent_procedure_call_statementContext>(0);
}

VHDLParser::Label_colonContext *VHDLParser::Architecture_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

VHDLParser::Concurrent_assertion_statementContext *VHDLParser::Architecture_statementContext::concurrent_assertion_statement()
{
    return getRuleContext<VHDLParser::Concurrent_assertion_statementContext>(0);
}

VHDLParser::Concurrent_signal_assignment_statementContext *VHDLParser::Architecture_statementContext::concurrent_signal_assignment_statement()
{
    return getRuleContext<VHDLParser::Concurrent_signal_assignment_statementContext>(0);
}

tree::TerminalNode *VHDLParser::Architecture_statementContext::POSTPONED()
{
    return getToken(VHDLParser::POSTPONED, 0);
}

VHDLParser::Component_instantiation_statementContext *VHDLParser::Architecture_statementContext::component_instantiation_statement()
{
    return getRuleContext<VHDLParser::Component_instantiation_statementContext>(0);
}

VHDLParser::Generate_statementContext *VHDLParser::Architecture_statementContext::generate_statement()
{
    return getRuleContext<VHDLParser::Generate_statementContext>(0);
}

VHDLParser::Concurrent_break_statementContext *VHDLParser::Architecture_statementContext::concurrent_break_statement()
{
    return getRuleContext<VHDLParser::Concurrent_break_statementContext>(0);
}

VHDLParser::Simultaneous_statementContext *VHDLParser::Architecture_statementContext::simultaneous_statement()
{
    return getRuleContext<VHDLParser::Simultaneous_statementContext>(0);
}

size_t VHDLParser::Architecture_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleArchitecture_statement;
}

void VHDLParser::Architecture_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterArchitecture_statement(this);
}

void VHDLParser::Architecture_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitArchitecture_statement(this);
}

std::any VHDLParser::Architecture_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitArchitecture_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Architecture_statementContext *VHDLParser::architecture_statement()
{
    Architecture_statementContext *_localctx = _tracker.createInstance<Architecture_statementContext>(_ctx, getState());
    enterRule(_localctx, 28, VHDLParser::RuleArchitecture_statement);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(623);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(602);
            block_statement();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(603);
            process_statement();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(605);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx))
            {
            case 1: {
                setState(604);
                label_colon();
                break;
            }

            default:
                break;
            }
            setState(607);
            concurrent_procedure_call_statement();
            break;
        }

        case 4: {
            enterOuterAlt(_localctx, 4);
            setState(609);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx))
            {
            case 1: {
                setState(608);
                label_colon();
                break;
            }

            default:
                break;
            }
            setState(611);
            concurrent_assertion_statement();
            break;
        }

        case 5: {
            enterOuterAlt(_localctx, 5);
            setState(613);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx))
            {
            case 1: {
                setState(612);
                label_colon();
                break;
            }

            default:
                break;
            }
            setState(616);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx))
            {
            case 1: {
                setState(615);
                match(VHDLParser::POSTPONED);
                break;
            }

            default:
                break;
            }
            setState(618);
            concurrent_signal_assignment_statement();
            break;
        }

        case 6: {
            enterOuterAlt(_localctx, 6);
            setState(619);
            component_instantiation_statement();
            break;
        }

        case 7: {
            enterOuterAlt(_localctx, 7);
            setState(620);
            generate_statement();
            break;
        }

        case 8: {
            enterOuterAlt(_localctx, 8);
            setState(621);
            concurrent_break_statement();
            break;
        }

        case 9: {
            enterOuterAlt(_localctx, 9);
            setState(622);
            simultaneous_statement();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Architecture_statement_partContext
//------------------------------------------------------------------

VHDLParser::Architecture_statement_partContext::Architecture_statement_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Architecture_statementContext *> VHDLParser::Architecture_statement_partContext::architecture_statement()
{
    return getRuleContexts<VHDLParser::Architecture_statementContext>();
}

VHDLParser::Architecture_statementContext *VHDLParser::Architecture_statement_partContext::architecture_statement(size_t i)
{
    return getRuleContext<VHDLParser::Architecture_statementContext>(i);
}

size_t VHDLParser::Architecture_statement_partContext::getRuleIndex() const
{
    return VHDLParser::RuleArchitecture_statement_part;
}

void VHDLParser::Architecture_statement_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterArchitecture_statement_part(this);
}

void VHDLParser::Architecture_statement_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitArchitecture_statement_part(this);
}

std::any VHDLParser::Architecture_statement_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitArchitecture_statement_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Architecture_statement_partContext *VHDLParser::architecture_statement_part()
{
    Architecture_statement_partContext *_localctx = _tracker.createInstance<Architecture_statement_partContext>(_ctx, getState());
    enterRule(_localctx, 30, VHDLParser::RuleArchitecture_statement_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(628);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 220676450460926978) != 0) || ((((_la - 66) & ~0x3fULL) == 0) && ((1ULL << (_la - 66)) & 3474740417772126219) != 0) ||
               ((((_la - 141) & ~0x3fULL) == 0) && ((1ULL << (_la - 141)) & 131457) != 0))
        {
            setState(625);
            architecture_statement();
            setState(630);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Array_nature_definitionContext
//------------------------------------------------------------------

VHDLParser::Array_nature_definitionContext::Array_nature_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Unconstrained_nature_definitionContext *VHDLParser::Array_nature_definitionContext::unconstrained_nature_definition()
{
    return getRuleContext<VHDLParser::Unconstrained_nature_definitionContext>(0);
}

VHDLParser::Constrained_nature_definitionContext *VHDLParser::Array_nature_definitionContext::constrained_nature_definition()
{
    return getRuleContext<VHDLParser::Constrained_nature_definitionContext>(0);
}

size_t VHDLParser::Array_nature_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleArray_nature_definition;
}

void VHDLParser::Array_nature_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterArray_nature_definition(this);
}

void VHDLParser::Array_nature_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitArray_nature_definition(this);
}

std::any VHDLParser::Array_nature_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitArray_nature_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Array_nature_definitionContext *VHDLParser::array_nature_definition()
{
    Array_nature_definitionContext *_localctx = _tracker.createInstance<Array_nature_definitionContext>(_ctx, getState());
    enterRule(_localctx, 32, VHDLParser::RuleArray_nature_definition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(633);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(631);
            unconstrained_nature_definition();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(632);
            constrained_nature_definition();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Array_type_definitionContext
//------------------------------------------------------------------

VHDLParser::Array_type_definitionContext::Array_type_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Unconstrained_array_definitionContext *VHDLParser::Array_type_definitionContext::unconstrained_array_definition()
{
    return getRuleContext<VHDLParser::Unconstrained_array_definitionContext>(0);
}

VHDLParser::Constrained_array_definitionContext *VHDLParser::Array_type_definitionContext::constrained_array_definition()
{
    return getRuleContext<VHDLParser::Constrained_array_definitionContext>(0);
}

size_t VHDLParser::Array_type_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleArray_type_definition;
}

void VHDLParser::Array_type_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterArray_type_definition(this);
}

void VHDLParser::Array_type_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitArray_type_definition(this);
}

std::any VHDLParser::Array_type_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitArray_type_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Array_type_definitionContext *VHDLParser::array_type_definition()
{
    Array_type_definitionContext *_localctx = _tracker.createInstance<Array_type_definitionContext>(_ctx, getState());
    enterRule(_localctx, 34, VHDLParser::RuleArray_type_definition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(637);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(635);
            unconstrained_array_definition();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(636);
            constrained_array_definition();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- AssertionContext
//------------------------------------------------------------------

VHDLParser::AssertionContext::AssertionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::AssertionContext::ASSERT()
{
    return getToken(VHDLParser::ASSERT, 0);
}

VHDLParser::ConditionContext *VHDLParser::AssertionContext::condition()
{
    return getRuleContext<VHDLParser::ConditionContext>(0);
}

tree::TerminalNode *VHDLParser::AssertionContext::REPORT()
{
    return getToken(VHDLParser::REPORT, 0);
}

std::vector<VHDLParser::ExpressionContext *> VHDLParser::AssertionContext::expression()
{
    return getRuleContexts<VHDLParser::ExpressionContext>();
}

VHDLParser::ExpressionContext *VHDLParser::AssertionContext::expression(size_t i)
{
    return getRuleContext<VHDLParser::ExpressionContext>(i);
}

tree::TerminalNode *VHDLParser::AssertionContext::SEVERITY()
{
    return getToken(VHDLParser::SEVERITY, 0);
}

size_t VHDLParser::AssertionContext::getRuleIndex() const
{
    return VHDLParser::RuleAssertion;
}

void VHDLParser::AssertionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAssertion(this);
}

void VHDLParser::AssertionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAssertion(this);
}

std::any VHDLParser::AssertionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAssertion(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::AssertionContext *VHDLParser::assertion()
{
    AssertionContext *_localctx = _tracker.createInstance<AssertionContext>(_ctx, getState());
    enterRule(_localctx, 36, VHDLParser::RuleAssertion);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(639);
        match(VHDLParser::ASSERT);
        setState(640);
        condition();
        setState(643);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::REPORT)
        {
            setState(641);
            match(VHDLParser::REPORT);
            setState(642);
            expression();
        }
        setState(647);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::SEVERITY)
        {
            setState(645);
            match(VHDLParser::SEVERITY);
            setState(646);
            expression();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Assertion_statementContext
//------------------------------------------------------------------

VHDLParser::Assertion_statementContext::Assertion_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::AssertionContext *VHDLParser::Assertion_statementContext::assertion()
{
    return getRuleContext<VHDLParser::AssertionContext>(0);
}

tree::TerminalNode *VHDLParser::Assertion_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Assertion_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

size_t VHDLParser::Assertion_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleAssertion_statement;
}

void VHDLParser::Assertion_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAssertion_statement(this);
}

void VHDLParser::Assertion_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAssertion_statement(this);
}

std::any VHDLParser::Assertion_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAssertion_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Assertion_statementContext *VHDLParser::assertion_statement()
{
    Assertion_statementContext *_localctx = _tracker.createInstance<Assertion_statementContext>(_ctx, getState());
    enterRule(_localctx, 38, VHDLParser::RuleAssertion_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(650);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(649);
            label_colon();
        }
        setState(652);
        assertion();
        setState(653);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Association_elementContext
//------------------------------------------------------------------

VHDLParser::Association_elementContext::Association_elementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Actual_partContext *VHDLParser::Association_elementContext::actual_part()
{
    return getRuleContext<VHDLParser::Actual_partContext>(0);
}

VHDLParser::Formal_partContext *VHDLParser::Association_elementContext::formal_part()
{
    return getRuleContext<VHDLParser::Formal_partContext>(0);
}

tree::TerminalNode *VHDLParser::Association_elementContext::ARROW()
{
    return getToken(VHDLParser::ARROW, 0);
}

size_t VHDLParser::Association_elementContext::getRuleIndex() const
{
    return VHDLParser::RuleAssociation_element;
}

void VHDLParser::Association_elementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAssociation_element(this);
}

void VHDLParser::Association_elementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAssociation_element(this);
}

std::any VHDLParser::Association_elementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAssociation_element(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Association_elementContext *VHDLParser::association_element()
{
    Association_elementContext *_localctx = _tracker.createInstance<Association_elementContext>(_ctx, getState());
    enterRule(_localctx, 40, VHDLParser::RuleAssociation_element);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(658);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx))
        {
        case 1: {
            setState(655);
            formal_part();
            setState(656);
            match(VHDLParser::ARROW);
            break;
        }

        default:
            break;
        }
        setState(660);
        actual_part();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Association_listContext
//------------------------------------------------------------------

VHDLParser::Association_listContext::Association_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Association_elementContext *> VHDLParser::Association_listContext::association_element()
{
    return getRuleContexts<VHDLParser::Association_elementContext>();
}

VHDLParser::Association_elementContext *VHDLParser::Association_listContext::association_element(size_t i)
{
    return getRuleContext<VHDLParser::Association_elementContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Association_listContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Association_listContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

size_t VHDLParser::Association_listContext::getRuleIndex() const
{
    return VHDLParser::RuleAssociation_list;
}

void VHDLParser::Association_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAssociation_list(this);
}

void VHDLParser::Association_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAssociation_list(this);
}

std::any VHDLParser::Association_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAssociation_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Association_listContext *VHDLParser::association_list()
{
    Association_listContext *_localctx = _tracker.createInstance<Association_listContext>(_ctx, getState());
    enterRule(_localctx, 42, VHDLParser::RuleAssociation_list);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(662);
        association_element();
        setState(667);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::COMMA)
        {
            setState(663);
            match(VHDLParser::COMMA);
            setState(664);
            association_element();
            setState(669);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Attribute_declarationContext
//------------------------------------------------------------------

VHDLParser::Attribute_declarationContext::Attribute_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Attribute_declarationContext::ATTRIBUTE()
{
    return getToken(VHDLParser::ATTRIBUTE, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Attribute_declarationContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

VHDLParser::NameContext *VHDLParser::Attribute_declarationContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

tree::TerminalNode *VHDLParser::Attribute_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Attribute_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleAttribute_declaration;
}

void VHDLParser::Attribute_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAttribute_declaration(this);
}

void VHDLParser::Attribute_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAttribute_declaration(this);
}

std::any VHDLParser::Attribute_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAttribute_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Attribute_declarationContext *VHDLParser::attribute_declaration()
{
    Attribute_declarationContext *_localctx = _tracker.createInstance<Attribute_declarationContext>(_ctx, getState());
    enterRule(_localctx, 44, VHDLParser::RuleAttribute_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(670);
        match(VHDLParser::ATTRIBUTE);
        setState(671);
        label_colon();
        setState(672);
        name();
        setState(673);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Attribute_designatorContext
//------------------------------------------------------------------

VHDLParser::Attribute_designatorContext::Attribute_designatorContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::IdentifierContext *VHDLParser::Attribute_designatorContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Attribute_designatorContext::RANGE()
{
    return getToken(VHDLParser::RANGE, 0);
}

tree::TerminalNode *VHDLParser::Attribute_designatorContext::REVERSE_RANGE()
{
    return getToken(VHDLParser::REVERSE_RANGE, 0);
}

tree::TerminalNode *VHDLParser::Attribute_designatorContext::ACROSS()
{
    return getToken(VHDLParser::ACROSS, 0);
}

tree::TerminalNode *VHDLParser::Attribute_designatorContext::THROUGH()
{
    return getToken(VHDLParser::THROUGH, 0);
}

tree::TerminalNode *VHDLParser::Attribute_designatorContext::REFERENCE()
{
    return getToken(VHDLParser::REFERENCE, 0);
}

tree::TerminalNode *VHDLParser::Attribute_designatorContext::TOLERANCE()
{
    return getToken(VHDLParser::TOLERANCE, 0);
}

size_t VHDLParser::Attribute_designatorContext::getRuleIndex() const
{
    return VHDLParser::RuleAttribute_designator;
}

void VHDLParser::Attribute_designatorContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAttribute_designator(this);
}

void VHDLParser::Attribute_designatorContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAttribute_designator(this);
}

std::any VHDLParser::Attribute_designatorContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAttribute_designator(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Attribute_designatorContext *VHDLParser::attribute_designator()
{
    Attribute_designatorContext *_localctx = _tracker.createInstance<Attribute_designatorContext>(_ctx, getState());
    enterRule(_localctx, 46, VHDLParser::RuleAttribute_designator);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(682);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER: {
            enterOuterAlt(_localctx, 1);
            setState(675);
            identifier();
            break;
        }

        case VHDLParser::RANGE: {
            enterOuterAlt(_localctx, 2);
            setState(676);
            match(VHDLParser::RANGE);
            break;
        }

        case VHDLParser::REVERSE_RANGE: {
            enterOuterAlt(_localctx, 3);
            setState(677);
            match(VHDLParser::REVERSE_RANGE);
            break;
        }

        case VHDLParser::ACROSS: {
            enterOuterAlt(_localctx, 4);
            setState(678);
            match(VHDLParser::ACROSS);
            break;
        }

        case VHDLParser::THROUGH: {
            enterOuterAlt(_localctx, 5);
            setState(679);
            match(VHDLParser::THROUGH);
            break;
        }

        case VHDLParser::REFERENCE: {
            enterOuterAlt(_localctx, 6);
            setState(680);
            match(VHDLParser::REFERENCE);
            break;
        }

        case VHDLParser::TOLERANCE: {
            enterOuterAlt(_localctx, 7);
            setState(681);
            match(VHDLParser::TOLERANCE);
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Attribute_specificationContext
//------------------------------------------------------------------

VHDLParser::Attribute_specificationContext::Attribute_specificationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Attribute_specificationContext::ATTRIBUTE()
{
    return getToken(VHDLParser::ATTRIBUTE, 0);
}

VHDLParser::Attribute_designatorContext *VHDLParser::Attribute_specificationContext::attribute_designator()
{
    return getRuleContext<VHDLParser::Attribute_designatorContext>(0);
}

tree::TerminalNode *VHDLParser::Attribute_specificationContext::OF()
{
    return getToken(VHDLParser::OF, 0);
}

VHDLParser::Entity_specificationContext *VHDLParser::Attribute_specificationContext::entity_specification()
{
    return getRuleContext<VHDLParser::Entity_specificationContext>(0);
}

tree::TerminalNode *VHDLParser::Attribute_specificationContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Attribute_specificationContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

tree::TerminalNode *VHDLParser::Attribute_specificationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Attribute_specificationContext::getRuleIndex() const
{
    return VHDLParser::RuleAttribute_specification;
}

void VHDLParser::Attribute_specificationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAttribute_specification(this);
}

void VHDLParser::Attribute_specificationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAttribute_specification(this);
}

std::any VHDLParser::Attribute_specificationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAttribute_specification(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Attribute_specificationContext *VHDLParser::attribute_specification()
{
    Attribute_specificationContext *_localctx = _tracker.createInstance<Attribute_specificationContext>(_ctx, getState());
    enterRule(_localctx, 48, VHDLParser::RuleAttribute_specification);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(684);
        match(VHDLParser::ATTRIBUTE);
        setState(685);
        attribute_designator();
        setState(686);
        match(VHDLParser::OF);
        setState(687);
        entity_specification();
        setState(688);
        match(VHDLParser::IS);
        setState(689);
        expression();
        setState(690);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Base_unit_declarationContext
//------------------------------------------------------------------

VHDLParser::Base_unit_declarationContext::Base_unit_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::IdentifierContext *VHDLParser::Base_unit_declarationContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Base_unit_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Base_unit_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleBase_unit_declaration;
}

void VHDLParser::Base_unit_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterBase_unit_declaration(this);
}

void VHDLParser::Base_unit_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitBase_unit_declaration(this);
}

std::any VHDLParser::Base_unit_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitBase_unit_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Base_unit_declarationContext *VHDLParser::base_unit_declaration()
{
    Base_unit_declarationContext *_localctx = _tracker.createInstance<Base_unit_declarationContext>(_ctx, getState());
    enterRule(_localctx, 50, VHDLParser::RuleBase_unit_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(692);
        identifier();
        setState(693);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Binding_indicationContext
//------------------------------------------------------------------

VHDLParser::Binding_indicationContext::Binding_indicationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Binding_indicationContext::USE()
{
    return getToken(VHDLParser::USE, 0);
}

VHDLParser::Entity_aspectContext *VHDLParser::Binding_indicationContext::entity_aspect()
{
    return getRuleContext<VHDLParser::Entity_aspectContext>(0);
}

VHDLParser::Generic_map_aspectContext *VHDLParser::Binding_indicationContext::generic_map_aspect()
{
    return getRuleContext<VHDLParser::Generic_map_aspectContext>(0);
}

VHDLParser::Port_map_aspectContext *VHDLParser::Binding_indicationContext::port_map_aspect()
{
    return getRuleContext<VHDLParser::Port_map_aspectContext>(0);
}

size_t VHDLParser::Binding_indicationContext::getRuleIndex() const
{
    return VHDLParser::RuleBinding_indication;
}

void VHDLParser::Binding_indicationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterBinding_indication(this);
}

void VHDLParser::Binding_indicationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitBinding_indication(this);
}

std::any VHDLParser::Binding_indicationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitBinding_indication(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Binding_indicationContext *VHDLParser::binding_indication()
{
    Binding_indicationContext *_localctx = _tracker.createInstance<Binding_indicationContext>(_ctx, getState());
    enterRule(_localctx, 52, VHDLParser::RuleBinding_indication);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(697);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::USE)
        {
            setState(695);
            match(VHDLParser::USE);
            setState(696);
            entity_aspect();
        }
        setState(700);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::GENERIC)
        {
            setState(699);
            generic_map_aspect();
        }
        setState(703);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::PORT)
        {
            setState(702);
            port_map_aspect();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Block_configurationContext
//------------------------------------------------------------------

VHDLParser::Block_configurationContext::Block_configurationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::Block_configurationContext::FOR()
{
    return getTokens(VHDLParser::FOR);
}

tree::TerminalNode *VHDLParser::Block_configurationContext::FOR(size_t i)
{
    return getToken(VHDLParser::FOR, i);
}

VHDLParser::Block_specificationContext *VHDLParser::Block_configurationContext::block_specification()
{
    return getRuleContext<VHDLParser::Block_specificationContext>(0);
}

tree::TerminalNode *VHDLParser::Block_configurationContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::Block_configurationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

std::vector<VHDLParser::Use_clauseContext *> VHDLParser::Block_configurationContext::use_clause()
{
    return getRuleContexts<VHDLParser::Use_clauseContext>();
}

VHDLParser::Use_clauseContext *VHDLParser::Block_configurationContext::use_clause(size_t i)
{
    return getRuleContext<VHDLParser::Use_clauseContext>(i);
}

std::vector<VHDLParser::Configuration_itemContext *> VHDLParser::Block_configurationContext::configuration_item()
{
    return getRuleContexts<VHDLParser::Configuration_itemContext>();
}

VHDLParser::Configuration_itemContext *VHDLParser::Block_configurationContext::configuration_item(size_t i)
{
    return getRuleContext<VHDLParser::Configuration_itemContext>(i);
}

size_t VHDLParser::Block_configurationContext::getRuleIndex() const
{
    return VHDLParser::RuleBlock_configuration;
}

void VHDLParser::Block_configurationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterBlock_configuration(this);
}

void VHDLParser::Block_configurationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitBlock_configuration(this);
}

std::any VHDLParser::Block_configurationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitBlock_configuration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Block_configurationContext *VHDLParser::block_configuration()
{
    Block_configurationContext *_localctx = _tracker.createInstance<Block_configurationContext>(_ctx, getState());
    enterRule(_localctx, 54, VHDLParser::RuleBlock_configuration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(705);
        match(VHDLParser::FOR);
        setState(706);
        block_specification();
        setState(710);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::USE)
        {
            setState(707);
            use_clause();
            setState(712);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(716);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::FOR)
        {
            setState(713);
            configuration_item();
            setState(718);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(719);
        match(VHDLParser::END);
        setState(720);
        match(VHDLParser::FOR);
        setState(721);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Block_declarative_itemContext
//------------------------------------------------------------------

VHDLParser::Block_declarative_itemContext::Block_declarative_itemContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Subprogram_declarationContext *VHDLParser::Block_declarative_itemContext::subprogram_declaration()
{
    return getRuleContext<VHDLParser::Subprogram_declarationContext>(0);
}

VHDLParser::Subprogram_bodyContext *VHDLParser::Block_declarative_itemContext::subprogram_body()
{
    return getRuleContext<VHDLParser::Subprogram_bodyContext>(0);
}

VHDLParser::Type_declarationContext *VHDLParser::Block_declarative_itemContext::type_declaration()
{
    return getRuleContext<VHDLParser::Type_declarationContext>(0);
}

VHDLParser::Subtype_declarationContext *VHDLParser::Block_declarative_itemContext::subtype_declaration()
{
    return getRuleContext<VHDLParser::Subtype_declarationContext>(0);
}

VHDLParser::Constant_declarationContext *VHDLParser::Block_declarative_itemContext::constant_declaration()
{
    return getRuleContext<VHDLParser::Constant_declarationContext>(0);
}

VHDLParser::Signal_declarationContext *VHDLParser::Block_declarative_itemContext::signal_declaration()
{
    return getRuleContext<VHDLParser::Signal_declarationContext>(0);
}

VHDLParser::Variable_declarationContext *VHDLParser::Block_declarative_itemContext::variable_declaration()
{
    return getRuleContext<VHDLParser::Variable_declarationContext>(0);
}

VHDLParser::File_declarationContext *VHDLParser::Block_declarative_itemContext::file_declaration()
{
    return getRuleContext<VHDLParser::File_declarationContext>(0);
}

VHDLParser::Alias_declarationContext *VHDLParser::Block_declarative_itemContext::alias_declaration()
{
    return getRuleContext<VHDLParser::Alias_declarationContext>(0);
}

VHDLParser::Component_declarationContext *VHDLParser::Block_declarative_itemContext::component_declaration()
{
    return getRuleContext<VHDLParser::Component_declarationContext>(0);
}

VHDLParser::Attribute_declarationContext *VHDLParser::Block_declarative_itemContext::attribute_declaration()
{
    return getRuleContext<VHDLParser::Attribute_declarationContext>(0);
}

VHDLParser::Attribute_specificationContext *VHDLParser::Block_declarative_itemContext::attribute_specification()
{
    return getRuleContext<VHDLParser::Attribute_specificationContext>(0);
}

VHDLParser::Configuration_specificationContext *VHDLParser::Block_declarative_itemContext::configuration_specification()
{
    return getRuleContext<VHDLParser::Configuration_specificationContext>(0);
}

VHDLParser::Disconnection_specificationContext *VHDLParser::Block_declarative_itemContext::disconnection_specification()
{
    return getRuleContext<VHDLParser::Disconnection_specificationContext>(0);
}

VHDLParser::Step_limit_specificationContext *VHDLParser::Block_declarative_itemContext::step_limit_specification()
{
    return getRuleContext<VHDLParser::Step_limit_specificationContext>(0);
}

VHDLParser::Use_clauseContext *VHDLParser::Block_declarative_itemContext::use_clause()
{
    return getRuleContext<VHDLParser::Use_clauseContext>(0);
}

VHDLParser::Group_template_declarationContext *VHDLParser::Block_declarative_itemContext::group_template_declaration()
{
    return getRuleContext<VHDLParser::Group_template_declarationContext>(0);
}

VHDLParser::Group_declarationContext *VHDLParser::Block_declarative_itemContext::group_declaration()
{
    return getRuleContext<VHDLParser::Group_declarationContext>(0);
}

VHDLParser::Nature_declarationContext *VHDLParser::Block_declarative_itemContext::nature_declaration()
{
    return getRuleContext<VHDLParser::Nature_declarationContext>(0);
}

VHDLParser::Subnature_declarationContext *VHDLParser::Block_declarative_itemContext::subnature_declaration()
{
    return getRuleContext<VHDLParser::Subnature_declarationContext>(0);
}

VHDLParser::Quantity_declarationContext *VHDLParser::Block_declarative_itemContext::quantity_declaration()
{
    return getRuleContext<VHDLParser::Quantity_declarationContext>(0);
}

VHDLParser::Terminal_declarationContext *VHDLParser::Block_declarative_itemContext::terminal_declaration()
{
    return getRuleContext<VHDLParser::Terminal_declarationContext>(0);
}

size_t VHDLParser::Block_declarative_itemContext::getRuleIndex() const
{
    return VHDLParser::RuleBlock_declarative_item;
}

void VHDLParser::Block_declarative_itemContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterBlock_declarative_item(this);
}

void VHDLParser::Block_declarative_itemContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitBlock_declarative_item(this);
}

std::any VHDLParser::Block_declarative_itemContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitBlock_declarative_item(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Block_declarative_itemContext *VHDLParser::block_declarative_item()
{
    Block_declarative_itemContext *_localctx = _tracker.createInstance<Block_declarative_itemContext>(_ctx, getState());
    enterRule(_localctx, 56, VHDLParser::RuleBlock_declarative_item);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(745);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(723);
            subprogram_declaration();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(724);
            subprogram_body();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(725);
            type_declaration();
            break;
        }

        case 4: {
            enterOuterAlt(_localctx, 4);
            setState(726);
            subtype_declaration();
            break;
        }

        case 5: {
            enterOuterAlt(_localctx, 5);
            setState(727);
            constant_declaration();
            break;
        }

        case 6: {
            enterOuterAlt(_localctx, 6);
            setState(728);
            signal_declaration();
            break;
        }

        case 7: {
            enterOuterAlt(_localctx, 7);
            setState(729);
            variable_declaration();
            break;
        }

        case 8: {
            enterOuterAlt(_localctx, 8);
            setState(730);
            file_declaration();
            break;
        }

        case 9: {
            enterOuterAlt(_localctx, 9);
            setState(731);
            alias_declaration();
            break;
        }

        case 10: {
            enterOuterAlt(_localctx, 10);
            setState(732);
            component_declaration();
            break;
        }

        case 11: {
            enterOuterAlt(_localctx, 11);
            setState(733);
            attribute_declaration();
            break;
        }

        case 12: {
            enterOuterAlt(_localctx, 12);
            setState(734);
            attribute_specification();
            break;
        }

        case 13: {
            enterOuterAlt(_localctx, 13);
            setState(735);
            configuration_specification();
            break;
        }

        case 14: {
            enterOuterAlt(_localctx, 14);
            setState(736);
            disconnection_specification();
            break;
        }

        case 15: {
            enterOuterAlt(_localctx, 15);
            setState(737);
            step_limit_specification();
            break;
        }

        case 16: {
            enterOuterAlt(_localctx, 16);
            setState(738);
            use_clause();
            break;
        }

        case 17: {
            enterOuterAlt(_localctx, 17);
            setState(739);
            group_template_declaration();
            break;
        }

        case 18: {
            enterOuterAlt(_localctx, 18);
            setState(740);
            group_declaration();
            break;
        }

        case 19: {
            enterOuterAlt(_localctx, 19);
            setState(741);
            nature_declaration();
            break;
        }

        case 20: {
            enterOuterAlt(_localctx, 20);
            setState(742);
            subnature_declaration();
            break;
        }

        case 21: {
            enterOuterAlt(_localctx, 21);
            setState(743);
            quantity_declaration();
            break;
        }

        case 22: {
            enterOuterAlt(_localctx, 22);
            setState(744);
            terminal_declaration();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Block_declarative_partContext
//------------------------------------------------------------------

VHDLParser::Block_declarative_partContext::Block_declarative_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Block_declarative_itemContext *> VHDLParser::Block_declarative_partContext::block_declarative_item()
{
    return getRuleContexts<VHDLParser::Block_declarative_itemContext>();
}

VHDLParser::Block_declarative_itemContext *VHDLParser::Block_declarative_partContext::block_declarative_item(size_t i)
{
    return getRuleContext<VHDLParser::Block_declarative_itemContext>(i);
}

size_t VHDLParser::Block_declarative_partContext::getRuleIndex() const
{
    return VHDLParser::RuleBlock_declarative_part;
}

void VHDLParser::Block_declarative_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterBlock_declarative_part(this);
}

void VHDLParser::Block_declarative_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitBlock_declarative_part(this);
}

std::any VHDLParser::Block_declarative_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitBlock_declarative_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Block_declarative_partContext *VHDLParser::block_declarative_part()
{
    Block_declarative_partContext *_localctx = _tracker.createInstance<Block_declarative_partContext>(_ctx, getState());
    enterRule(_localctx, 58, VHDLParser::RuleBlock_declarative_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(750);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 2269550383466528) != 0) || ((((_la - 68) & ~0x3fULL) == 0) && ((1ULL << (_la - 68)) & 210571231245) != 0))
        {
            setState(747);
            block_declarative_item();
            setState(752);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Block_headerContext
//------------------------------------------------------------------

VHDLParser::Block_headerContext::Block_headerContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Generic_clauseContext *VHDLParser::Block_headerContext::generic_clause()
{
    return getRuleContext<VHDLParser::Generic_clauseContext>(0);
}

VHDLParser::Port_clauseContext *VHDLParser::Block_headerContext::port_clause()
{
    return getRuleContext<VHDLParser::Port_clauseContext>(0);
}

VHDLParser::Generic_map_aspectContext *VHDLParser::Block_headerContext::generic_map_aspect()
{
    return getRuleContext<VHDLParser::Generic_map_aspectContext>(0);
}

std::vector<tree::TerminalNode *> VHDLParser::Block_headerContext::SEMI()
{
    return getTokens(VHDLParser::SEMI);
}

tree::TerminalNode *VHDLParser::Block_headerContext::SEMI(size_t i)
{
    return getToken(VHDLParser::SEMI, i);
}

VHDLParser::Port_map_aspectContext *VHDLParser::Block_headerContext::port_map_aspect()
{
    return getRuleContext<VHDLParser::Port_map_aspectContext>(0);
}

size_t VHDLParser::Block_headerContext::getRuleIndex() const
{
    return VHDLParser::RuleBlock_header;
}

void VHDLParser::Block_headerContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterBlock_header(this);
}

void VHDLParser::Block_headerContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitBlock_header(this);
}

std::any VHDLParser::Block_headerContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitBlock_header(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Block_headerContext *VHDLParser::block_header()
{
    Block_headerContext *_localctx = _tracker.createInstance<Block_headerContext>(_ctx, getState());
    enterRule(_localctx, 60, VHDLParser::RuleBlock_header);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(759);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::GENERIC)
        {
            setState(753);
            generic_clause();
            setState(757);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == VHDLParser::GENERIC)
            {
                setState(754);
                generic_map_aspect();
                setState(755);
                match(VHDLParser::SEMI);
            }
        }
        setState(767);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::PORT)
        {
            setState(761);
            port_clause();
            setState(765);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == VHDLParser::PORT)
            {
                setState(762);
                port_map_aspect();
                setState(763);
                match(VHDLParser::SEMI);
            }
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Block_specificationContext
//------------------------------------------------------------------

VHDLParser::Block_specificationContext::Block_specificationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::IdentifierContext *VHDLParser::Block_specificationContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Block_specificationContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::Index_specificationContext *VHDLParser::Block_specificationContext::index_specification()
{
    return getRuleContext<VHDLParser::Index_specificationContext>(0);
}

tree::TerminalNode *VHDLParser::Block_specificationContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

VHDLParser::NameContext *VHDLParser::Block_specificationContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

size_t VHDLParser::Block_specificationContext::getRuleIndex() const
{
    return VHDLParser::RuleBlock_specification;
}

void VHDLParser::Block_specificationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterBlock_specification(this);
}

void VHDLParser::Block_specificationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitBlock_specification(this);
}

std::any VHDLParser::Block_specificationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitBlock_specification(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Block_specificationContext *VHDLParser::block_specification()
{
    Block_specificationContext *_localctx = _tracker.createInstance<Block_specificationContext>(_ctx, getState());
    enterRule(_localctx, 62, VHDLParser::RuleBlock_specification);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(777);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(769);
            identifier();
            setState(774);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == VHDLParser::LPAREN)
            {
                setState(770);
                match(VHDLParser::LPAREN);
                setState(771);
                index_specification();
                setState(772);
                match(VHDLParser::RPAREN);
            }
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(776);
            name();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Block_statementContext
//------------------------------------------------------------------

VHDLParser::Block_statementContext::Block_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Label_colonContext *VHDLParser::Block_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

std::vector<tree::TerminalNode *> VHDLParser::Block_statementContext::BLOCK()
{
    return getTokens(VHDLParser::BLOCK);
}

tree::TerminalNode *VHDLParser::Block_statementContext::BLOCK(size_t i)
{
    return getToken(VHDLParser::BLOCK, i);
}

VHDLParser::Block_headerContext *VHDLParser::Block_statementContext::block_header()
{
    return getRuleContext<VHDLParser::Block_headerContext>(0);
}

VHDLParser::Block_declarative_partContext *VHDLParser::Block_statementContext::block_declarative_part()
{
    return getRuleContext<VHDLParser::Block_declarative_partContext>(0);
}

tree::TerminalNode *VHDLParser::Block_statementContext::BEGIN()
{
    return getToken(VHDLParser::BEGIN, 0);
}

VHDLParser::Block_statement_partContext *VHDLParser::Block_statementContext::block_statement_part()
{
    return getRuleContext<VHDLParser::Block_statement_partContext>(0);
}

tree::TerminalNode *VHDLParser::Block_statementContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::Block_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

tree::TerminalNode *VHDLParser::Block_statementContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Block_statementContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

tree::TerminalNode *VHDLParser::Block_statementContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

tree::TerminalNode *VHDLParser::Block_statementContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::IdentifierContext *VHDLParser::Block_statementContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

size_t VHDLParser::Block_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleBlock_statement;
}

void VHDLParser::Block_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterBlock_statement(this);
}

void VHDLParser::Block_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitBlock_statement(this);
}

std::any VHDLParser::Block_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitBlock_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Block_statementContext *VHDLParser::block_statement()
{
    Block_statementContext *_localctx = _tracker.createInstance<Block_statementContext>(_ctx, getState());
    enterRule(_localctx, 64, VHDLParser::RuleBlock_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(779);
        label_colon();
        setState(780);
        match(VHDLParser::BLOCK);
        setState(785);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::LPAREN)
        {
            setState(781);
            match(VHDLParser::LPAREN);
            setState(782);
            expression();
            setState(783);
            match(VHDLParser::RPAREN);
        }
        setState(788);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::IS)
        {
            setState(787);
            match(VHDLParser::IS);
        }
        setState(790);
        block_header();
        setState(791);
        block_declarative_part();
        setState(792);
        match(VHDLParser::BEGIN);
        setState(793);
        block_statement_part();
        setState(794);
        match(VHDLParser::END);
        setState(795);
        match(VHDLParser::BLOCK);
        setState(797);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(796);
            identifier();
        }
        setState(799);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Block_statement_partContext
//------------------------------------------------------------------

VHDLParser::Block_statement_partContext::Block_statement_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Architecture_statementContext *> VHDLParser::Block_statement_partContext::architecture_statement()
{
    return getRuleContexts<VHDLParser::Architecture_statementContext>();
}

VHDLParser::Architecture_statementContext *VHDLParser::Block_statement_partContext::architecture_statement(size_t i)
{
    return getRuleContext<VHDLParser::Architecture_statementContext>(i);
}

size_t VHDLParser::Block_statement_partContext::getRuleIndex() const
{
    return VHDLParser::RuleBlock_statement_part;
}

void VHDLParser::Block_statement_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterBlock_statement_part(this);
}

void VHDLParser::Block_statement_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitBlock_statement_part(this);
}

std::any VHDLParser::Block_statement_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitBlock_statement_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Block_statement_partContext *VHDLParser::block_statement_part()
{
    Block_statement_partContext *_localctx = _tracker.createInstance<Block_statement_partContext>(_ctx, getState());
    enterRule(_localctx, 66, VHDLParser::RuleBlock_statement_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(804);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 220676450460926978) != 0) || ((((_la - 66) & ~0x3fULL) == 0) && ((1ULL << (_la - 66)) & 3474740417772126219) != 0) ||
               ((((_la - 141) & ~0x3fULL) == 0) && ((1ULL << (_la - 141)) & 131457) != 0))
        {
            setState(801);
            architecture_statement();
            setState(806);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Branch_quantity_declarationContext
//------------------------------------------------------------------

VHDLParser::Branch_quantity_declarationContext::Branch_quantity_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Branch_quantity_declarationContext::QUANTITY()
{
    return getToken(VHDLParser::QUANTITY, 0);
}

VHDLParser::Terminal_aspectContext *VHDLParser::Branch_quantity_declarationContext::terminal_aspect()
{
    return getRuleContext<VHDLParser::Terminal_aspectContext>(0);
}

tree::TerminalNode *VHDLParser::Branch_quantity_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Across_aspectContext *VHDLParser::Branch_quantity_declarationContext::across_aspect()
{
    return getRuleContext<VHDLParser::Across_aspectContext>(0);
}

VHDLParser::Through_aspectContext *VHDLParser::Branch_quantity_declarationContext::through_aspect()
{
    return getRuleContext<VHDLParser::Through_aspectContext>(0);
}

size_t VHDLParser::Branch_quantity_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleBranch_quantity_declaration;
}

void VHDLParser::Branch_quantity_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterBranch_quantity_declaration(this);
}

void VHDLParser::Branch_quantity_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitBranch_quantity_declaration(this);
}

std::any VHDLParser::Branch_quantity_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitBranch_quantity_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Branch_quantity_declarationContext *VHDLParser::branch_quantity_declaration()
{
    Branch_quantity_declarationContext *_localctx = _tracker.createInstance<Branch_quantity_declarationContext>(_ctx, getState());
    enterRule(_localctx, 68, VHDLParser::RuleBranch_quantity_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(807);
        match(VHDLParser::QUANTITY);
        setState(809);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx))
        {
        case 1: {
            setState(808);
            across_aspect();
            break;
        }

        default:
            break;
        }
        setState(812);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx))
        {
        case 1: {
            setState(811);
            through_aspect();
            break;
        }

        default:
            break;
        }
        setState(814);
        terminal_aspect();
        setState(815);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Break_elementContext
//------------------------------------------------------------------

VHDLParser::Break_elementContext::Break_elementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::NameContext *VHDLParser::Break_elementContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

tree::TerminalNode *VHDLParser::Break_elementContext::ARROW()
{
    return getToken(VHDLParser::ARROW, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Break_elementContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

VHDLParser::Break_selector_clauseContext *VHDLParser::Break_elementContext::break_selector_clause()
{
    return getRuleContext<VHDLParser::Break_selector_clauseContext>(0);
}

size_t VHDLParser::Break_elementContext::getRuleIndex() const
{
    return VHDLParser::RuleBreak_element;
}

void VHDLParser::Break_elementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterBreak_element(this);
}

void VHDLParser::Break_elementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitBreak_element(this);
}

std::any VHDLParser::Break_elementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitBreak_element(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Break_elementContext *VHDLParser::break_element()
{
    Break_elementContext *_localctx = _tracker.createInstance<Break_elementContext>(_ctx, getState());
    enterRule(_localctx, 70, VHDLParser::RuleBreak_element);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(818);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::FOR)
        {
            setState(817);
            break_selector_clause();
        }
        setState(820);
        name();
        setState(821);
        match(VHDLParser::ARROW);
        setState(822);
        expression();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Break_listContext
//------------------------------------------------------------------

VHDLParser::Break_listContext::Break_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Break_elementContext *> VHDLParser::Break_listContext::break_element()
{
    return getRuleContexts<VHDLParser::Break_elementContext>();
}

VHDLParser::Break_elementContext *VHDLParser::Break_listContext::break_element(size_t i)
{
    return getRuleContext<VHDLParser::Break_elementContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Break_listContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Break_listContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

size_t VHDLParser::Break_listContext::getRuleIndex() const
{
    return VHDLParser::RuleBreak_list;
}

void VHDLParser::Break_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterBreak_list(this);
}

void VHDLParser::Break_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitBreak_list(this);
}

std::any VHDLParser::Break_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitBreak_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Break_listContext *VHDLParser::break_list()
{
    Break_listContext *_localctx = _tracker.createInstance<Break_listContext>(_ctx, getState());
    enterRule(_localctx, 72, VHDLParser::RuleBreak_list);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(824);
        break_element();
        setState(829);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::COMMA)
        {
            setState(825);
            match(VHDLParser::COMMA);
            setState(826);
            break_element();
            setState(831);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Break_selector_clauseContext
//------------------------------------------------------------------

VHDLParser::Break_selector_clauseContext::Break_selector_clauseContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Break_selector_clauseContext::FOR()
{
    return getToken(VHDLParser::FOR, 0);
}

VHDLParser::NameContext *VHDLParser::Break_selector_clauseContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

tree::TerminalNode *VHDLParser::Break_selector_clauseContext::USE()
{
    return getToken(VHDLParser::USE, 0);
}

size_t VHDLParser::Break_selector_clauseContext::getRuleIndex() const
{
    return VHDLParser::RuleBreak_selector_clause;
}

void VHDLParser::Break_selector_clauseContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterBreak_selector_clause(this);
}

void VHDLParser::Break_selector_clauseContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitBreak_selector_clause(this);
}

std::any VHDLParser::Break_selector_clauseContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitBreak_selector_clause(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Break_selector_clauseContext *VHDLParser::break_selector_clause()
{
    Break_selector_clauseContext *_localctx = _tracker.createInstance<Break_selector_clauseContext>(_ctx, getState());
    enterRule(_localctx, 74, VHDLParser::RuleBreak_selector_clause);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(832);
        match(VHDLParser::FOR);
        setState(833);
        name();
        setState(834);
        match(VHDLParser::USE);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Break_statementContext
//------------------------------------------------------------------

VHDLParser::Break_statementContext::Break_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Break_statementContext::BREAK()
{
    return getToken(VHDLParser::BREAK, 0);
}

tree::TerminalNode *VHDLParser::Break_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Break_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

VHDLParser::Break_listContext *VHDLParser::Break_statementContext::break_list()
{
    return getRuleContext<VHDLParser::Break_listContext>(0);
}

tree::TerminalNode *VHDLParser::Break_statementContext::WHEN()
{
    return getToken(VHDLParser::WHEN, 0);
}

VHDLParser::ConditionContext *VHDLParser::Break_statementContext::condition()
{
    return getRuleContext<VHDLParser::ConditionContext>(0);
}

size_t VHDLParser::Break_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleBreak_statement;
}

void VHDLParser::Break_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterBreak_statement(this);
}

void VHDLParser::Break_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitBreak_statement(this);
}

std::any VHDLParser::Break_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitBreak_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Break_statementContext *VHDLParser::break_statement()
{
    Break_statementContext *_localctx = _tracker.createInstance<Break_statementContext>(_ctx, getState());
    enterRule(_localctx, 76, VHDLParser::RuleBreak_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(837);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(836);
            label_colon();
        }
        setState(839);
        match(VHDLParser::BREAK);
        setState(841);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::FOR || ((((_la - 118) & ~0x3fULL) == 0) && ((1ULL << (_la - 118)) & 515) != 0))
        {
            setState(840);
            break_list();
        }
        setState(845);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::WHEN)
        {
            setState(843);
            match(VHDLParser::WHEN);
            setState(844);
            condition();
        }
        setState(847);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Case_statementContext
//------------------------------------------------------------------

VHDLParser::Case_statementContext::Case_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::Case_statementContext::CASE()
{
    return getTokens(VHDLParser::CASE);
}

tree::TerminalNode *VHDLParser::Case_statementContext::CASE(size_t i)
{
    return getToken(VHDLParser::CASE, i);
}

VHDLParser::ExpressionContext *VHDLParser::Case_statementContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

tree::TerminalNode *VHDLParser::Case_statementContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

tree::TerminalNode *VHDLParser::Case_statementContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::Case_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Case_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

std::vector<VHDLParser::Case_statement_alternativeContext *> VHDLParser::Case_statementContext::case_statement_alternative()
{
    return getRuleContexts<VHDLParser::Case_statement_alternativeContext>();
}

VHDLParser::Case_statement_alternativeContext *VHDLParser::Case_statementContext::case_statement_alternative(size_t i)
{
    return getRuleContext<VHDLParser::Case_statement_alternativeContext>(i);
}

VHDLParser::IdentifierContext *VHDLParser::Case_statementContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

size_t VHDLParser::Case_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleCase_statement;
}

void VHDLParser::Case_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterCase_statement(this);
}

void VHDLParser::Case_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitCase_statement(this);
}

std::any VHDLParser::Case_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitCase_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Case_statementContext *VHDLParser::case_statement()
{
    Case_statementContext *_localctx = _tracker.createInstance<Case_statementContext>(_ctx, getState());
    enterRule(_localctx, 78, VHDLParser::RuleCase_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(850);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(849);
            label_colon();
        }
        setState(852);
        match(VHDLParser::CASE);
        setState(853);
        expression();
        setState(854);
        match(VHDLParser::IS);
        setState(856);
        _errHandler->sync(this);
        _la = _input->LA(1);
        do
        {
            setState(855);
            case_statement_alternative();
            setState(858);
            _errHandler->sync(this);
            _la = _input->LA(1);
        } while (_la == VHDLParser::WHEN);
        setState(860);
        match(VHDLParser::END);
        setState(861);
        match(VHDLParser::CASE);
        setState(863);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(862);
            identifier();
        }
        setState(865);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Case_statement_alternativeContext
//------------------------------------------------------------------

VHDLParser::Case_statement_alternativeContext::Case_statement_alternativeContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Case_statement_alternativeContext::WHEN()
{
    return getToken(VHDLParser::WHEN, 0);
}

VHDLParser::ChoicesContext *VHDLParser::Case_statement_alternativeContext::choices()
{
    return getRuleContext<VHDLParser::ChoicesContext>(0);
}

tree::TerminalNode *VHDLParser::Case_statement_alternativeContext::ARROW()
{
    return getToken(VHDLParser::ARROW, 0);
}

VHDLParser::Sequence_of_statementsContext *VHDLParser::Case_statement_alternativeContext::sequence_of_statements()
{
    return getRuleContext<VHDLParser::Sequence_of_statementsContext>(0);
}

size_t VHDLParser::Case_statement_alternativeContext::getRuleIndex() const
{
    return VHDLParser::RuleCase_statement_alternative;
}

void VHDLParser::Case_statement_alternativeContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterCase_statement_alternative(this);
}

void VHDLParser::Case_statement_alternativeContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitCase_statement_alternative(this);
}

std::any VHDLParser::Case_statement_alternativeContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitCase_statement_alternative(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Case_statement_alternativeContext *VHDLParser::case_statement_alternative()
{
    Case_statement_alternativeContext *_localctx = _tracker.createInstance<Case_statement_alternativeContext>(_ctx, getState());
    enterRule(_localctx, 80, VHDLParser::RuleCase_statement_alternative);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(867);
        match(VHDLParser::WHEN);
        setState(868);
        choices();
        setState(869);
        match(VHDLParser::ARROW);
        setState(870);
        sequence_of_statements();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ChoiceContext
//------------------------------------------------------------------

VHDLParser::ChoiceContext::ChoiceContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::IdentifierContext *VHDLParser::ChoiceContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

VHDLParser::Discrete_rangeContext *VHDLParser::ChoiceContext::discrete_range()
{
    return getRuleContext<VHDLParser::Discrete_rangeContext>(0);
}

VHDLParser::Simple_expressionContext *VHDLParser::ChoiceContext::simple_expression()
{
    return getRuleContext<VHDLParser::Simple_expressionContext>(0);
}

tree::TerminalNode *VHDLParser::ChoiceContext::OTHERS()
{
    return getToken(VHDLParser::OTHERS, 0);
}

size_t VHDLParser::ChoiceContext::getRuleIndex() const
{
    return VHDLParser::RuleChoice;
}

void VHDLParser::ChoiceContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterChoice(this);
}

void VHDLParser::ChoiceContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitChoice(this);
}

std::any VHDLParser::ChoiceContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitChoice(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::ChoiceContext *VHDLParser::choice()
{
    ChoiceContext *_localctx = _tracker.createInstance<ChoiceContext>(_ctx, getState());
    enterRule(_localctx, 82, VHDLParser::RuleChoice);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(876);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(872);
            identifier();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(873);
            discrete_range();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(874);
            simple_expression();
            break;
        }

        case 4: {
            enterOuterAlt(_localctx, 4);
            setState(875);
            match(VHDLParser::OTHERS);
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ChoicesContext
//------------------------------------------------------------------

VHDLParser::ChoicesContext::ChoicesContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::ChoiceContext *> VHDLParser::ChoicesContext::choice()
{
    return getRuleContexts<VHDLParser::ChoiceContext>();
}

VHDLParser::ChoiceContext *VHDLParser::ChoicesContext::choice(size_t i)
{
    return getRuleContext<VHDLParser::ChoiceContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::ChoicesContext::BAR()
{
    return getTokens(VHDLParser::BAR);
}

tree::TerminalNode *VHDLParser::ChoicesContext::BAR(size_t i)
{
    return getToken(VHDLParser::BAR, i);
}

size_t VHDLParser::ChoicesContext::getRuleIndex() const
{
    return VHDLParser::RuleChoices;
}

void VHDLParser::ChoicesContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterChoices(this);
}

void VHDLParser::ChoicesContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitChoices(this);
}

std::any VHDLParser::ChoicesContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitChoices(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::ChoicesContext *VHDLParser::choices()
{
    ChoicesContext *_localctx = _tracker.createInstance<ChoicesContext>(_ctx, getState());
    enterRule(_localctx, 84, VHDLParser::RuleChoices);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(878);
        choice();
        setState(883);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::BAR)
        {
            setState(879);
            match(VHDLParser::BAR);
            setState(880);
            choice();
            setState(885);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Component_configurationContext
//------------------------------------------------------------------

VHDLParser::Component_configurationContext::Component_configurationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::Component_configurationContext::FOR()
{
    return getTokens(VHDLParser::FOR);
}

tree::TerminalNode *VHDLParser::Component_configurationContext::FOR(size_t i)
{
    return getToken(VHDLParser::FOR, i);
}

VHDLParser::Component_specificationContext *VHDLParser::Component_configurationContext::component_specification()
{
    return getRuleContext<VHDLParser::Component_specificationContext>(0);
}

tree::TerminalNode *VHDLParser::Component_configurationContext::END()
{
    return getToken(VHDLParser::END, 0);
}

std::vector<tree::TerminalNode *> VHDLParser::Component_configurationContext::SEMI()
{
    return getTokens(VHDLParser::SEMI);
}

tree::TerminalNode *VHDLParser::Component_configurationContext::SEMI(size_t i)
{
    return getToken(VHDLParser::SEMI, i);
}

VHDLParser::Binding_indicationContext *VHDLParser::Component_configurationContext::binding_indication()
{
    return getRuleContext<VHDLParser::Binding_indicationContext>(0);
}

VHDLParser::Block_configurationContext *VHDLParser::Component_configurationContext::block_configuration()
{
    return getRuleContext<VHDLParser::Block_configurationContext>(0);
}

size_t VHDLParser::Component_configurationContext::getRuleIndex() const
{
    return VHDLParser::RuleComponent_configuration;
}

void VHDLParser::Component_configurationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterComponent_configuration(this);
}

void VHDLParser::Component_configurationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitComponent_configuration(this);
}

std::any VHDLParser::Component_configurationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitComponent_configuration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Component_configurationContext *VHDLParser::component_configuration()
{
    Component_configurationContext *_localctx = _tracker.createInstance<Component_configurationContext>(_ctx, getState());
    enterRule(_localctx, 86, VHDLParser::RuleComponent_configuration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(886);
        match(VHDLParser::FOR);
        setState(887);
        component_specification();
        setState(891);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::GENERIC

            || _la == VHDLParser::PORT || _la == VHDLParser::USE

            || _la == VHDLParser::SEMI)
        {
            setState(888);
            binding_indication();
            setState(889);
            match(VHDLParser::SEMI);
        }
        setState(894);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::FOR)
        {
            setState(893);
            block_configuration();
        }
        setState(896);
        match(VHDLParser::END);
        setState(897);
        match(VHDLParser::FOR);
        setState(898);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Component_declarationContext
//------------------------------------------------------------------

VHDLParser::Component_declarationContext::Component_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::Component_declarationContext::COMPONENT()
{
    return getTokens(VHDLParser::COMPONENT);
}

tree::TerminalNode *VHDLParser::Component_declarationContext::COMPONENT(size_t i)
{
    return getToken(VHDLParser::COMPONENT, i);
}

std::vector<VHDLParser::IdentifierContext *> VHDLParser::Component_declarationContext::identifier()
{
    return getRuleContexts<VHDLParser::IdentifierContext>();
}

VHDLParser::IdentifierContext *VHDLParser::Component_declarationContext::identifier(size_t i)
{
    return getRuleContext<VHDLParser::IdentifierContext>(i);
}

tree::TerminalNode *VHDLParser::Component_declarationContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::Component_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

tree::TerminalNode *VHDLParser::Component_declarationContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::Generic_clauseContext *VHDLParser::Component_declarationContext::generic_clause()
{
    return getRuleContext<VHDLParser::Generic_clauseContext>(0);
}

VHDLParser::Port_clauseContext *VHDLParser::Component_declarationContext::port_clause()
{
    return getRuleContext<VHDLParser::Port_clauseContext>(0);
}

size_t VHDLParser::Component_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleComponent_declaration;
}

void VHDLParser::Component_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterComponent_declaration(this);
}

void VHDLParser::Component_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitComponent_declaration(this);
}

std::any VHDLParser::Component_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitComponent_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Component_declarationContext *VHDLParser::component_declaration()
{
    Component_declarationContext *_localctx = _tracker.createInstance<Component_declarationContext>(_ctx, getState());
    enterRule(_localctx, 88, VHDLParser::RuleComponent_declaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(900);
        match(VHDLParser::COMPONENT);
        setState(901);
        identifier();
        setState(903);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::IS)
        {
            setState(902);
            match(VHDLParser::IS);
        }
        setState(906);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::GENERIC)
        {
            setState(905);
            generic_clause();
        }
        setState(909);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::PORT)
        {
            setState(908);
            port_clause();
        }
        setState(911);
        match(VHDLParser::END);
        setState(912);
        match(VHDLParser::COMPONENT);
        setState(914);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(913);
            identifier();
        }
        setState(916);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Component_instantiation_statementContext
//------------------------------------------------------------------

VHDLParser::Component_instantiation_statementContext::Component_instantiation_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Label_colonContext *VHDLParser::Component_instantiation_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

VHDLParser::Instantiated_unitContext *VHDLParser::Component_instantiation_statementContext::instantiated_unit()
{
    return getRuleContext<VHDLParser::Instantiated_unitContext>(0);
}

tree::TerminalNode *VHDLParser::Component_instantiation_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Generic_map_aspectContext *VHDLParser::Component_instantiation_statementContext::generic_map_aspect()
{
    return getRuleContext<VHDLParser::Generic_map_aspectContext>(0);
}

VHDLParser::Port_map_aspectContext *VHDLParser::Component_instantiation_statementContext::port_map_aspect()
{
    return getRuleContext<VHDLParser::Port_map_aspectContext>(0);
}

size_t VHDLParser::Component_instantiation_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleComponent_instantiation_statement;
}

void VHDLParser::Component_instantiation_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterComponent_instantiation_statement(this);
}

void VHDLParser::Component_instantiation_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitComponent_instantiation_statement(this);
}

std::any VHDLParser::Component_instantiation_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitComponent_instantiation_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Component_instantiation_statementContext *VHDLParser::component_instantiation_statement()
{
    Component_instantiation_statementContext *_localctx = _tracker.createInstance<Component_instantiation_statementContext>(_ctx, getState());
    enterRule(_localctx, 90, VHDLParser::RuleComponent_instantiation_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(918);
        label_colon();
        setState(919);
        instantiated_unit();
        setState(921);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::GENERIC)
        {
            setState(920);
            generic_map_aspect();
        }
        setState(924);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::PORT)
        {
            setState(923);
            port_map_aspect();
        }
        setState(926);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Component_specificationContext
//------------------------------------------------------------------

VHDLParser::Component_specificationContext::Component_specificationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Instantiation_listContext *VHDLParser::Component_specificationContext::instantiation_list()
{
    return getRuleContext<VHDLParser::Instantiation_listContext>(0);
}

tree::TerminalNode *VHDLParser::Component_specificationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::NameContext *VHDLParser::Component_specificationContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

size_t VHDLParser::Component_specificationContext::getRuleIndex() const
{
    return VHDLParser::RuleComponent_specification;
}

void VHDLParser::Component_specificationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterComponent_specification(this);
}

void VHDLParser::Component_specificationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitComponent_specification(this);
}

std::any VHDLParser::Component_specificationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitComponent_specification(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Component_specificationContext *VHDLParser::component_specification()
{
    Component_specificationContext *_localctx = _tracker.createInstance<Component_specificationContext>(_ctx, getState());
    enterRule(_localctx, 92, VHDLParser::RuleComponent_specification);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(928);
        instantiation_list();
        setState(929);
        match(VHDLParser::COLON);
        setState(930);
        name();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Composite_nature_definitionContext
//------------------------------------------------------------------

VHDLParser::Composite_nature_definitionContext::Composite_nature_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Array_nature_definitionContext *VHDLParser::Composite_nature_definitionContext::array_nature_definition()
{
    return getRuleContext<VHDLParser::Array_nature_definitionContext>(0);
}

VHDLParser::Record_nature_definitionContext *VHDLParser::Composite_nature_definitionContext::record_nature_definition()
{
    return getRuleContext<VHDLParser::Record_nature_definitionContext>(0);
}

size_t VHDLParser::Composite_nature_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleComposite_nature_definition;
}

void VHDLParser::Composite_nature_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterComposite_nature_definition(this);
}

void VHDLParser::Composite_nature_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitComposite_nature_definition(this);
}

std::any VHDLParser::Composite_nature_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitComposite_nature_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Composite_nature_definitionContext *VHDLParser::composite_nature_definition()
{
    Composite_nature_definitionContext *_localctx = _tracker.createInstance<Composite_nature_definitionContext>(_ctx, getState());
    enterRule(_localctx, 94, VHDLParser::RuleComposite_nature_definition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(934);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::ARRAY: {
            enterOuterAlt(_localctx, 1);
            setState(932);
            array_nature_definition();
            break;
        }

        case VHDLParser::RECORD: {
            enterOuterAlt(_localctx, 2);
            setState(933);
            record_nature_definition();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Composite_type_definitionContext
//------------------------------------------------------------------

VHDLParser::Composite_type_definitionContext::Composite_type_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Array_type_definitionContext *VHDLParser::Composite_type_definitionContext::array_type_definition()
{
    return getRuleContext<VHDLParser::Array_type_definitionContext>(0);
}

VHDLParser::Record_type_definitionContext *VHDLParser::Composite_type_definitionContext::record_type_definition()
{
    return getRuleContext<VHDLParser::Record_type_definitionContext>(0);
}

size_t VHDLParser::Composite_type_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleComposite_type_definition;
}

void VHDLParser::Composite_type_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterComposite_type_definition(this);
}

void VHDLParser::Composite_type_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitComposite_type_definition(this);
}

std::any VHDLParser::Composite_type_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitComposite_type_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Composite_type_definitionContext *VHDLParser::composite_type_definition()
{
    Composite_type_definitionContext *_localctx = _tracker.createInstance<Composite_type_definitionContext>(_ctx, getState());
    enterRule(_localctx, 96, VHDLParser::RuleComposite_type_definition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(938);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::ARRAY: {
            enterOuterAlt(_localctx, 1);
            setState(936);
            array_type_definition();
            break;
        }

        case VHDLParser::RECORD: {
            enterOuterAlt(_localctx, 2);
            setState(937);
            record_type_definition();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Concurrent_assertion_statementContext
//------------------------------------------------------------------

VHDLParser::Concurrent_assertion_statementContext::Concurrent_assertion_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::AssertionContext *VHDLParser::Concurrent_assertion_statementContext::assertion()
{
    return getRuleContext<VHDLParser::AssertionContext>(0);
}

tree::TerminalNode *VHDLParser::Concurrent_assertion_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Concurrent_assertion_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

tree::TerminalNode *VHDLParser::Concurrent_assertion_statementContext::POSTPONED()
{
    return getToken(VHDLParser::POSTPONED, 0);
}

size_t VHDLParser::Concurrent_assertion_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleConcurrent_assertion_statement;
}

void VHDLParser::Concurrent_assertion_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterConcurrent_assertion_statement(this);
}

void VHDLParser::Concurrent_assertion_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitConcurrent_assertion_statement(this);
}

std::any VHDLParser::Concurrent_assertion_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitConcurrent_assertion_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Concurrent_assertion_statementContext *VHDLParser::concurrent_assertion_statement()
{
    Concurrent_assertion_statementContext *_localctx = _tracker.createInstance<Concurrent_assertion_statementContext>(_ctx, getState());
    enterRule(_localctx, 98, VHDLParser::RuleConcurrent_assertion_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(941);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(940);
            label_colon();
        }
        setState(944);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::POSTPONED)
        {
            setState(943);
            match(VHDLParser::POSTPONED);
        }
        setState(946);
        assertion();
        setState(947);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Concurrent_break_statementContext
//------------------------------------------------------------------

VHDLParser::Concurrent_break_statementContext::Concurrent_break_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Concurrent_break_statementContext::BREAK()
{
    return getToken(VHDLParser::BREAK, 0);
}

tree::TerminalNode *VHDLParser::Concurrent_break_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Concurrent_break_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

VHDLParser::Break_listContext *VHDLParser::Concurrent_break_statementContext::break_list()
{
    return getRuleContext<VHDLParser::Break_listContext>(0);
}

VHDLParser::Sensitivity_clauseContext *VHDLParser::Concurrent_break_statementContext::sensitivity_clause()
{
    return getRuleContext<VHDLParser::Sensitivity_clauseContext>(0);
}

tree::TerminalNode *VHDLParser::Concurrent_break_statementContext::WHEN()
{
    return getToken(VHDLParser::WHEN, 0);
}

VHDLParser::ConditionContext *VHDLParser::Concurrent_break_statementContext::condition()
{
    return getRuleContext<VHDLParser::ConditionContext>(0);
}

size_t VHDLParser::Concurrent_break_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleConcurrent_break_statement;
}

void VHDLParser::Concurrent_break_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterConcurrent_break_statement(this);
}

void VHDLParser::Concurrent_break_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitConcurrent_break_statement(this);
}

std::any VHDLParser::Concurrent_break_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitConcurrent_break_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Concurrent_break_statementContext *VHDLParser::concurrent_break_statement()
{
    Concurrent_break_statementContext *_localctx = _tracker.createInstance<Concurrent_break_statementContext>(_ctx, getState());
    enterRule(_localctx, 100, VHDLParser::RuleConcurrent_break_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(950);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(949);
            label_colon();
        }
        setState(952);
        match(VHDLParser::BREAK);
        setState(954);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::FOR || ((((_la - 118) & ~0x3fULL) == 0) && ((1ULL << (_la - 118)) & 515) != 0))
        {
            setState(953);
            break_list();
        }
        setState(957);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::ON)
        {
            setState(956);
            sensitivity_clause();
        }
        setState(961);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::WHEN)
        {
            setState(959);
            match(VHDLParser::WHEN);
            setState(960);
            condition();
        }
        setState(963);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Concurrent_procedure_call_statementContext
//------------------------------------------------------------------

VHDLParser::Concurrent_procedure_call_statementContext::Concurrent_procedure_call_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Procedure_callContext *VHDLParser::Concurrent_procedure_call_statementContext::procedure_call()
{
    return getRuleContext<VHDLParser::Procedure_callContext>(0);
}

tree::TerminalNode *VHDLParser::Concurrent_procedure_call_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Concurrent_procedure_call_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

tree::TerminalNode *VHDLParser::Concurrent_procedure_call_statementContext::POSTPONED()
{
    return getToken(VHDLParser::POSTPONED, 0);
}

size_t VHDLParser::Concurrent_procedure_call_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleConcurrent_procedure_call_statement;
}

void VHDLParser::Concurrent_procedure_call_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterConcurrent_procedure_call_statement(this);
}

void VHDLParser::Concurrent_procedure_call_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitConcurrent_procedure_call_statement(this);
}

std::any VHDLParser::Concurrent_procedure_call_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitConcurrent_procedure_call_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Concurrent_procedure_call_statementContext *VHDLParser::concurrent_procedure_call_statement()
{
    Concurrent_procedure_call_statementContext *_localctx = _tracker.createInstance<Concurrent_procedure_call_statementContext>(_ctx, getState());
    enterRule(_localctx, 102, VHDLParser::RuleConcurrent_procedure_call_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(966);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx))
        {
        case 1: {
            setState(965);
            label_colon();
            break;
        }

        default:
            break;
        }
        setState(969);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::POSTPONED)
        {
            setState(968);
            match(VHDLParser::POSTPONED);
        }
        setState(971);
        procedure_call();
        setState(972);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Concurrent_signal_assignment_statementContext
//------------------------------------------------------------------

VHDLParser::Concurrent_signal_assignment_statementContext::Concurrent_signal_assignment_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Conditional_signal_assignmentContext *VHDLParser::Concurrent_signal_assignment_statementContext::conditional_signal_assignment()
{
    return getRuleContext<VHDLParser::Conditional_signal_assignmentContext>(0);
}

VHDLParser::Selected_signal_assignmentContext *VHDLParser::Concurrent_signal_assignment_statementContext::selected_signal_assignment()
{
    return getRuleContext<VHDLParser::Selected_signal_assignmentContext>(0);
}

VHDLParser::Label_colonContext *VHDLParser::Concurrent_signal_assignment_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

tree::TerminalNode *VHDLParser::Concurrent_signal_assignment_statementContext::POSTPONED()
{
    return getToken(VHDLParser::POSTPONED, 0);
}

size_t VHDLParser::Concurrent_signal_assignment_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleConcurrent_signal_assignment_statement;
}

void VHDLParser::Concurrent_signal_assignment_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterConcurrent_signal_assignment_statement(this);
}

void VHDLParser::Concurrent_signal_assignment_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitConcurrent_signal_assignment_statement(this);
}

std::any VHDLParser::Concurrent_signal_assignment_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitConcurrent_signal_assignment_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Concurrent_signal_assignment_statementContext *VHDLParser::concurrent_signal_assignment_statement()
{
    Concurrent_signal_assignment_statementContext *_localctx = _tracker.createInstance<Concurrent_signal_assignment_statementContext>(_ctx, getState());
    enterRule(_localctx, 104, VHDLParser::RuleConcurrent_signal_assignment_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(975);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx))
        {
        case 1: {
            setState(974);
            label_colon();
            break;
        }

        default:
            break;
        }
        setState(978);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::POSTPONED)
        {
            setState(977);
            match(VHDLParser::POSTPONED);
        }
        setState(982);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER:
        case VHDLParser::STRING_LITERAL:
        case VHDLParser::LPAREN: {
            setState(980);
            conditional_signal_assignment();
            break;
        }

        case VHDLParser::WITH: {
            setState(981);
            selected_signal_assignment();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ConditionContext
//------------------------------------------------------------------

VHDLParser::ConditionContext::ConditionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::ExpressionContext *VHDLParser::ConditionContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::ConditionContext::getRuleIndex() const
{
    return VHDLParser::RuleCondition;
}

void VHDLParser::ConditionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterCondition(this);
}

void VHDLParser::ConditionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitCondition(this);
}

std::any VHDLParser::ConditionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitCondition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::ConditionContext *VHDLParser::condition()
{
    ConditionContext *_localctx = _tracker.createInstance<ConditionContext>(_ctx, getState());
    enterRule(_localctx, 106, VHDLParser::RuleCondition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(984);
        expression();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Condition_clauseContext
//------------------------------------------------------------------

VHDLParser::Condition_clauseContext::Condition_clauseContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Condition_clauseContext::UNTIL()
{
    return getToken(VHDLParser::UNTIL, 0);
}

VHDLParser::ConditionContext *VHDLParser::Condition_clauseContext::condition()
{
    return getRuleContext<VHDLParser::ConditionContext>(0);
}

size_t VHDLParser::Condition_clauseContext::getRuleIndex() const
{
    return VHDLParser::RuleCondition_clause;
}

void VHDLParser::Condition_clauseContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterCondition_clause(this);
}

void VHDLParser::Condition_clauseContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitCondition_clause(this);
}

std::any VHDLParser::Condition_clauseContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitCondition_clause(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Condition_clauseContext *VHDLParser::condition_clause()
{
    Condition_clauseContext *_localctx = _tracker.createInstance<Condition_clauseContext>(_ctx, getState());
    enterRule(_localctx, 108, VHDLParser::RuleCondition_clause);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(986);
        match(VHDLParser::UNTIL);
        setState(987);
        condition();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Conditional_signal_assignmentContext
//------------------------------------------------------------------

VHDLParser::Conditional_signal_assignmentContext::Conditional_signal_assignmentContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::TargetContext *VHDLParser::Conditional_signal_assignmentContext::target()
{
    return getRuleContext<VHDLParser::TargetContext>(0);
}

tree::TerminalNode *VHDLParser::Conditional_signal_assignmentContext::LE()
{
    return getToken(VHDLParser::LE, 0);
}

VHDLParser::OptsContext *VHDLParser::Conditional_signal_assignmentContext::opts()
{
    return getRuleContext<VHDLParser::OptsContext>(0);
}

VHDLParser::Conditional_waveformsContext *VHDLParser::Conditional_signal_assignmentContext::conditional_waveforms()
{
    return getRuleContext<VHDLParser::Conditional_waveformsContext>(0);
}

tree::TerminalNode *VHDLParser::Conditional_signal_assignmentContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Conditional_signal_assignmentContext::getRuleIndex() const
{
    return VHDLParser::RuleConditional_signal_assignment;
}

void VHDLParser::Conditional_signal_assignmentContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterConditional_signal_assignment(this);
}

void VHDLParser::Conditional_signal_assignmentContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitConditional_signal_assignment(this);
}

std::any VHDLParser::Conditional_signal_assignmentContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitConditional_signal_assignment(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Conditional_signal_assignmentContext *VHDLParser::conditional_signal_assignment()
{
    Conditional_signal_assignmentContext *_localctx = _tracker.createInstance<Conditional_signal_assignmentContext>(_ctx, getState());
    enterRule(_localctx, 110, VHDLParser::RuleConditional_signal_assignment);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(989);
        target();
        setState(990);
        match(VHDLParser::LE);
        setState(991);
        opts();
        setState(992);
        conditional_waveforms();
        setState(993);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Conditional_waveformsContext
//------------------------------------------------------------------

VHDLParser::Conditional_waveformsContext::Conditional_waveformsContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::WaveformContext *VHDLParser::Conditional_waveformsContext::waveform()
{
    return getRuleContext<VHDLParser::WaveformContext>(0);
}

tree::TerminalNode *VHDLParser::Conditional_waveformsContext::WHEN()
{
    return getToken(VHDLParser::WHEN, 0);
}

VHDLParser::ConditionContext *VHDLParser::Conditional_waveformsContext::condition()
{
    return getRuleContext<VHDLParser::ConditionContext>(0);
}

tree::TerminalNode *VHDLParser::Conditional_waveformsContext::ELSE()
{
    return getToken(VHDLParser::ELSE, 0);
}

VHDLParser::Conditional_waveformsContext *VHDLParser::Conditional_waveformsContext::conditional_waveforms()
{
    return getRuleContext<VHDLParser::Conditional_waveformsContext>(0);
}

size_t VHDLParser::Conditional_waveformsContext::getRuleIndex() const
{
    return VHDLParser::RuleConditional_waveforms;
}

void VHDLParser::Conditional_waveformsContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterConditional_waveforms(this);
}

void VHDLParser::Conditional_waveformsContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitConditional_waveforms(this);
}

std::any VHDLParser::Conditional_waveformsContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitConditional_waveforms(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Conditional_waveformsContext *VHDLParser::conditional_waveforms()
{
    Conditional_waveformsContext *_localctx = _tracker.createInstance<Conditional_waveformsContext>(_ctx, getState());
    enterRule(_localctx, 112, VHDLParser::RuleConditional_waveforms);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(995);
        waveform();
        setState(1002);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::WHEN)
        {
            setState(996);
            match(VHDLParser::WHEN);
            setState(997);
            condition();
            setState(1000);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == VHDLParser::ELSE)
            {
                setState(998);
                match(VHDLParser::ELSE);
                setState(999);
                conditional_waveforms();
            }
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Configuration_declarationContext
//------------------------------------------------------------------

VHDLParser::Configuration_declarationContext::Configuration_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::Configuration_declarationContext::CONFIGURATION()
{
    return getTokens(VHDLParser::CONFIGURATION);
}

tree::TerminalNode *VHDLParser::Configuration_declarationContext::CONFIGURATION(size_t i)
{
    return getToken(VHDLParser::CONFIGURATION, i);
}

std::vector<VHDLParser::IdentifierContext *> VHDLParser::Configuration_declarationContext::identifier()
{
    return getRuleContexts<VHDLParser::IdentifierContext>();
}

VHDLParser::IdentifierContext *VHDLParser::Configuration_declarationContext::identifier(size_t i)
{
    return getRuleContext<VHDLParser::IdentifierContext>(i);
}

tree::TerminalNode *VHDLParser::Configuration_declarationContext::OF()
{
    return getToken(VHDLParser::OF, 0);
}

VHDLParser::NameContext *VHDLParser::Configuration_declarationContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

tree::TerminalNode *VHDLParser::Configuration_declarationContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::Configuration_declarative_partContext *VHDLParser::Configuration_declarationContext::configuration_declarative_part()
{
    return getRuleContext<VHDLParser::Configuration_declarative_partContext>(0);
}

VHDLParser::Block_configurationContext *VHDLParser::Configuration_declarationContext::block_configuration()
{
    return getRuleContext<VHDLParser::Block_configurationContext>(0);
}

tree::TerminalNode *VHDLParser::Configuration_declarationContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::Configuration_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Configuration_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleConfiguration_declaration;
}

void VHDLParser::Configuration_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterConfiguration_declaration(this);
}

void VHDLParser::Configuration_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitConfiguration_declaration(this);
}

std::any VHDLParser::Configuration_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitConfiguration_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Configuration_declarationContext *VHDLParser::configuration_declaration()
{
    Configuration_declarationContext *_localctx = _tracker.createInstance<Configuration_declarationContext>(_ctx, getState());
    enterRule(_localctx, 114, VHDLParser::RuleConfiguration_declaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1004);
        match(VHDLParser::CONFIGURATION);
        setState(1005);
        identifier();
        setState(1006);
        match(VHDLParser::OF);
        setState(1007);
        name();
        setState(1008);
        match(VHDLParser::IS);
        setState(1009);
        configuration_declarative_part();
        setState(1010);
        block_configuration();
        setState(1011);
        match(VHDLParser::END);
        setState(1013);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::CONFIGURATION)
        {
            setState(1012);
            match(VHDLParser::CONFIGURATION);
        }
        setState(1016);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1015);
            identifier();
        }
        setState(1018);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Configuration_declarative_itemContext
//------------------------------------------------------------------

VHDLParser::Configuration_declarative_itemContext::Configuration_declarative_itemContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Use_clauseContext *VHDLParser::Configuration_declarative_itemContext::use_clause()
{
    return getRuleContext<VHDLParser::Use_clauseContext>(0);
}

VHDLParser::Attribute_specificationContext *VHDLParser::Configuration_declarative_itemContext::attribute_specification()
{
    return getRuleContext<VHDLParser::Attribute_specificationContext>(0);
}

VHDLParser::Group_declarationContext *VHDLParser::Configuration_declarative_itemContext::group_declaration()
{
    return getRuleContext<VHDLParser::Group_declarationContext>(0);
}

size_t VHDLParser::Configuration_declarative_itemContext::getRuleIndex() const
{
    return VHDLParser::RuleConfiguration_declarative_item;
}

void VHDLParser::Configuration_declarative_itemContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterConfiguration_declarative_item(this);
}

void VHDLParser::Configuration_declarative_itemContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitConfiguration_declarative_item(this);
}

std::any VHDLParser::Configuration_declarative_itemContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitConfiguration_declarative_item(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Configuration_declarative_itemContext *VHDLParser::configuration_declarative_item()
{
    Configuration_declarative_itemContext *_localctx = _tracker.createInstance<Configuration_declarative_itemContext>(_ctx, getState());
    enterRule(_localctx, 116, VHDLParser::RuleConfiguration_declarative_item);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1023);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::USE: {
            enterOuterAlt(_localctx, 1);
            setState(1020);
            use_clause();
            break;
        }

        case VHDLParser::ATTRIBUTE: {
            enterOuterAlt(_localctx, 2);
            setState(1021);
            attribute_specification();
            break;
        }

        case VHDLParser::GROUP: {
            enterOuterAlt(_localctx, 3);
            setState(1022);
            group_declaration();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Configuration_declarative_partContext
//------------------------------------------------------------------

VHDLParser::Configuration_declarative_partContext::Configuration_declarative_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Configuration_declarative_itemContext *> VHDLParser::Configuration_declarative_partContext::configuration_declarative_item()
{
    return getRuleContexts<VHDLParser::Configuration_declarative_itemContext>();
}

VHDLParser::Configuration_declarative_itemContext *VHDLParser::Configuration_declarative_partContext::configuration_declarative_item(size_t i)
{
    return getRuleContext<VHDLParser::Configuration_declarative_itemContext>(i);
}

size_t VHDLParser::Configuration_declarative_partContext::getRuleIndex() const
{
    return VHDLParser::RuleConfiguration_declarative_part;
}

void VHDLParser::Configuration_declarative_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterConfiguration_declarative_part(this);
}

void VHDLParser::Configuration_declarative_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitConfiguration_declarative_part(this);
}

std::any VHDLParser::Configuration_declarative_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitConfiguration_declarative_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Configuration_declarative_partContext *VHDLParser::configuration_declarative_part()
{
    Configuration_declarative_partContext *_localctx = _tracker.createInstance<Configuration_declarative_partContext>(_ctx, getState());
    enterRule(_localctx, 118, VHDLParser::RuleConfiguration_declarative_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1028);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::ATTRIBUTE

               || _la == VHDLParser::GROUP || _la == VHDLParser::USE)
        {
            setState(1025);
            configuration_declarative_item();
            setState(1030);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Configuration_itemContext
//------------------------------------------------------------------

VHDLParser::Configuration_itemContext::Configuration_itemContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Block_configurationContext *VHDLParser::Configuration_itemContext::block_configuration()
{
    return getRuleContext<VHDLParser::Block_configurationContext>(0);
}

VHDLParser::Component_configurationContext *VHDLParser::Configuration_itemContext::component_configuration()
{
    return getRuleContext<VHDLParser::Component_configurationContext>(0);
}

size_t VHDLParser::Configuration_itemContext::getRuleIndex() const
{
    return VHDLParser::RuleConfiguration_item;
}

void VHDLParser::Configuration_itemContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterConfiguration_item(this);
}

void VHDLParser::Configuration_itemContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitConfiguration_item(this);
}

std::any VHDLParser::Configuration_itemContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitConfiguration_item(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Configuration_itemContext *VHDLParser::configuration_item()
{
    Configuration_itemContext *_localctx = _tracker.createInstance<Configuration_itemContext>(_ctx, getState());
    enterRule(_localctx, 120, VHDLParser::RuleConfiguration_item);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1033);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(1031);
            block_configuration();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(1032);
            component_configuration();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Configuration_specificationContext
//------------------------------------------------------------------

VHDLParser::Configuration_specificationContext::Configuration_specificationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Configuration_specificationContext::FOR()
{
    return getToken(VHDLParser::FOR, 0);
}

VHDLParser::Component_specificationContext *VHDLParser::Configuration_specificationContext::component_specification()
{
    return getRuleContext<VHDLParser::Component_specificationContext>(0);
}

VHDLParser::Binding_indicationContext *VHDLParser::Configuration_specificationContext::binding_indication()
{
    return getRuleContext<VHDLParser::Binding_indicationContext>(0);
}

tree::TerminalNode *VHDLParser::Configuration_specificationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Configuration_specificationContext::getRuleIndex() const
{
    return VHDLParser::RuleConfiguration_specification;
}

void VHDLParser::Configuration_specificationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterConfiguration_specification(this);
}

void VHDLParser::Configuration_specificationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitConfiguration_specification(this);
}

std::any VHDLParser::Configuration_specificationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitConfiguration_specification(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Configuration_specificationContext *VHDLParser::configuration_specification()
{
    Configuration_specificationContext *_localctx = _tracker.createInstance<Configuration_specificationContext>(_ctx, getState());
    enterRule(_localctx, 122, VHDLParser::RuleConfiguration_specification);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1035);
        match(VHDLParser::FOR);
        setState(1036);
        component_specification();
        setState(1037);
        binding_indication();
        setState(1038);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Constant_declarationContext
//------------------------------------------------------------------

VHDLParser::Constant_declarationContext::Constant_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Constant_declarationContext::CONSTANT()
{
    return getToken(VHDLParser::CONSTANT, 0);
}

VHDLParser::Identifier_listContext *VHDLParser::Constant_declarationContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Constant_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Constant_declarationContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

tree::TerminalNode *VHDLParser::Constant_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

tree::TerminalNode *VHDLParser::Constant_declarationContext::VARASGN()
{
    return getToken(VHDLParser::VARASGN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Constant_declarationContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::Constant_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleConstant_declaration;
}

void VHDLParser::Constant_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterConstant_declaration(this);
}

void VHDLParser::Constant_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitConstant_declaration(this);
}

std::any VHDLParser::Constant_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitConstant_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Constant_declarationContext *VHDLParser::constant_declaration()
{
    Constant_declarationContext *_localctx = _tracker.createInstance<Constant_declarationContext>(_ctx, getState());
    enterRule(_localctx, 124, VHDLParser::RuleConstant_declaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1040);
        match(VHDLParser::CONSTANT);
        setState(1041);
        identifier_list();
        setState(1042);
        match(VHDLParser::COLON);
        setState(1043);
        subtype_indication();
        setState(1046);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::VARASGN)
        {
            setState(1044);
            match(VHDLParser::VARASGN);
            setState(1045);
            expression();
        }
        setState(1048);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Constrained_array_definitionContext
//------------------------------------------------------------------

VHDLParser::Constrained_array_definitionContext::Constrained_array_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Constrained_array_definitionContext::ARRAY()
{
    return getToken(VHDLParser::ARRAY, 0);
}

VHDLParser::Index_constraintContext *VHDLParser::Constrained_array_definitionContext::index_constraint()
{
    return getRuleContext<VHDLParser::Index_constraintContext>(0);
}

tree::TerminalNode *VHDLParser::Constrained_array_definitionContext::OF()
{
    return getToken(VHDLParser::OF, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Constrained_array_definitionContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

size_t VHDLParser::Constrained_array_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleConstrained_array_definition;
}

void VHDLParser::Constrained_array_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterConstrained_array_definition(this);
}

void VHDLParser::Constrained_array_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitConstrained_array_definition(this);
}

std::any VHDLParser::Constrained_array_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitConstrained_array_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Constrained_array_definitionContext *VHDLParser::constrained_array_definition()
{
    Constrained_array_definitionContext *_localctx = _tracker.createInstance<Constrained_array_definitionContext>(_ctx, getState());
    enterRule(_localctx, 126, VHDLParser::RuleConstrained_array_definition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1050);
        match(VHDLParser::ARRAY);
        setState(1051);
        index_constraint();
        setState(1052);
        match(VHDLParser::OF);
        setState(1053);
        subtype_indication();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Constrained_nature_definitionContext
//------------------------------------------------------------------

VHDLParser::Constrained_nature_definitionContext::Constrained_nature_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Constrained_nature_definitionContext::ARRAY()
{
    return getToken(VHDLParser::ARRAY, 0);
}

VHDLParser::Index_constraintContext *VHDLParser::Constrained_nature_definitionContext::index_constraint()
{
    return getRuleContext<VHDLParser::Index_constraintContext>(0);
}

tree::TerminalNode *VHDLParser::Constrained_nature_definitionContext::OF()
{
    return getToken(VHDLParser::OF, 0);
}

VHDLParser::Subnature_indicationContext *VHDLParser::Constrained_nature_definitionContext::subnature_indication()
{
    return getRuleContext<VHDLParser::Subnature_indicationContext>(0);
}

size_t VHDLParser::Constrained_nature_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleConstrained_nature_definition;
}

void VHDLParser::Constrained_nature_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterConstrained_nature_definition(this);
}

void VHDLParser::Constrained_nature_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitConstrained_nature_definition(this);
}

std::any VHDLParser::Constrained_nature_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitConstrained_nature_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Constrained_nature_definitionContext *VHDLParser::constrained_nature_definition()
{
    Constrained_nature_definitionContext *_localctx = _tracker.createInstance<Constrained_nature_definitionContext>(_ctx, getState());
    enterRule(_localctx, 128, VHDLParser::RuleConstrained_nature_definition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1055);
        match(VHDLParser::ARRAY);
        setState(1056);
        index_constraint();
        setState(1057);
        match(VHDLParser::OF);
        setState(1058);
        subnature_indication();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ConstraintContext
//------------------------------------------------------------------

VHDLParser::ConstraintContext::ConstraintContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Range_constraintContext *VHDLParser::ConstraintContext::range_constraint()
{
    return getRuleContext<VHDLParser::Range_constraintContext>(0);
}

VHDLParser::Index_constraintContext *VHDLParser::ConstraintContext::index_constraint()
{
    return getRuleContext<VHDLParser::Index_constraintContext>(0);
}

size_t VHDLParser::ConstraintContext::getRuleIndex() const
{
    return VHDLParser::RuleConstraint;
}

void VHDLParser::ConstraintContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterConstraint(this);
}

void VHDLParser::ConstraintContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitConstraint(this);
}

std::any VHDLParser::ConstraintContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitConstraint(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::ConstraintContext *VHDLParser::constraint()
{
    ConstraintContext *_localctx = _tracker.createInstance<ConstraintContext>(_ctx, getState());
    enterRule(_localctx, 130, VHDLParser::RuleConstraint);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1062);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::RANGE: {
            enterOuterAlt(_localctx, 1);
            setState(1060);
            range_constraint();
            break;
        }

        case VHDLParser::LPAREN: {
            enterOuterAlt(_localctx, 2);
            setState(1061);
            index_constraint();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Context_clauseContext
//------------------------------------------------------------------

VHDLParser::Context_clauseContext::Context_clauseContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Context_itemContext *> VHDLParser::Context_clauseContext::context_item()
{
    return getRuleContexts<VHDLParser::Context_itemContext>();
}

VHDLParser::Context_itemContext *VHDLParser::Context_clauseContext::context_item(size_t i)
{
    return getRuleContext<VHDLParser::Context_itemContext>(i);
}

size_t VHDLParser::Context_clauseContext::getRuleIndex() const
{
    return VHDLParser::RuleContext_clause;
}

void VHDLParser::Context_clauseContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterContext_clause(this);
}

void VHDLParser::Context_clauseContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitContext_clause(this);
}

std::any VHDLParser::Context_clauseContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitContext_clause(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Context_clauseContext *VHDLParser::context_clause()
{
    Context_clauseContext *_localctx = _tracker.createInstance<Context_clauseContext>(_ctx, getState());
    enterRule(_localctx, 132, VHDLParser::RuleContext_clause);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1067);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::LIBRARY

               || _la == VHDLParser::USE)
        {
            setState(1064);
            context_item();
            setState(1069);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Context_itemContext
//------------------------------------------------------------------

VHDLParser::Context_itemContext::Context_itemContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Library_clauseContext *VHDLParser::Context_itemContext::library_clause()
{
    return getRuleContext<VHDLParser::Library_clauseContext>(0);
}

VHDLParser::Use_clauseContext *VHDLParser::Context_itemContext::use_clause()
{
    return getRuleContext<VHDLParser::Use_clauseContext>(0);
}

size_t VHDLParser::Context_itemContext::getRuleIndex() const
{
    return VHDLParser::RuleContext_item;
}

void VHDLParser::Context_itemContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterContext_item(this);
}

void VHDLParser::Context_itemContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitContext_item(this);
}

std::any VHDLParser::Context_itemContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitContext_item(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Context_itemContext *VHDLParser::context_item()
{
    Context_itemContext *_localctx = _tracker.createInstance<Context_itemContext>(_ctx, getState());
    enterRule(_localctx, 134, VHDLParser::RuleContext_item);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1072);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::LIBRARY: {
            enterOuterAlt(_localctx, 1);
            setState(1070);
            library_clause();
            break;
        }

        case VHDLParser::USE: {
            enterOuterAlt(_localctx, 2);
            setState(1071);
            use_clause();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Delay_mechanismContext
//------------------------------------------------------------------

VHDLParser::Delay_mechanismContext::Delay_mechanismContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Delay_mechanismContext::TRANSPORT()
{
    return getToken(VHDLParser::TRANSPORT, 0);
}

tree::TerminalNode *VHDLParser::Delay_mechanismContext::INERTIAL()
{
    return getToken(VHDLParser::INERTIAL, 0);
}

tree::TerminalNode *VHDLParser::Delay_mechanismContext::REJECT()
{
    return getToken(VHDLParser::REJECT, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Delay_mechanismContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::Delay_mechanismContext::getRuleIndex() const
{
    return VHDLParser::RuleDelay_mechanism;
}

void VHDLParser::Delay_mechanismContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterDelay_mechanism(this);
}

void VHDLParser::Delay_mechanismContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitDelay_mechanism(this);
}

std::any VHDLParser::Delay_mechanismContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitDelay_mechanism(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Delay_mechanismContext *VHDLParser::delay_mechanism()
{
    Delay_mechanismContext *_localctx = _tracker.createInstance<Delay_mechanismContext>(_ctx, getState());
    enterRule(_localctx, 136, VHDLParser::RuleDelay_mechanism);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1080);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::TRANSPORT: {
            enterOuterAlt(_localctx, 1);
            setState(1074);
            match(VHDLParser::TRANSPORT);
            break;
        }

        case VHDLParser::INERTIAL:
        case VHDLParser::REJECT: {
            enterOuterAlt(_localctx, 2);
            setState(1077);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == VHDLParser::REJECT)
            {
                setState(1075);
                match(VHDLParser::REJECT);
                setState(1076);
                expression();
            }
            setState(1079);
            match(VHDLParser::INERTIAL);
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Design_fileContext
//------------------------------------------------------------------

VHDLParser::Design_fileContext::Design_fileContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Design_fileContext::EOF()
{
    return getToken(VHDLParser::EOF, 0);
}

std::vector<VHDLParser::Design_unitContext *> VHDLParser::Design_fileContext::design_unit()
{
    return getRuleContexts<VHDLParser::Design_unitContext>();
}

VHDLParser::Design_unitContext *VHDLParser::Design_fileContext::design_unit(size_t i)
{
    return getRuleContext<VHDLParser::Design_unitContext>(i);
}

size_t VHDLParser::Design_fileContext::getRuleIndex() const
{
    return VHDLParser::RuleDesign_file;
}

void VHDLParser::Design_fileContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterDesign_file(this);
}

void VHDLParser::Design_fileContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitDesign_file(this);
}

std::any VHDLParser::Design_fileContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitDesign_file(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Design_fileContext *VHDLParser::design_file()
{
    Design_fileContext *_localctx = _tracker.createInstance<Design_fileContext>(_ctx, getState());
    enterRule(_localctx, 138, VHDLParser::RuleDesign_file);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1085);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 8796127625472) != 0) || _la == VHDLParser::PACKAGE

               || _la == VHDLParser::USE)
        {
            setState(1082);
            design_unit();
            setState(1087);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(1088);
        match(VHDLParser::EOF);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Design_unitContext
//------------------------------------------------------------------

VHDLParser::Design_unitContext::Design_unitContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Context_clauseContext *VHDLParser::Design_unitContext::context_clause()
{
    return getRuleContext<VHDLParser::Context_clauseContext>(0);
}

VHDLParser::Library_unitContext *VHDLParser::Design_unitContext::library_unit()
{
    return getRuleContext<VHDLParser::Library_unitContext>(0);
}

size_t VHDLParser::Design_unitContext::getRuleIndex() const
{
    return VHDLParser::RuleDesign_unit;
}

void VHDLParser::Design_unitContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterDesign_unit(this);
}

void VHDLParser::Design_unitContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitDesign_unit(this);
}

std::any VHDLParser::Design_unitContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitDesign_unit(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Design_unitContext *VHDLParser::design_unit()
{
    Design_unitContext *_localctx = _tracker.createInstance<Design_unitContext>(_ctx, getState());
    enterRule(_localctx, 140, VHDLParser::RuleDesign_unit);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1090);
        context_clause();
        setState(1091);
        library_unit();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- DesignatorContext
//------------------------------------------------------------------

VHDLParser::DesignatorContext::DesignatorContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::IdentifierContext *VHDLParser::DesignatorContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::DesignatorContext::STRING_LITERAL()
{
    return getToken(VHDLParser::STRING_LITERAL, 0);
}

size_t VHDLParser::DesignatorContext::getRuleIndex() const
{
    return VHDLParser::RuleDesignator;
}

void VHDLParser::DesignatorContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterDesignator(this);
}

void VHDLParser::DesignatorContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitDesignator(this);
}

std::any VHDLParser::DesignatorContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitDesignator(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::DesignatorContext *VHDLParser::designator()
{
    DesignatorContext *_localctx = _tracker.createInstance<DesignatorContext>(_ctx, getState());
    enterRule(_localctx, 142, VHDLParser::RuleDesignator);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1095);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER: {
            enterOuterAlt(_localctx, 1);
            setState(1093);
            identifier();
            break;
        }

        case VHDLParser::STRING_LITERAL: {
            enterOuterAlt(_localctx, 2);
            setState(1094);
            match(VHDLParser::STRING_LITERAL);
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- DirectionContext
//------------------------------------------------------------------

VHDLParser::DirectionContext::DirectionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::DirectionContext::TO()
{
    return getToken(VHDLParser::TO, 0);
}

tree::TerminalNode *VHDLParser::DirectionContext::DOWNTO()
{
    return getToken(VHDLParser::DOWNTO, 0);
}

size_t VHDLParser::DirectionContext::getRuleIndex() const
{
    return VHDLParser::RuleDirection;
}

void VHDLParser::DirectionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterDirection(this);
}

void VHDLParser::DirectionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitDirection(this);
}

std::any VHDLParser::DirectionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitDirection(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::DirectionContext *VHDLParser::direction()
{
    DirectionContext *_localctx = _tracker.createInstance<DirectionContext>(_ctx, getState());
    enterRule(_localctx, 144, VHDLParser::RuleDirection);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1097);
        _la = _input->LA(1);
        if (!(_la == VHDLParser::DOWNTO || _la == VHDLParser::TO))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Disconnection_specificationContext
//------------------------------------------------------------------

VHDLParser::Disconnection_specificationContext::Disconnection_specificationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Disconnection_specificationContext::DISCONNECT()
{
    return getToken(VHDLParser::DISCONNECT, 0);
}

VHDLParser::Guarded_signal_specificationContext *VHDLParser::Disconnection_specificationContext::guarded_signal_specification()
{
    return getRuleContext<VHDLParser::Guarded_signal_specificationContext>(0);
}

tree::TerminalNode *VHDLParser::Disconnection_specificationContext::AFTER()
{
    return getToken(VHDLParser::AFTER, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Disconnection_specificationContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

tree::TerminalNode *VHDLParser::Disconnection_specificationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Disconnection_specificationContext::getRuleIndex() const
{
    return VHDLParser::RuleDisconnection_specification;
}

void VHDLParser::Disconnection_specificationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterDisconnection_specification(this);
}

void VHDLParser::Disconnection_specificationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitDisconnection_specification(this);
}

std::any VHDLParser::Disconnection_specificationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitDisconnection_specification(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Disconnection_specificationContext *VHDLParser::disconnection_specification()
{
    Disconnection_specificationContext *_localctx = _tracker.createInstance<Disconnection_specificationContext>(_ctx, getState());
    enterRule(_localctx, 146, VHDLParser::RuleDisconnection_specification);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1099);
        match(VHDLParser::DISCONNECT);
        setState(1100);
        guarded_signal_specification();
        setState(1101);
        match(VHDLParser::AFTER);
        setState(1102);
        expression();
        setState(1103);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Discrete_rangeContext
//------------------------------------------------------------------

VHDLParser::Discrete_rangeContext::Discrete_rangeContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Range_declContext *VHDLParser::Discrete_rangeContext::range_decl()
{
    return getRuleContext<VHDLParser::Range_declContext>(0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Discrete_rangeContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

size_t VHDLParser::Discrete_rangeContext::getRuleIndex() const
{
    return VHDLParser::RuleDiscrete_range;
}

void VHDLParser::Discrete_rangeContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterDiscrete_range(this);
}

void VHDLParser::Discrete_rangeContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitDiscrete_range(this);
}

std::any VHDLParser::Discrete_rangeContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitDiscrete_range(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Discrete_rangeContext *VHDLParser::discrete_range()
{
    Discrete_rangeContext *_localctx = _tracker.createInstance<Discrete_rangeContext>(_ctx, getState());
    enterRule(_localctx, 148, VHDLParser::RuleDiscrete_range);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1107);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 92, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(1105);
            range_decl();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(1106);
            subtype_indication();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Element_associationContext
//------------------------------------------------------------------

VHDLParser::Element_associationContext::Element_associationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::ExpressionContext *VHDLParser::Element_associationContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

VHDLParser::ChoicesContext *VHDLParser::Element_associationContext::choices()
{
    return getRuleContext<VHDLParser::ChoicesContext>(0);
}

tree::TerminalNode *VHDLParser::Element_associationContext::ARROW()
{
    return getToken(VHDLParser::ARROW, 0);
}

size_t VHDLParser::Element_associationContext::getRuleIndex() const
{
    return VHDLParser::RuleElement_association;
}

void VHDLParser::Element_associationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterElement_association(this);
}

void VHDLParser::Element_associationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitElement_association(this);
}

std::any VHDLParser::Element_associationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitElement_association(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Element_associationContext *VHDLParser::element_association()
{
    Element_associationContext *_localctx = _tracker.createInstance<Element_associationContext>(_ctx, getState());
    enterRule(_localctx, 150, VHDLParser::RuleElement_association);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1112);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx))
        {
        case 1: {
            setState(1109);
            choices();
            setState(1110);
            match(VHDLParser::ARROW);
            break;
        }

        default:
            break;
        }
        setState(1114);
        expression();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Element_declarationContext
//------------------------------------------------------------------

VHDLParser::Element_declarationContext::Element_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Identifier_listContext *VHDLParser::Element_declarationContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Element_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Element_subtype_definitionContext *VHDLParser::Element_declarationContext::element_subtype_definition()
{
    return getRuleContext<VHDLParser::Element_subtype_definitionContext>(0);
}

tree::TerminalNode *VHDLParser::Element_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Element_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleElement_declaration;
}

void VHDLParser::Element_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterElement_declaration(this);
}

void VHDLParser::Element_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitElement_declaration(this);
}

std::any VHDLParser::Element_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitElement_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Element_declarationContext *VHDLParser::element_declaration()
{
    Element_declarationContext *_localctx = _tracker.createInstance<Element_declarationContext>(_ctx, getState());
    enterRule(_localctx, 152, VHDLParser::RuleElement_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1116);
        identifier_list();
        setState(1117);
        match(VHDLParser::COLON);
        setState(1118);
        element_subtype_definition();
        setState(1119);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Element_subnature_definitionContext
//------------------------------------------------------------------

VHDLParser::Element_subnature_definitionContext::Element_subnature_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Subnature_indicationContext *VHDLParser::Element_subnature_definitionContext::subnature_indication()
{
    return getRuleContext<VHDLParser::Subnature_indicationContext>(0);
}

size_t VHDLParser::Element_subnature_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleElement_subnature_definition;
}

void VHDLParser::Element_subnature_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterElement_subnature_definition(this);
}

void VHDLParser::Element_subnature_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitElement_subnature_definition(this);
}

std::any VHDLParser::Element_subnature_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitElement_subnature_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Element_subnature_definitionContext *VHDLParser::element_subnature_definition()
{
    Element_subnature_definitionContext *_localctx = _tracker.createInstance<Element_subnature_definitionContext>(_ctx, getState());
    enterRule(_localctx, 154, VHDLParser::RuleElement_subnature_definition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1121);
        subnature_indication();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Element_subtype_definitionContext
//------------------------------------------------------------------

VHDLParser::Element_subtype_definitionContext::Element_subtype_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Subtype_indicationContext *VHDLParser::Element_subtype_definitionContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

size_t VHDLParser::Element_subtype_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleElement_subtype_definition;
}

void VHDLParser::Element_subtype_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterElement_subtype_definition(this);
}

void VHDLParser::Element_subtype_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitElement_subtype_definition(this);
}

std::any VHDLParser::Element_subtype_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitElement_subtype_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Element_subtype_definitionContext *VHDLParser::element_subtype_definition()
{
    Element_subtype_definitionContext *_localctx = _tracker.createInstance<Element_subtype_definitionContext>(_ctx, getState());
    enterRule(_localctx, 156, VHDLParser::RuleElement_subtype_definition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1123);
        subtype_indication();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Entity_aspectContext
//------------------------------------------------------------------

VHDLParser::Entity_aspectContext::Entity_aspectContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Entity_aspectContext::ENTITY()
{
    return getToken(VHDLParser::ENTITY, 0);
}

VHDLParser::NameContext *VHDLParser::Entity_aspectContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

tree::TerminalNode *VHDLParser::Entity_aspectContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::IdentifierContext *VHDLParser::Entity_aspectContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Entity_aspectContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

tree::TerminalNode *VHDLParser::Entity_aspectContext::CONFIGURATION()
{
    return getToken(VHDLParser::CONFIGURATION, 0);
}

tree::TerminalNode *VHDLParser::Entity_aspectContext::OPEN()
{
    return getToken(VHDLParser::OPEN, 0);
}

size_t VHDLParser::Entity_aspectContext::getRuleIndex() const
{
    return VHDLParser::RuleEntity_aspect;
}

void VHDLParser::Entity_aspectContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterEntity_aspect(this);
}

void VHDLParser::Entity_aspectContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitEntity_aspect(this);
}

std::any VHDLParser::Entity_aspectContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitEntity_aspect(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Entity_aspectContext *VHDLParser::entity_aspect()
{
    Entity_aspectContext *_localctx = _tracker.createInstance<Entity_aspectContext>(_ctx, getState());
    enterRule(_localctx, 158, VHDLParser::RuleEntity_aspect);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1136);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::ENTITY: {
            enterOuterAlt(_localctx, 1);
            setState(1125);
            match(VHDLParser::ENTITY);
            setState(1126);
            name();
            setState(1131);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == VHDLParser::LPAREN)
            {
                setState(1127);
                match(VHDLParser::LPAREN);
                setState(1128);
                identifier();
                setState(1129);
                match(VHDLParser::RPAREN);
            }
            break;
        }

        case VHDLParser::CONFIGURATION: {
            enterOuterAlt(_localctx, 2);
            setState(1133);
            match(VHDLParser::CONFIGURATION);
            setState(1134);
            name();
            break;
        }

        case VHDLParser::OPEN: {
            enterOuterAlt(_localctx, 3);
            setState(1135);
            match(VHDLParser::OPEN);
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Entity_classContext
//------------------------------------------------------------------

VHDLParser::Entity_classContext::Entity_classContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Entity_classContext::ENTITY()
{
    return getToken(VHDLParser::ENTITY, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::ARCHITECTURE()
{
    return getToken(VHDLParser::ARCHITECTURE, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::CONFIGURATION()
{
    return getToken(VHDLParser::CONFIGURATION, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::PROCEDURE()
{
    return getToken(VHDLParser::PROCEDURE, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::FUNCTION()
{
    return getToken(VHDLParser::FUNCTION, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::PACKAGE()
{
    return getToken(VHDLParser::PACKAGE, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::TYPE()
{
    return getToken(VHDLParser::TYPE, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::SUBTYPE()
{
    return getToken(VHDLParser::SUBTYPE, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::CONSTANT()
{
    return getToken(VHDLParser::CONSTANT, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::SIGNAL()
{
    return getToken(VHDLParser::SIGNAL, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::VARIABLE()
{
    return getToken(VHDLParser::VARIABLE, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::COMPONENT()
{
    return getToken(VHDLParser::COMPONENT, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::LABEL()
{
    return getToken(VHDLParser::LABEL, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::LITERAL()
{
    return getToken(VHDLParser::LITERAL, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::UNITS()
{
    return getToken(VHDLParser::UNITS, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::GROUP()
{
    return getToken(VHDLParser::GROUP, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::FILE()
{
    return getToken(VHDLParser::FILE, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::NATURE()
{
    return getToken(VHDLParser::NATURE, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::SUBNATURE()
{
    return getToken(VHDLParser::SUBNATURE, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::QUANTITY()
{
    return getToken(VHDLParser::QUANTITY, 0);
}

tree::TerminalNode *VHDLParser::Entity_classContext::TERMINAL()
{
    return getToken(VHDLParser::TERMINAL, 0);
}

size_t VHDLParser::Entity_classContext::getRuleIndex() const
{
    return VHDLParser::RuleEntity_class;
}

void VHDLParser::Entity_classContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterEntity_class(this);
}

void VHDLParser::Entity_classContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitEntity_class(this);
}

std::any VHDLParser::Entity_classContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitEntity_class(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Entity_classContext *VHDLParser::entity_class()
{
    Entity_classContext *_localctx = _tracker.createInstance<Entity_classContext>(_ctx, getState());
    enterRule(_localctx, 160, VHDLParser::RuleEntity_class);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1138);
        _la = _input->LA(1);
        if (!((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 2326586505822464) != 0) || ((((_la - 64) & ~0x3fULL) == 0) && ((1ULL << (_la - 64)) & 2544503881873) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Entity_class_entryContext
//------------------------------------------------------------------

VHDLParser::Entity_class_entryContext::Entity_class_entryContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Entity_classContext *VHDLParser::Entity_class_entryContext::entity_class()
{
    return getRuleContext<VHDLParser::Entity_classContext>(0);
}

tree::TerminalNode *VHDLParser::Entity_class_entryContext::BOX()
{
    return getToken(VHDLParser::BOX, 0);
}

size_t VHDLParser::Entity_class_entryContext::getRuleIndex() const
{
    return VHDLParser::RuleEntity_class_entry;
}

void VHDLParser::Entity_class_entryContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterEntity_class_entry(this);
}

void VHDLParser::Entity_class_entryContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitEntity_class_entry(this);
}

std::any VHDLParser::Entity_class_entryContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitEntity_class_entry(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Entity_class_entryContext *VHDLParser::entity_class_entry()
{
    Entity_class_entryContext *_localctx = _tracker.createInstance<Entity_class_entryContext>(_ctx, getState());
    enterRule(_localctx, 162, VHDLParser::RuleEntity_class_entry);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1140);
        entity_class();
        setState(1142);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BOX)
        {
            setState(1141);
            match(VHDLParser::BOX);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Entity_class_entry_listContext
//------------------------------------------------------------------

VHDLParser::Entity_class_entry_listContext::Entity_class_entry_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Entity_class_entryContext *> VHDLParser::Entity_class_entry_listContext::entity_class_entry()
{
    return getRuleContexts<VHDLParser::Entity_class_entryContext>();
}

VHDLParser::Entity_class_entryContext *VHDLParser::Entity_class_entry_listContext::entity_class_entry(size_t i)
{
    return getRuleContext<VHDLParser::Entity_class_entryContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Entity_class_entry_listContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Entity_class_entry_listContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

size_t VHDLParser::Entity_class_entry_listContext::getRuleIndex() const
{
    return VHDLParser::RuleEntity_class_entry_list;
}

void VHDLParser::Entity_class_entry_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterEntity_class_entry_list(this);
}

void VHDLParser::Entity_class_entry_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitEntity_class_entry_list(this);
}

std::any VHDLParser::Entity_class_entry_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitEntity_class_entry_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Entity_class_entry_listContext *VHDLParser::entity_class_entry_list()
{
    Entity_class_entry_listContext *_localctx = _tracker.createInstance<Entity_class_entry_listContext>(_ctx, getState());
    enterRule(_localctx, 164, VHDLParser::RuleEntity_class_entry_list);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1144);
        entity_class_entry();
        setState(1149);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::COMMA)
        {
            setState(1145);
            match(VHDLParser::COMMA);
            setState(1146);
            entity_class_entry();
            setState(1151);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Entity_declarationContext
//------------------------------------------------------------------

VHDLParser::Entity_declarationContext::Entity_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::Entity_declarationContext::ENTITY()
{
    return getTokens(VHDLParser::ENTITY);
}

tree::TerminalNode *VHDLParser::Entity_declarationContext::ENTITY(size_t i)
{
    return getToken(VHDLParser::ENTITY, i);
}

std::vector<VHDLParser::IdentifierContext *> VHDLParser::Entity_declarationContext::identifier()
{
    return getRuleContexts<VHDLParser::IdentifierContext>();
}

VHDLParser::IdentifierContext *VHDLParser::Entity_declarationContext::identifier(size_t i)
{
    return getRuleContext<VHDLParser::IdentifierContext>(i);
}

tree::TerminalNode *VHDLParser::Entity_declarationContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::Entity_headerContext *VHDLParser::Entity_declarationContext::entity_header()
{
    return getRuleContext<VHDLParser::Entity_headerContext>(0);
}

VHDLParser::Entity_declarative_partContext *VHDLParser::Entity_declarationContext::entity_declarative_part()
{
    return getRuleContext<VHDLParser::Entity_declarative_partContext>(0);
}

tree::TerminalNode *VHDLParser::Entity_declarationContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::Entity_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

tree::TerminalNode *VHDLParser::Entity_declarationContext::BEGIN()
{
    return getToken(VHDLParser::BEGIN, 0);
}

VHDLParser::Entity_statement_partContext *VHDLParser::Entity_declarationContext::entity_statement_part()
{
    return getRuleContext<VHDLParser::Entity_statement_partContext>(0);
}

size_t VHDLParser::Entity_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleEntity_declaration;
}

void VHDLParser::Entity_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterEntity_declaration(this);
}

void VHDLParser::Entity_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitEntity_declaration(this);
}

std::any VHDLParser::Entity_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitEntity_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Entity_declarationContext *VHDLParser::entity_declaration()
{
    Entity_declarationContext *_localctx = _tracker.createInstance<Entity_declarationContext>(_ctx, getState());
    enterRule(_localctx, 166, VHDLParser::RuleEntity_declaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1152);
        match(VHDLParser::ENTITY);
        setState(1153);
        identifier();
        setState(1154);
        match(VHDLParser::IS);
        setState(1155);
        entity_header();
        setState(1156);
        entity_declarative_part();
        setState(1159);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BEGIN)
        {
            setState(1157);
            match(VHDLParser::BEGIN);
            setState(1158);
            entity_statement_part();
        }
        setState(1161);
        match(VHDLParser::END);
        setState(1163);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::ENTITY)
        {
            setState(1162);
            match(VHDLParser::ENTITY);
        }
        setState(1166);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1165);
            identifier();
        }
        setState(1168);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Entity_declarative_itemContext
//------------------------------------------------------------------

VHDLParser::Entity_declarative_itemContext::Entity_declarative_itemContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Subprogram_declarationContext *VHDLParser::Entity_declarative_itemContext::subprogram_declaration()
{
    return getRuleContext<VHDLParser::Subprogram_declarationContext>(0);
}

VHDLParser::Subprogram_bodyContext *VHDLParser::Entity_declarative_itemContext::subprogram_body()
{
    return getRuleContext<VHDLParser::Subprogram_bodyContext>(0);
}

VHDLParser::Type_declarationContext *VHDLParser::Entity_declarative_itemContext::type_declaration()
{
    return getRuleContext<VHDLParser::Type_declarationContext>(0);
}

VHDLParser::Subtype_declarationContext *VHDLParser::Entity_declarative_itemContext::subtype_declaration()
{
    return getRuleContext<VHDLParser::Subtype_declarationContext>(0);
}

VHDLParser::Constant_declarationContext *VHDLParser::Entity_declarative_itemContext::constant_declaration()
{
    return getRuleContext<VHDLParser::Constant_declarationContext>(0);
}

VHDLParser::Signal_declarationContext *VHDLParser::Entity_declarative_itemContext::signal_declaration()
{
    return getRuleContext<VHDLParser::Signal_declarationContext>(0);
}

VHDLParser::Variable_declarationContext *VHDLParser::Entity_declarative_itemContext::variable_declaration()
{
    return getRuleContext<VHDLParser::Variable_declarationContext>(0);
}

VHDLParser::File_declarationContext *VHDLParser::Entity_declarative_itemContext::file_declaration()
{
    return getRuleContext<VHDLParser::File_declarationContext>(0);
}

VHDLParser::Alias_declarationContext *VHDLParser::Entity_declarative_itemContext::alias_declaration()
{
    return getRuleContext<VHDLParser::Alias_declarationContext>(0);
}

VHDLParser::Attribute_declarationContext *VHDLParser::Entity_declarative_itemContext::attribute_declaration()
{
    return getRuleContext<VHDLParser::Attribute_declarationContext>(0);
}

VHDLParser::Attribute_specificationContext *VHDLParser::Entity_declarative_itemContext::attribute_specification()
{
    return getRuleContext<VHDLParser::Attribute_specificationContext>(0);
}

VHDLParser::Disconnection_specificationContext *VHDLParser::Entity_declarative_itemContext::disconnection_specification()
{
    return getRuleContext<VHDLParser::Disconnection_specificationContext>(0);
}

VHDLParser::Step_limit_specificationContext *VHDLParser::Entity_declarative_itemContext::step_limit_specification()
{
    return getRuleContext<VHDLParser::Step_limit_specificationContext>(0);
}

VHDLParser::Use_clauseContext *VHDLParser::Entity_declarative_itemContext::use_clause()
{
    return getRuleContext<VHDLParser::Use_clauseContext>(0);
}

VHDLParser::Group_template_declarationContext *VHDLParser::Entity_declarative_itemContext::group_template_declaration()
{
    return getRuleContext<VHDLParser::Group_template_declarationContext>(0);
}

VHDLParser::Group_declarationContext *VHDLParser::Entity_declarative_itemContext::group_declaration()
{
    return getRuleContext<VHDLParser::Group_declarationContext>(0);
}

VHDLParser::Nature_declarationContext *VHDLParser::Entity_declarative_itemContext::nature_declaration()
{
    return getRuleContext<VHDLParser::Nature_declarationContext>(0);
}

VHDLParser::Subnature_declarationContext *VHDLParser::Entity_declarative_itemContext::subnature_declaration()
{
    return getRuleContext<VHDLParser::Subnature_declarationContext>(0);
}

VHDLParser::Quantity_declarationContext *VHDLParser::Entity_declarative_itemContext::quantity_declaration()
{
    return getRuleContext<VHDLParser::Quantity_declarationContext>(0);
}

VHDLParser::Terminal_declarationContext *VHDLParser::Entity_declarative_itemContext::terminal_declaration()
{
    return getRuleContext<VHDLParser::Terminal_declarationContext>(0);
}

size_t VHDLParser::Entity_declarative_itemContext::getRuleIndex() const
{
    return VHDLParser::RuleEntity_declarative_item;
}

void VHDLParser::Entity_declarative_itemContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterEntity_declarative_item(this);
}

void VHDLParser::Entity_declarative_itemContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitEntity_declarative_item(this);
}

std::any VHDLParser::Entity_declarative_itemContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitEntity_declarative_item(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Entity_declarative_itemContext *VHDLParser::entity_declarative_item()
{
    Entity_declarative_itemContext *_localctx = _tracker.createInstance<Entity_declarative_itemContext>(_ctx, getState());
    enterRule(_localctx, 168, VHDLParser::RuleEntity_declarative_item);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1190);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(1170);
            subprogram_declaration();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(1171);
            subprogram_body();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(1172);
            type_declaration();
            break;
        }

        case 4: {
            enterOuterAlt(_localctx, 4);
            setState(1173);
            subtype_declaration();
            break;
        }

        case 5: {
            enterOuterAlt(_localctx, 5);
            setState(1174);
            constant_declaration();
            break;
        }

        case 6: {
            enterOuterAlt(_localctx, 6);
            setState(1175);
            signal_declaration();
            break;
        }

        case 7: {
            enterOuterAlt(_localctx, 7);
            setState(1176);
            variable_declaration();
            break;
        }

        case 8: {
            enterOuterAlt(_localctx, 8);
            setState(1177);
            file_declaration();
            break;
        }

        case 9: {
            enterOuterAlt(_localctx, 9);
            setState(1178);
            alias_declaration();
            break;
        }

        case 10: {
            enterOuterAlt(_localctx, 10);
            setState(1179);
            attribute_declaration();
            break;
        }

        case 11: {
            enterOuterAlt(_localctx, 11);
            setState(1180);
            attribute_specification();
            break;
        }

        case 12: {
            enterOuterAlt(_localctx, 12);
            setState(1181);
            disconnection_specification();
            break;
        }

        case 13: {
            enterOuterAlt(_localctx, 13);
            setState(1182);
            step_limit_specification();
            break;
        }

        case 14: {
            enterOuterAlt(_localctx, 14);
            setState(1183);
            use_clause();
            break;
        }

        case 15: {
            enterOuterAlt(_localctx, 15);
            setState(1184);
            group_template_declaration();
            break;
        }

        case 16: {
            enterOuterAlt(_localctx, 16);
            setState(1185);
            group_declaration();
            break;
        }

        case 17: {
            enterOuterAlt(_localctx, 17);
            setState(1186);
            nature_declaration();
            break;
        }

        case 18: {
            enterOuterAlt(_localctx, 18);
            setState(1187);
            subnature_declaration();
            break;
        }

        case 19: {
            enterOuterAlt(_localctx, 19);
            setState(1188);
            quantity_declaration();
            break;
        }

        case 20: {
            enterOuterAlt(_localctx, 20);
            setState(1189);
            terminal_declaration();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Entity_declarative_partContext
//------------------------------------------------------------------

VHDLParser::Entity_declarative_partContext::Entity_declarative_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Entity_declarative_itemContext *> VHDLParser::Entity_declarative_partContext::entity_declarative_item()
{
    return getRuleContexts<VHDLParser::Entity_declarative_itemContext>();
}

VHDLParser::Entity_declarative_itemContext *VHDLParser::Entity_declarative_partContext::entity_declarative_item(size_t i)
{
    return getRuleContext<VHDLParser::Entity_declarative_itemContext>(i);
}

size_t VHDLParser::Entity_declarative_partContext::getRuleIndex() const
{
    return VHDLParser::RuleEntity_declarative_part;
}

void VHDLParser::Entity_declarative_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterEntity_declarative_part(this);
}

void VHDLParser::Entity_declarative_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitEntity_declarative_part(this);
}

std::any VHDLParser::Entity_declarative_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitEntity_declarative_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Entity_declarative_partContext *VHDLParser::entity_declarative_part()
{
    Entity_declarative_partContext *_localctx = _tracker.createInstance<Entity_declarative_partContext>(_ctx, getState());
    enterRule(_localctx, 170, VHDLParser::RuleEntity_declarative_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1195);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 2269549309200416) != 0) || ((((_la - 68) & ~0x3fULL) == 0) && ((1ULL << (_la - 68)) & 210571231245) != 0))
        {
            setState(1192);
            entity_declarative_item();
            setState(1197);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Entity_designatorContext
//------------------------------------------------------------------

VHDLParser::Entity_designatorContext::Entity_designatorContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Entity_tagContext *VHDLParser::Entity_designatorContext::entity_tag()
{
    return getRuleContext<VHDLParser::Entity_tagContext>(0);
}

VHDLParser::SignatureContext *VHDLParser::Entity_designatorContext::signature()
{
    return getRuleContext<VHDLParser::SignatureContext>(0);
}

size_t VHDLParser::Entity_designatorContext::getRuleIndex() const
{
    return VHDLParser::RuleEntity_designator;
}

void VHDLParser::Entity_designatorContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterEntity_designator(this);
}

void VHDLParser::Entity_designatorContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitEntity_designator(this);
}

std::any VHDLParser::Entity_designatorContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitEntity_designator(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Entity_designatorContext *VHDLParser::entity_designator()
{
    Entity_designatorContext *_localctx = _tracker.createInstance<Entity_designatorContext>(_ctx, getState());
    enterRule(_localctx, 172, VHDLParser::RuleEntity_designator);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1198);
        entity_tag();
        setState(1200);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::LBRACKET)
        {
            setState(1199);
            signature();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Entity_headerContext
//------------------------------------------------------------------

VHDLParser::Entity_headerContext::Entity_headerContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Generic_clauseContext *VHDLParser::Entity_headerContext::generic_clause()
{
    return getRuleContext<VHDLParser::Generic_clauseContext>(0);
}

VHDLParser::Port_clauseContext *VHDLParser::Entity_headerContext::port_clause()
{
    return getRuleContext<VHDLParser::Port_clauseContext>(0);
}

size_t VHDLParser::Entity_headerContext::getRuleIndex() const
{
    return VHDLParser::RuleEntity_header;
}

void VHDLParser::Entity_headerContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterEntity_header(this);
}

void VHDLParser::Entity_headerContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitEntity_header(this);
}

std::any VHDLParser::Entity_headerContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitEntity_header(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Entity_headerContext *VHDLParser::entity_header()
{
    Entity_headerContext *_localctx = _tracker.createInstance<Entity_headerContext>(_ctx, getState());
    enterRule(_localctx, 174, VHDLParser::RuleEntity_header);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1203);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::GENERIC)
        {
            setState(1202);
            generic_clause();
        }
        setState(1206);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::PORT)
        {
            setState(1205);
            port_clause();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Entity_name_listContext
//------------------------------------------------------------------

VHDLParser::Entity_name_listContext::Entity_name_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Entity_designatorContext *> VHDLParser::Entity_name_listContext::entity_designator()
{
    return getRuleContexts<VHDLParser::Entity_designatorContext>();
}

VHDLParser::Entity_designatorContext *VHDLParser::Entity_name_listContext::entity_designator(size_t i)
{
    return getRuleContext<VHDLParser::Entity_designatorContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Entity_name_listContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Entity_name_listContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

tree::TerminalNode *VHDLParser::Entity_name_listContext::OTHERS()
{
    return getToken(VHDLParser::OTHERS, 0);
}

tree::TerminalNode *VHDLParser::Entity_name_listContext::ALL()
{
    return getToken(VHDLParser::ALL, 0);
}

size_t VHDLParser::Entity_name_listContext::getRuleIndex() const
{
    return VHDLParser::RuleEntity_name_list;
}

void VHDLParser::Entity_name_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterEntity_name_list(this);
}

void VHDLParser::Entity_name_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitEntity_name_list(this);
}

std::any VHDLParser::Entity_name_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitEntity_name_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Entity_name_listContext *VHDLParser::entity_name_list()
{
    Entity_name_listContext *_localctx = _tracker.createInstance<Entity_name_listContext>(_ctx, getState());
    enterRule(_localctx, 176, VHDLParser::RuleEntity_name_list);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1218);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER:
        case VHDLParser::CHARACTER_LITERAL:
        case VHDLParser::STRING_LITERAL: {
            enterOuterAlt(_localctx, 1);
            setState(1208);
            entity_designator();
            setState(1213);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == VHDLParser::COMMA)
            {
                setState(1209);
                match(VHDLParser::COMMA);
                setState(1210);
                entity_designator();
                setState(1215);
                _errHandler->sync(this);
                _la = _input->LA(1);
            }
            break;
        }

        case VHDLParser::OTHERS: {
            enterOuterAlt(_localctx, 2);
            setState(1216);
            match(VHDLParser::OTHERS);
            break;
        }

        case VHDLParser::ALL: {
            enterOuterAlt(_localctx, 3);
            setState(1217);
            match(VHDLParser::ALL);
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Entity_specificationContext
//------------------------------------------------------------------

VHDLParser::Entity_specificationContext::Entity_specificationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Entity_name_listContext *VHDLParser::Entity_specificationContext::entity_name_list()
{
    return getRuleContext<VHDLParser::Entity_name_listContext>(0);
}

tree::TerminalNode *VHDLParser::Entity_specificationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Entity_classContext *VHDLParser::Entity_specificationContext::entity_class()
{
    return getRuleContext<VHDLParser::Entity_classContext>(0);
}

size_t VHDLParser::Entity_specificationContext::getRuleIndex() const
{
    return VHDLParser::RuleEntity_specification;
}

void VHDLParser::Entity_specificationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterEntity_specification(this);
}

void VHDLParser::Entity_specificationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitEntity_specification(this);
}

std::any VHDLParser::Entity_specificationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitEntity_specification(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Entity_specificationContext *VHDLParser::entity_specification()
{
    Entity_specificationContext *_localctx = _tracker.createInstance<Entity_specificationContext>(_ctx, getState());
    enterRule(_localctx, 178, VHDLParser::RuleEntity_specification);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1220);
        entity_name_list();
        setState(1221);
        match(VHDLParser::COLON);
        setState(1222);
        entity_class();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Entity_statementContext
//------------------------------------------------------------------

VHDLParser::Entity_statementContext::Entity_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Concurrent_assertion_statementContext *VHDLParser::Entity_statementContext::concurrent_assertion_statement()
{
    return getRuleContext<VHDLParser::Concurrent_assertion_statementContext>(0);
}

VHDLParser::Process_statementContext *VHDLParser::Entity_statementContext::process_statement()
{
    return getRuleContext<VHDLParser::Process_statementContext>(0);
}

VHDLParser::Concurrent_procedure_call_statementContext *VHDLParser::Entity_statementContext::concurrent_procedure_call_statement()
{
    return getRuleContext<VHDLParser::Concurrent_procedure_call_statementContext>(0);
}

size_t VHDLParser::Entity_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleEntity_statement;
}

void VHDLParser::Entity_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterEntity_statement(this);
}

void VHDLParser::Entity_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitEntity_statement(this);
}

std::any VHDLParser::Entity_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitEntity_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Entity_statementContext *VHDLParser::entity_statement()
{
    Entity_statementContext *_localctx = _tracker.createInstance<Entity_statementContext>(_ctx, getState());
    enterRule(_localctx, 180, VHDLParser::RuleEntity_statement);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1227);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(1224);
            concurrent_assertion_statement();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(1225);
            process_statement();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(1226);
            concurrent_procedure_call_statement();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Entity_statement_partContext
//------------------------------------------------------------------

VHDLParser::Entity_statement_partContext::Entity_statement_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Entity_statementContext *> VHDLParser::Entity_statement_partContext::entity_statement()
{
    return getRuleContexts<VHDLParser::Entity_statementContext>();
}

VHDLParser::Entity_statementContext *VHDLParser::Entity_statement_partContext::entity_statement(size_t i)
{
    return getRuleContext<VHDLParser::Entity_statementContext>(i);
}

size_t VHDLParser::Entity_statement_partContext::getRuleIndex() const
{
    return VHDLParser::RuleEntity_statement_part;
}

void VHDLParser::Entity_statement_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterEntity_statement_part(this);
}

void VHDLParser::Entity_statement_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitEntity_statement_part(this);
}

std::any VHDLParser::Entity_statement_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitEntity_statement_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Entity_statement_partContext *VHDLParser::entity_statement_part()
{
    Entity_statement_partContext *_localctx = _tracker.createInstance<Entity_statement_partContext>(_ctx, getState());
    enterRule(_localctx, 182, VHDLParser::RuleEntity_statement_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1232);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::ASSERT || ((((_la - 66) & ~0x3fULL) == 0) && ((1ULL << (_la - 66)) & 13510798882111491) != 0))
        {
            setState(1229);
            entity_statement();
            setState(1234);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Entity_tagContext
//------------------------------------------------------------------

VHDLParser::Entity_tagContext::Entity_tagContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::IdentifierContext *VHDLParser::Entity_tagContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Entity_tagContext::CHARACTER_LITERAL()
{
    return getToken(VHDLParser::CHARACTER_LITERAL, 0);
}

tree::TerminalNode *VHDLParser::Entity_tagContext::STRING_LITERAL()
{
    return getToken(VHDLParser::STRING_LITERAL, 0);
}

size_t VHDLParser::Entity_tagContext::getRuleIndex() const
{
    return VHDLParser::RuleEntity_tag;
}

void VHDLParser::Entity_tagContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterEntity_tag(this);
}

void VHDLParser::Entity_tagContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitEntity_tag(this);
}

std::any VHDLParser::Entity_tagContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitEntity_tag(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Entity_tagContext *VHDLParser::entity_tag()
{
    Entity_tagContext *_localctx = _tracker.createInstance<Entity_tagContext>(_ctx, getState());
    enterRule(_localctx, 184, VHDLParser::RuleEntity_tag);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1238);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER: {
            enterOuterAlt(_localctx, 1);
            setState(1235);
            identifier();
            break;
        }

        case VHDLParser::CHARACTER_LITERAL: {
            enterOuterAlt(_localctx, 2);
            setState(1236);
            match(VHDLParser::CHARACTER_LITERAL);
            break;
        }

        case VHDLParser::STRING_LITERAL: {
            enterOuterAlt(_localctx, 3);
            setState(1237);
            match(VHDLParser::STRING_LITERAL);
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Enumeration_literalContext
//------------------------------------------------------------------

VHDLParser::Enumeration_literalContext::Enumeration_literalContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::IdentifierContext *VHDLParser::Enumeration_literalContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Enumeration_literalContext::CHARACTER_LITERAL()
{
    return getToken(VHDLParser::CHARACTER_LITERAL, 0);
}

size_t VHDLParser::Enumeration_literalContext::getRuleIndex() const
{
    return VHDLParser::RuleEnumeration_literal;
}

void VHDLParser::Enumeration_literalContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterEnumeration_literal(this);
}

void VHDLParser::Enumeration_literalContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitEnumeration_literal(this);
}

std::any VHDLParser::Enumeration_literalContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitEnumeration_literal(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Enumeration_literalContext *VHDLParser::enumeration_literal()
{
    Enumeration_literalContext *_localctx = _tracker.createInstance<Enumeration_literalContext>(_ctx, getState());
    enterRule(_localctx, 186, VHDLParser::RuleEnumeration_literal);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1242);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER: {
            enterOuterAlt(_localctx, 1);
            setState(1240);
            identifier();
            break;
        }

        case VHDLParser::CHARACTER_LITERAL: {
            enterOuterAlt(_localctx, 2);
            setState(1241);
            match(VHDLParser::CHARACTER_LITERAL);
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Enumeration_type_definitionContext
//------------------------------------------------------------------

VHDLParser::Enumeration_type_definitionContext::Enumeration_type_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Enumeration_type_definitionContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

std::vector<VHDLParser::Enumeration_literalContext *> VHDLParser::Enumeration_type_definitionContext::enumeration_literal()
{
    return getRuleContexts<VHDLParser::Enumeration_literalContext>();
}

VHDLParser::Enumeration_literalContext *VHDLParser::Enumeration_type_definitionContext::enumeration_literal(size_t i)
{
    return getRuleContext<VHDLParser::Enumeration_literalContext>(i);
}

tree::TerminalNode *VHDLParser::Enumeration_type_definitionContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

std::vector<tree::TerminalNode *> VHDLParser::Enumeration_type_definitionContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Enumeration_type_definitionContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

size_t VHDLParser::Enumeration_type_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleEnumeration_type_definition;
}

void VHDLParser::Enumeration_type_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterEnumeration_type_definition(this);
}

void VHDLParser::Enumeration_type_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitEnumeration_type_definition(this);
}

std::any VHDLParser::Enumeration_type_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitEnumeration_type_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Enumeration_type_definitionContext *VHDLParser::enumeration_type_definition()
{
    Enumeration_type_definitionContext *_localctx = _tracker.createInstance<Enumeration_type_definitionContext>(_ctx, getState());
    enterRule(_localctx, 188, VHDLParser::RuleEnumeration_type_definition);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1244);
        match(VHDLParser::LPAREN);
        setState(1245);
        enumeration_literal();
        setState(1250);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::COMMA)
        {
            setState(1246);
            match(VHDLParser::COMMA);
            setState(1247);
            enumeration_literal();
            setState(1252);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(1253);
        match(VHDLParser::RPAREN);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Exit_statementContext
//------------------------------------------------------------------

VHDLParser::Exit_statementContext::Exit_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Exit_statementContext::EXIT()
{
    return getToken(VHDLParser::EXIT, 0);
}

tree::TerminalNode *VHDLParser::Exit_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Exit_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

VHDLParser::IdentifierContext *VHDLParser::Exit_statementContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Exit_statementContext::WHEN()
{
    return getToken(VHDLParser::WHEN, 0);
}

VHDLParser::ConditionContext *VHDLParser::Exit_statementContext::condition()
{
    return getRuleContext<VHDLParser::ConditionContext>(0);
}

size_t VHDLParser::Exit_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleExit_statement;
}

void VHDLParser::Exit_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterExit_statement(this);
}

void VHDLParser::Exit_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitExit_statement(this);
}

std::any VHDLParser::Exit_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitExit_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Exit_statementContext *VHDLParser::exit_statement()
{
    Exit_statementContext *_localctx = _tracker.createInstance<Exit_statementContext>(_ctx, getState());
    enterRule(_localctx, 190, VHDLParser::RuleExit_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1256);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1255);
            label_colon();
        }
        setState(1258);
        match(VHDLParser::EXIT);
        setState(1260);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1259);
            identifier();
        }
        setState(1264);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::WHEN)
        {
            setState(1262);
            match(VHDLParser::WHEN);
            setState(1263);
            condition();
        }
        setState(1266);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ExpressionContext
//------------------------------------------------------------------

VHDLParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::RelationContext *> VHDLParser::ExpressionContext::relation()
{
    return getRuleContexts<VHDLParser::RelationContext>();
}

VHDLParser::RelationContext *VHDLParser::ExpressionContext::relation(size_t i)
{
    return getRuleContext<VHDLParser::RelationContext>(i);
}

std::vector<VHDLParser::Logical_operatorContext *> VHDLParser::ExpressionContext::logical_operator()
{
    return getRuleContexts<VHDLParser::Logical_operatorContext>();
}

VHDLParser::Logical_operatorContext *VHDLParser::ExpressionContext::logical_operator(size_t i)
{
    return getRuleContext<VHDLParser::Logical_operatorContext>(i);
}

size_t VHDLParser::ExpressionContext::getRuleIndex() const
{
    return VHDLParser::RuleExpression;
}

void VHDLParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterExpression(this);
}

void VHDLParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitExpression(this);
}

std::any VHDLParser::ExpressionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitExpression(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::ExpressionContext *VHDLParser::expression()
{
    ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, getState());
    enterRule(_localctx, 192, VHDLParser::RuleExpression);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(1268);
        relation();
        setState(1274);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(1269);
                logical_operator();
                setState(1270);
                relation();
            }
            setState(1276);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FactorContext
//------------------------------------------------------------------

VHDLParser::FactorContext::FactorContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::PrimaryContext *> VHDLParser::FactorContext::primary()
{
    return getRuleContexts<VHDLParser::PrimaryContext>();
}

VHDLParser::PrimaryContext *VHDLParser::FactorContext::primary(size_t i)
{
    return getRuleContext<VHDLParser::PrimaryContext>(i);
}

tree::TerminalNode *VHDLParser::FactorContext::DOUBLESTAR()
{
    return getToken(VHDLParser::DOUBLESTAR, 0);
}

tree::TerminalNode *VHDLParser::FactorContext::ABS()
{
    return getToken(VHDLParser::ABS, 0);
}

tree::TerminalNode *VHDLParser::FactorContext::NOT()
{
    return getToken(VHDLParser::NOT, 0);
}

size_t VHDLParser::FactorContext::getRuleIndex() const
{
    return VHDLParser::RuleFactor;
}

void VHDLParser::FactorContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterFactor(this);
}

void VHDLParser::FactorContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitFactor(this);
}

std::any VHDLParser::FactorContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitFactor(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::FactorContext *VHDLParser::factor()
{
    FactorContext *_localctx = _tracker.createInstance<FactorContext>(_ctx, getState());
    enterRule(_localctx, 194, VHDLParser::RuleFactor);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1286);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::NEW:
        case VHDLParser::NULL_:
        case VHDLParser::BASE_LITERAL:
        case VHDLParser::BIT_STRING_LITERAL:
        case VHDLParser::REAL_LITERAL:
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER:
        case VHDLParser::CHARACTER_LITERAL:
        case VHDLParser::STRING_LITERAL:
        case VHDLParser::LPAREN:
        case VHDLParser::INTEGER: {
            enterOuterAlt(_localctx, 1);
            setState(1277);
            primary();
            setState(1280);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx))
            {
            case 1: {
                setState(1278);
                match(VHDLParser::DOUBLESTAR);
                setState(1279);
                primary();
                break;
            }

            default:
                break;
            }
            break;
        }

        case VHDLParser::ABS: {
            enterOuterAlt(_localctx, 2);
            setState(1282);
            match(VHDLParser::ABS);
            setState(1283);
            primary();
            break;
        }

        case VHDLParser::NOT: {
            enterOuterAlt(_localctx, 3);
            setState(1284);
            match(VHDLParser::NOT);
            setState(1285);
            primary();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- File_declarationContext
//------------------------------------------------------------------

VHDLParser::File_declarationContext::File_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::File_declarationContext::FILE()
{
    return getToken(VHDLParser::FILE, 0);
}

VHDLParser::Identifier_listContext *VHDLParser::File_declarationContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::File_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::File_declarationContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

tree::TerminalNode *VHDLParser::File_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::File_open_informationContext *VHDLParser::File_declarationContext::file_open_information()
{
    return getRuleContext<VHDLParser::File_open_informationContext>(0);
}

size_t VHDLParser::File_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleFile_declaration;
}

void VHDLParser::File_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterFile_declaration(this);
}

void VHDLParser::File_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitFile_declaration(this);
}

std::any VHDLParser::File_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitFile_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::File_declarationContext *VHDLParser::file_declaration()
{
    File_declarationContext *_localctx = _tracker.createInstance<File_declarationContext>(_ctx, getState());
    enterRule(_localctx, 196, VHDLParser::RuleFile_declaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1288);
        match(VHDLParser::FILE);
        setState(1289);
        identifier_list();
        setState(1290);
        match(VHDLParser::COLON);
        setState(1291);
        subtype_indication();
        setState(1293);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::IS

            || _la == VHDLParser::OPEN)
        {
            setState(1292);
            file_open_information();
        }
        setState(1295);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- File_logical_nameContext
//------------------------------------------------------------------

VHDLParser::File_logical_nameContext::File_logical_nameContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::ExpressionContext *VHDLParser::File_logical_nameContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::File_logical_nameContext::getRuleIndex() const
{
    return VHDLParser::RuleFile_logical_name;
}

void VHDLParser::File_logical_nameContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterFile_logical_name(this);
}

void VHDLParser::File_logical_nameContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitFile_logical_name(this);
}

std::any VHDLParser::File_logical_nameContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitFile_logical_name(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::File_logical_nameContext *VHDLParser::file_logical_name()
{
    File_logical_nameContext *_localctx = _tracker.createInstance<File_logical_nameContext>(_ctx, getState());
    enterRule(_localctx, 198, VHDLParser::RuleFile_logical_name);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1297);
        expression();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- File_open_informationContext
//------------------------------------------------------------------

VHDLParser::File_open_informationContext::File_open_informationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::File_open_informationContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::File_logical_nameContext *VHDLParser::File_open_informationContext::file_logical_name()
{
    return getRuleContext<VHDLParser::File_logical_nameContext>(0);
}

tree::TerminalNode *VHDLParser::File_open_informationContext::OPEN()
{
    return getToken(VHDLParser::OPEN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::File_open_informationContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::File_open_informationContext::getRuleIndex() const
{
    return VHDLParser::RuleFile_open_information;
}

void VHDLParser::File_open_informationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterFile_open_information(this);
}

void VHDLParser::File_open_informationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitFile_open_information(this);
}

std::any VHDLParser::File_open_informationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitFile_open_information(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::File_open_informationContext *VHDLParser::file_open_information()
{
    File_open_informationContext *_localctx = _tracker.createInstance<File_open_informationContext>(_ctx, getState());
    enterRule(_localctx, 200, VHDLParser::RuleFile_open_information);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1301);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::OPEN)
        {
            setState(1299);
            match(VHDLParser::OPEN);
            setState(1300);
            expression();
        }
        setState(1303);
        match(VHDLParser::IS);
        setState(1304);
        file_logical_name();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- File_type_definitionContext
//------------------------------------------------------------------

VHDLParser::File_type_definitionContext::File_type_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::File_type_definitionContext::FILE()
{
    return getToken(VHDLParser::FILE, 0);
}

tree::TerminalNode *VHDLParser::File_type_definitionContext::OF()
{
    return getToken(VHDLParser::OF, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::File_type_definitionContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

size_t VHDLParser::File_type_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleFile_type_definition;
}

void VHDLParser::File_type_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterFile_type_definition(this);
}

void VHDLParser::File_type_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitFile_type_definition(this);
}

std::any VHDLParser::File_type_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitFile_type_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::File_type_definitionContext *VHDLParser::file_type_definition()
{
    File_type_definitionContext *_localctx = _tracker.createInstance<File_type_definitionContext>(_ctx, getState());
    enterRule(_localctx, 202, VHDLParser::RuleFile_type_definition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1306);
        match(VHDLParser::FILE);
        setState(1307);
        match(VHDLParser::OF);
        setState(1308);
        subtype_indication();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Formal_parameter_listContext
//------------------------------------------------------------------

VHDLParser::Formal_parameter_listContext::Formal_parameter_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Interface_listContext *VHDLParser::Formal_parameter_listContext::interface_list()
{
    return getRuleContext<VHDLParser::Interface_listContext>(0);
}

size_t VHDLParser::Formal_parameter_listContext::getRuleIndex() const
{
    return VHDLParser::RuleFormal_parameter_list;
}

void VHDLParser::Formal_parameter_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterFormal_parameter_list(this);
}

void VHDLParser::Formal_parameter_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitFormal_parameter_list(this);
}

std::any VHDLParser::Formal_parameter_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitFormal_parameter_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Formal_parameter_listContext *VHDLParser::formal_parameter_list()
{
    Formal_parameter_listContext *_localctx = _tracker.createInstance<Formal_parameter_listContext>(_ctx, getState());
    enterRule(_localctx, 204, VHDLParser::RuleFormal_parameter_list);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1310);
        interface_list();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Formal_partContext
//------------------------------------------------------------------

VHDLParser::Formal_partContext::Formal_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::IdentifierContext *VHDLParser::Formal_partContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Formal_partContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::Explicit_rangeContext *VHDLParser::Formal_partContext::explicit_range()
{
    return getRuleContext<VHDLParser::Explicit_rangeContext>(0);
}

tree::TerminalNode *VHDLParser::Formal_partContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

size_t VHDLParser::Formal_partContext::getRuleIndex() const
{
    return VHDLParser::RuleFormal_part;
}

void VHDLParser::Formal_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterFormal_part(this);
}

void VHDLParser::Formal_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitFormal_part(this);
}

std::any VHDLParser::Formal_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitFormal_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Formal_partContext *VHDLParser::formal_part()
{
    Formal_partContext *_localctx = _tracker.createInstance<Formal_partContext>(_ctx, getState());
    enterRule(_localctx, 206, VHDLParser::RuleFormal_part);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1318);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(1312);
            identifier();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(1313);
            identifier();
            setState(1314);
            match(VHDLParser::LPAREN);
            setState(1315);
            explicit_range();
            setState(1316);
            match(VHDLParser::RPAREN);
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Free_quantity_declarationContext
//------------------------------------------------------------------

VHDLParser::Free_quantity_declarationContext::Free_quantity_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Free_quantity_declarationContext::QUANTITY()
{
    return getToken(VHDLParser::QUANTITY, 0);
}

VHDLParser::Identifier_listContext *VHDLParser::Free_quantity_declarationContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Free_quantity_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Free_quantity_declarationContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

tree::TerminalNode *VHDLParser::Free_quantity_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

tree::TerminalNode *VHDLParser::Free_quantity_declarationContext::VARASGN()
{
    return getToken(VHDLParser::VARASGN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Free_quantity_declarationContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::Free_quantity_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleFree_quantity_declaration;
}

void VHDLParser::Free_quantity_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterFree_quantity_declaration(this);
}

void VHDLParser::Free_quantity_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitFree_quantity_declaration(this);
}

std::any VHDLParser::Free_quantity_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitFree_quantity_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Free_quantity_declarationContext *VHDLParser::free_quantity_declaration()
{
    Free_quantity_declarationContext *_localctx = _tracker.createInstance<Free_quantity_declarationContext>(_ctx, getState());
    enterRule(_localctx, 208, VHDLParser::RuleFree_quantity_declaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1320);
        match(VHDLParser::QUANTITY);
        setState(1321);
        identifier_list();
        setState(1322);
        match(VHDLParser::COLON);
        setState(1323);
        subtype_indication();
        setState(1326);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::VARASGN)
        {
            setState(1324);
            match(VHDLParser::VARASGN);
            setState(1325);
            expression();
        }
        setState(1328);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Generate_statementContext
//------------------------------------------------------------------

VHDLParser::Generate_statementContext::Generate_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Label_colonContext *VHDLParser::Generate_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

VHDLParser::Generation_schemeContext *VHDLParser::Generate_statementContext::generation_scheme()
{
    return getRuleContext<VHDLParser::Generation_schemeContext>(0);
}

std::vector<tree::TerminalNode *> VHDLParser::Generate_statementContext::GENERATE()
{
    return getTokens(VHDLParser::GENERATE);
}

tree::TerminalNode *VHDLParser::Generate_statementContext::GENERATE(size_t i)
{
    return getToken(VHDLParser::GENERATE, i);
}

tree::TerminalNode *VHDLParser::Generate_statementContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::Generate_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

tree::TerminalNode *VHDLParser::Generate_statementContext::BEGIN()
{
    return getToken(VHDLParser::BEGIN, 0);
}

std::vector<VHDLParser::Architecture_statementContext *> VHDLParser::Generate_statementContext::architecture_statement()
{
    return getRuleContexts<VHDLParser::Architecture_statementContext>();
}

VHDLParser::Architecture_statementContext *VHDLParser::Generate_statementContext::architecture_statement(size_t i)
{
    return getRuleContext<VHDLParser::Architecture_statementContext>(i);
}

VHDLParser::IdentifierContext *VHDLParser::Generate_statementContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

std::vector<VHDLParser::Block_declarative_itemContext *> VHDLParser::Generate_statementContext::block_declarative_item()
{
    return getRuleContexts<VHDLParser::Block_declarative_itemContext>();
}

VHDLParser::Block_declarative_itemContext *VHDLParser::Generate_statementContext::block_declarative_item(size_t i)
{
    return getRuleContext<VHDLParser::Block_declarative_itemContext>(i);
}

size_t VHDLParser::Generate_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleGenerate_statement;
}

void VHDLParser::Generate_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterGenerate_statement(this);
}

void VHDLParser::Generate_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitGenerate_statement(this);
}

std::any VHDLParser::Generate_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitGenerate_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Generate_statementContext *VHDLParser::generate_statement()
{
    Generate_statementContext *_localctx = _tracker.createInstance<Generate_statementContext>(_ctx, getState());
    enterRule(_localctx, 210, VHDLParser::RuleGenerate_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1330);
        label_colon();
        setState(1331);
        generation_scheme();
        setState(1332);
        match(VHDLParser::GENERATE);
        setState(1340);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 2269550383470624) != 0) || ((((_la - 68) & ~0x3fULL) == 0) && ((1ULL << (_la - 68)) & 210571231245) != 0))
        {
            setState(1336);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 2269550383466528) != 0) || ((((_la - 68) & ~0x3fULL) == 0) && ((1ULL << (_la - 68)) & 210571231245) != 0))
            {
                setState(1333);
                block_declarative_item();
                setState(1338);
                _errHandler->sync(this);
                _la = _input->LA(1);
            }
            setState(1339);
            match(VHDLParser::BEGIN);
        }
        setState(1345);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 220676450460926978) != 0) || ((((_la - 66) & ~0x3fULL) == 0) && ((1ULL << (_la - 66)) & 3474740417772126219) != 0) ||
               ((((_la - 141) & ~0x3fULL) == 0) && ((1ULL << (_la - 141)) & 131457) != 0))
        {
            setState(1342);
            architecture_statement();
            setState(1347);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(1348);
        match(VHDLParser::END);
        setState(1349);
        match(VHDLParser::GENERATE);
        setState(1351);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1350);
            identifier();
        }
        setState(1353);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Generation_schemeContext
//------------------------------------------------------------------

VHDLParser::Generation_schemeContext::Generation_schemeContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Generation_schemeContext::FOR()
{
    return getToken(VHDLParser::FOR, 0);
}

VHDLParser::Parameter_specificationContext *VHDLParser::Generation_schemeContext::parameter_specification()
{
    return getRuleContext<VHDLParser::Parameter_specificationContext>(0);
}

tree::TerminalNode *VHDLParser::Generation_schemeContext::IF()
{
    return getToken(VHDLParser::IF, 0);
}

VHDLParser::ConditionContext *VHDLParser::Generation_schemeContext::condition()
{
    return getRuleContext<VHDLParser::ConditionContext>(0);
}

size_t VHDLParser::Generation_schemeContext::getRuleIndex() const
{
    return VHDLParser::RuleGeneration_scheme;
}

void VHDLParser::Generation_schemeContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterGeneration_scheme(this);
}

void VHDLParser::Generation_schemeContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitGeneration_scheme(this);
}

std::any VHDLParser::Generation_schemeContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitGeneration_scheme(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Generation_schemeContext *VHDLParser::generation_scheme()
{
    Generation_schemeContext *_localctx = _tracker.createInstance<Generation_schemeContext>(_ctx, getState());
    enterRule(_localctx, 212, VHDLParser::RuleGeneration_scheme);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1359);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::FOR: {
            enterOuterAlt(_localctx, 1);
            setState(1355);
            match(VHDLParser::FOR);
            setState(1356);
            parameter_specification();
            break;
        }

        case VHDLParser::IF: {
            enterOuterAlt(_localctx, 2);
            setState(1357);
            match(VHDLParser::IF);
            setState(1358);
            condition();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Generic_clauseContext
//------------------------------------------------------------------

VHDLParser::Generic_clauseContext::Generic_clauseContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Generic_clauseContext::GENERIC()
{
    return getToken(VHDLParser::GENERIC, 0);
}

tree::TerminalNode *VHDLParser::Generic_clauseContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::Generic_listContext *VHDLParser::Generic_clauseContext::generic_list()
{
    return getRuleContext<VHDLParser::Generic_listContext>(0);
}

tree::TerminalNode *VHDLParser::Generic_clauseContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

tree::TerminalNode *VHDLParser::Generic_clauseContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Generic_clauseContext::getRuleIndex() const
{
    return VHDLParser::RuleGeneric_clause;
}

void VHDLParser::Generic_clauseContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterGeneric_clause(this);
}

void VHDLParser::Generic_clauseContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitGeneric_clause(this);
}

std::any VHDLParser::Generic_clauseContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitGeneric_clause(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Generic_clauseContext *VHDLParser::generic_clause()
{
    Generic_clauseContext *_localctx = _tracker.createInstance<Generic_clauseContext>(_ctx, getState());
    enterRule(_localctx, 214, VHDLParser::RuleGeneric_clause);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1361);
        match(VHDLParser::GENERIC);
        setState(1362);
        match(VHDLParser::LPAREN);
        setState(1363);
        generic_list();
        setState(1364);
        match(VHDLParser::RPAREN);
        setState(1365);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Generic_listContext
//------------------------------------------------------------------

VHDLParser::Generic_listContext::Generic_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Interface_constant_declarationContext *> VHDLParser::Generic_listContext::interface_constant_declaration()
{
    return getRuleContexts<VHDLParser::Interface_constant_declarationContext>();
}

VHDLParser::Interface_constant_declarationContext *VHDLParser::Generic_listContext::interface_constant_declaration(size_t i)
{
    return getRuleContext<VHDLParser::Interface_constant_declarationContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Generic_listContext::SEMI()
{
    return getTokens(VHDLParser::SEMI);
}

tree::TerminalNode *VHDLParser::Generic_listContext::SEMI(size_t i)
{
    return getToken(VHDLParser::SEMI, i);
}

size_t VHDLParser::Generic_listContext::getRuleIndex() const
{
    return VHDLParser::RuleGeneric_list;
}

void VHDLParser::Generic_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterGeneric_list(this);
}

void VHDLParser::Generic_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitGeneric_list(this);
}

std::any VHDLParser::Generic_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitGeneric_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Generic_listContext *VHDLParser::generic_list()
{
    Generic_listContext *_localctx = _tracker.createInstance<Generic_listContext>(_ctx, getState());
    enterRule(_localctx, 216, VHDLParser::RuleGeneric_list);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1367);
        interface_constant_declaration();
        setState(1372);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::SEMI)
        {
            setState(1368);
            match(VHDLParser::SEMI);
            setState(1369);
            interface_constant_declaration();
            setState(1374);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Generic_map_aspectContext
//------------------------------------------------------------------

VHDLParser::Generic_map_aspectContext::Generic_map_aspectContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Generic_map_aspectContext::GENERIC()
{
    return getToken(VHDLParser::GENERIC, 0);
}

tree::TerminalNode *VHDLParser::Generic_map_aspectContext::MAP()
{
    return getToken(VHDLParser::MAP, 0);
}

tree::TerminalNode *VHDLParser::Generic_map_aspectContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::Association_listContext *VHDLParser::Generic_map_aspectContext::association_list()
{
    return getRuleContext<VHDLParser::Association_listContext>(0);
}

tree::TerminalNode *VHDLParser::Generic_map_aspectContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

size_t VHDLParser::Generic_map_aspectContext::getRuleIndex() const
{
    return VHDLParser::RuleGeneric_map_aspect;
}

void VHDLParser::Generic_map_aspectContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterGeneric_map_aspect(this);
}

void VHDLParser::Generic_map_aspectContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitGeneric_map_aspect(this);
}

std::any VHDLParser::Generic_map_aspectContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitGeneric_map_aspect(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Generic_map_aspectContext *VHDLParser::generic_map_aspect()
{
    Generic_map_aspectContext *_localctx = _tracker.createInstance<Generic_map_aspectContext>(_ctx, getState());
    enterRule(_localctx, 218, VHDLParser::RuleGeneric_map_aspect);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1375);
        match(VHDLParser::GENERIC);
        setState(1376);
        match(VHDLParser::MAP);
        setState(1377);
        match(VHDLParser::LPAREN);
        setState(1378);
        association_list();
        setState(1379);
        match(VHDLParser::RPAREN);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Group_constituentContext
//------------------------------------------------------------------

VHDLParser::Group_constituentContext::Group_constituentContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::NameContext *VHDLParser::Group_constituentContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

tree::TerminalNode *VHDLParser::Group_constituentContext::CHARACTER_LITERAL()
{
    return getToken(VHDLParser::CHARACTER_LITERAL, 0);
}

size_t VHDLParser::Group_constituentContext::getRuleIndex() const
{
    return VHDLParser::RuleGroup_constituent;
}

void VHDLParser::Group_constituentContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterGroup_constituent(this);
}

void VHDLParser::Group_constituentContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitGroup_constituent(this);
}

std::any VHDLParser::Group_constituentContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitGroup_constituent(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Group_constituentContext *VHDLParser::group_constituent()
{
    Group_constituentContext *_localctx = _tracker.createInstance<Group_constituentContext>(_ctx, getState());
    enterRule(_localctx, 220, VHDLParser::RuleGroup_constituent);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1383);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER:
        case VHDLParser::STRING_LITERAL: {
            enterOuterAlt(_localctx, 1);
            setState(1381);
            name();
            break;
        }

        case VHDLParser::CHARACTER_LITERAL: {
            enterOuterAlt(_localctx, 2);
            setState(1382);
            match(VHDLParser::CHARACTER_LITERAL);
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Group_constituent_listContext
//------------------------------------------------------------------

VHDLParser::Group_constituent_listContext::Group_constituent_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Group_constituentContext *> VHDLParser::Group_constituent_listContext::group_constituent()
{
    return getRuleContexts<VHDLParser::Group_constituentContext>();
}

VHDLParser::Group_constituentContext *VHDLParser::Group_constituent_listContext::group_constituent(size_t i)
{
    return getRuleContext<VHDLParser::Group_constituentContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Group_constituent_listContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Group_constituent_listContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

size_t VHDLParser::Group_constituent_listContext::getRuleIndex() const
{
    return VHDLParser::RuleGroup_constituent_list;
}

void VHDLParser::Group_constituent_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterGroup_constituent_list(this);
}

void VHDLParser::Group_constituent_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitGroup_constituent_list(this);
}

std::any VHDLParser::Group_constituent_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitGroup_constituent_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Group_constituent_listContext *VHDLParser::group_constituent_list()
{
    Group_constituent_listContext *_localctx = _tracker.createInstance<Group_constituent_listContext>(_ctx, getState());
    enterRule(_localctx, 222, VHDLParser::RuleGroup_constituent_list);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1385);
        group_constituent();
        setState(1390);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::COMMA)
        {
            setState(1386);
            match(VHDLParser::COMMA);
            setState(1387);
            group_constituent();
            setState(1392);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Group_declarationContext
//------------------------------------------------------------------

VHDLParser::Group_declarationContext::Group_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Group_declarationContext::GROUP()
{
    return getToken(VHDLParser::GROUP, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Group_declarationContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

VHDLParser::NameContext *VHDLParser::Group_declarationContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

tree::TerminalNode *VHDLParser::Group_declarationContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::Group_constituent_listContext *VHDLParser::Group_declarationContext::group_constituent_list()
{
    return getRuleContext<VHDLParser::Group_constituent_listContext>(0);
}

tree::TerminalNode *VHDLParser::Group_declarationContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

tree::TerminalNode *VHDLParser::Group_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Group_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleGroup_declaration;
}

void VHDLParser::Group_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterGroup_declaration(this);
}

void VHDLParser::Group_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitGroup_declaration(this);
}

std::any VHDLParser::Group_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitGroup_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Group_declarationContext *VHDLParser::group_declaration()
{
    Group_declarationContext *_localctx = _tracker.createInstance<Group_declarationContext>(_ctx, getState());
    enterRule(_localctx, 224, VHDLParser::RuleGroup_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1393);
        match(VHDLParser::GROUP);
        setState(1394);
        label_colon();
        setState(1395);
        name();
        setState(1396);
        match(VHDLParser::LPAREN);
        setState(1397);
        group_constituent_list();
        setState(1398);
        match(VHDLParser::RPAREN);
        setState(1399);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Group_template_declarationContext
//------------------------------------------------------------------

VHDLParser::Group_template_declarationContext::Group_template_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Group_template_declarationContext::GROUP()
{
    return getToken(VHDLParser::GROUP, 0);
}

VHDLParser::IdentifierContext *VHDLParser::Group_template_declarationContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Group_template_declarationContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

tree::TerminalNode *VHDLParser::Group_template_declarationContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::Entity_class_entry_listContext *VHDLParser::Group_template_declarationContext::entity_class_entry_list()
{
    return getRuleContext<VHDLParser::Entity_class_entry_listContext>(0);
}

tree::TerminalNode *VHDLParser::Group_template_declarationContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

tree::TerminalNode *VHDLParser::Group_template_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Group_template_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleGroup_template_declaration;
}

void VHDLParser::Group_template_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterGroup_template_declaration(this);
}

void VHDLParser::Group_template_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitGroup_template_declaration(this);
}

std::any VHDLParser::Group_template_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitGroup_template_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Group_template_declarationContext *VHDLParser::group_template_declaration()
{
    Group_template_declarationContext *_localctx = _tracker.createInstance<Group_template_declarationContext>(_ctx, getState());
    enterRule(_localctx, 226, VHDLParser::RuleGroup_template_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1401);
        match(VHDLParser::GROUP);
        setState(1402);
        identifier();
        setState(1403);
        match(VHDLParser::IS);
        setState(1404);
        match(VHDLParser::LPAREN);
        setState(1405);
        entity_class_entry_list();
        setState(1406);
        match(VHDLParser::RPAREN);
        setState(1407);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Guarded_signal_specificationContext
//------------------------------------------------------------------

VHDLParser::Guarded_signal_specificationContext::Guarded_signal_specificationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Signal_listContext *VHDLParser::Guarded_signal_specificationContext::signal_list()
{
    return getRuleContext<VHDLParser::Signal_listContext>(0);
}

tree::TerminalNode *VHDLParser::Guarded_signal_specificationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::NameContext *VHDLParser::Guarded_signal_specificationContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

size_t VHDLParser::Guarded_signal_specificationContext::getRuleIndex() const
{
    return VHDLParser::RuleGuarded_signal_specification;
}

void VHDLParser::Guarded_signal_specificationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterGuarded_signal_specification(this);
}

void VHDLParser::Guarded_signal_specificationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitGuarded_signal_specification(this);
}

std::any VHDLParser::Guarded_signal_specificationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitGuarded_signal_specification(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Guarded_signal_specificationContext *VHDLParser::guarded_signal_specification()
{
    Guarded_signal_specificationContext *_localctx = _tracker.createInstance<Guarded_signal_specificationContext>(_ctx, getState());
    enterRule(_localctx, 228, VHDLParser::RuleGuarded_signal_specification);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1409);
        signal_list();
        setState(1410);
        match(VHDLParser::COLON);
        setState(1411);
        name();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- IdentifierContext
//------------------------------------------------------------------

VHDLParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::IdentifierContext::BASIC_IDENTIFIER()
{
    return getToken(VHDLParser::BASIC_IDENTIFIER, 0);
}

tree::TerminalNode *VHDLParser::IdentifierContext::EXTENDED_IDENTIFIER()
{
    return getToken(VHDLParser::EXTENDED_IDENTIFIER, 0);
}

size_t VHDLParser::IdentifierContext::getRuleIndex() const
{
    return VHDLParser::RuleIdentifier;
}

void VHDLParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterIdentifier(this);
}

void VHDLParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitIdentifier(this);
}

std::any VHDLParser::IdentifierContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitIdentifier(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::IdentifierContext *VHDLParser::identifier()
{
    IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
    enterRule(_localctx, 230, VHDLParser::RuleIdentifier);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1413);
        _la = _input->LA(1);
        if (!(_la == VHDLParser::BASIC_IDENTIFIER

              || _la == VHDLParser::EXTENDED_IDENTIFIER))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Identifier_listContext
//------------------------------------------------------------------

VHDLParser::Identifier_listContext::Identifier_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::IdentifierContext *> VHDLParser::Identifier_listContext::identifier()
{
    return getRuleContexts<VHDLParser::IdentifierContext>();
}

VHDLParser::IdentifierContext *VHDLParser::Identifier_listContext::identifier(size_t i)
{
    return getRuleContext<VHDLParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Identifier_listContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Identifier_listContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

size_t VHDLParser::Identifier_listContext::getRuleIndex() const
{
    return VHDLParser::RuleIdentifier_list;
}

void VHDLParser::Identifier_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterIdentifier_list(this);
}

void VHDLParser::Identifier_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitIdentifier_list(this);
}

std::any VHDLParser::Identifier_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitIdentifier_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Identifier_listContext *VHDLParser::identifier_list()
{
    Identifier_listContext *_localctx = _tracker.createInstance<Identifier_listContext>(_ctx, getState());
    enterRule(_localctx, 232, VHDLParser::RuleIdentifier_list);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1415);
        identifier();
        setState(1420);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::COMMA)
        {
            setState(1416);
            match(VHDLParser::COMMA);
            setState(1417);
            identifier();
            setState(1422);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- If_statementContext
//------------------------------------------------------------------

VHDLParser::If_statementContext::If_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::If_statementContext::IF()
{
    return getTokens(VHDLParser::IF);
}

tree::TerminalNode *VHDLParser::If_statementContext::IF(size_t i)
{
    return getToken(VHDLParser::IF, i);
}

std::vector<VHDLParser::ConditionContext *> VHDLParser::If_statementContext::condition()
{
    return getRuleContexts<VHDLParser::ConditionContext>();
}

VHDLParser::ConditionContext *VHDLParser::If_statementContext::condition(size_t i)
{
    return getRuleContext<VHDLParser::ConditionContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::If_statementContext::THEN()
{
    return getTokens(VHDLParser::THEN);
}

tree::TerminalNode *VHDLParser::If_statementContext::THEN(size_t i)
{
    return getToken(VHDLParser::THEN, i);
}

std::vector<VHDLParser::Sequence_of_statementsContext *> VHDLParser::If_statementContext::sequence_of_statements()
{
    return getRuleContexts<VHDLParser::Sequence_of_statementsContext>();
}

VHDLParser::Sequence_of_statementsContext *VHDLParser::If_statementContext::sequence_of_statements(size_t i)
{
    return getRuleContext<VHDLParser::Sequence_of_statementsContext>(i);
}

tree::TerminalNode *VHDLParser::If_statementContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::If_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::If_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

std::vector<tree::TerminalNode *> VHDLParser::If_statementContext::ELSIF()
{
    return getTokens(VHDLParser::ELSIF);
}

tree::TerminalNode *VHDLParser::If_statementContext::ELSIF(size_t i)
{
    return getToken(VHDLParser::ELSIF, i);
}

tree::TerminalNode *VHDLParser::If_statementContext::ELSE()
{
    return getToken(VHDLParser::ELSE, 0);
}

VHDLParser::IdentifierContext *VHDLParser::If_statementContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

size_t VHDLParser::If_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleIf_statement;
}

void VHDLParser::If_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterIf_statement(this);
}

void VHDLParser::If_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitIf_statement(this);
}

std::any VHDLParser::If_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitIf_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::If_statementContext *VHDLParser::if_statement()
{
    If_statementContext *_localctx = _tracker.createInstance<If_statementContext>(_ctx, getState());
    enterRule(_localctx, 234, VHDLParser::RuleIf_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1424);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1423);
            label_colon();
        }
        setState(1426);
        match(VHDLParser::IF);
        setState(1427);
        condition();
        setState(1428);
        match(VHDLParser::THEN);
        setState(1429);
        sequence_of_statements();
        setState(1437);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::ELSIF)
        {
            setState(1430);
            match(VHDLParser::ELSIF);
            setState(1431);
            condition();
            setState(1432);
            match(VHDLParser::THEN);
            setState(1433);
            sequence_of_statements();
            setState(1439);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(1442);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::ELSE)
        {
            setState(1440);
            match(VHDLParser::ELSE);
            setState(1441);
            sequence_of_statements();
        }
        setState(1444);
        match(VHDLParser::END);
        setState(1445);
        match(VHDLParser::IF);
        setState(1447);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1446);
            identifier();
        }
        setState(1449);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Index_constraintContext
//------------------------------------------------------------------

VHDLParser::Index_constraintContext::Index_constraintContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Index_constraintContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

std::vector<VHDLParser::Discrete_rangeContext *> VHDLParser::Index_constraintContext::discrete_range()
{
    return getRuleContexts<VHDLParser::Discrete_rangeContext>();
}

VHDLParser::Discrete_rangeContext *VHDLParser::Index_constraintContext::discrete_range(size_t i)
{
    return getRuleContext<VHDLParser::Discrete_rangeContext>(i);
}

tree::TerminalNode *VHDLParser::Index_constraintContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

std::vector<tree::TerminalNode *> VHDLParser::Index_constraintContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Index_constraintContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

size_t VHDLParser::Index_constraintContext::getRuleIndex() const
{
    return VHDLParser::RuleIndex_constraint;
}

void VHDLParser::Index_constraintContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterIndex_constraint(this);
}

void VHDLParser::Index_constraintContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitIndex_constraint(this);
}

std::any VHDLParser::Index_constraintContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitIndex_constraint(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Index_constraintContext *VHDLParser::index_constraint()
{
    Index_constraintContext *_localctx = _tracker.createInstance<Index_constraintContext>(_ctx, getState());
    enterRule(_localctx, 236, VHDLParser::RuleIndex_constraint);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1451);
        match(VHDLParser::LPAREN);
        setState(1452);
        discrete_range();
        setState(1457);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::COMMA)
        {
            setState(1453);
            match(VHDLParser::COMMA);
            setState(1454);
            discrete_range();
            setState(1459);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(1460);
        match(VHDLParser::RPAREN);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Index_specificationContext
//------------------------------------------------------------------

VHDLParser::Index_specificationContext::Index_specificationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Discrete_rangeContext *VHDLParser::Index_specificationContext::discrete_range()
{
    return getRuleContext<VHDLParser::Discrete_rangeContext>(0);
}

VHDLParser::ExpressionContext *VHDLParser::Index_specificationContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::Index_specificationContext::getRuleIndex() const
{
    return VHDLParser::RuleIndex_specification;
}

void VHDLParser::Index_specificationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterIndex_specification(this);
}

void VHDLParser::Index_specificationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitIndex_specification(this);
}

std::any VHDLParser::Index_specificationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitIndex_specification(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Index_specificationContext *VHDLParser::index_specification()
{
    Index_specificationContext *_localctx = _tracker.createInstance<Index_specificationContext>(_ctx, getState());
    enterRule(_localctx, 238, VHDLParser::RuleIndex_specification);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1464);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 137, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(1462);
            discrete_range();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(1463);
            expression();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Index_subtype_definitionContext
//------------------------------------------------------------------

VHDLParser::Index_subtype_definitionContext::Index_subtype_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::NameContext *VHDLParser::Index_subtype_definitionContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

tree::TerminalNode *VHDLParser::Index_subtype_definitionContext::RANGE()
{
    return getToken(VHDLParser::RANGE, 0);
}

tree::TerminalNode *VHDLParser::Index_subtype_definitionContext::BOX()
{
    return getToken(VHDLParser::BOX, 0);
}

size_t VHDLParser::Index_subtype_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleIndex_subtype_definition;
}

void VHDLParser::Index_subtype_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterIndex_subtype_definition(this);
}

void VHDLParser::Index_subtype_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitIndex_subtype_definition(this);
}

std::any VHDLParser::Index_subtype_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitIndex_subtype_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Index_subtype_definitionContext *VHDLParser::index_subtype_definition()
{
    Index_subtype_definitionContext *_localctx = _tracker.createInstance<Index_subtype_definitionContext>(_ctx, getState());
    enterRule(_localctx, 240, VHDLParser::RuleIndex_subtype_definition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1466);
        name();
        setState(1467);
        match(VHDLParser::RANGE);
        setState(1468);
        match(VHDLParser::BOX);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Instantiated_unitContext
//------------------------------------------------------------------

VHDLParser::Instantiated_unitContext::Instantiated_unitContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::NameContext *VHDLParser::Instantiated_unitContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

tree::TerminalNode *VHDLParser::Instantiated_unitContext::COMPONENT()
{
    return getToken(VHDLParser::COMPONENT, 0);
}

tree::TerminalNode *VHDLParser::Instantiated_unitContext::ENTITY()
{
    return getToken(VHDLParser::ENTITY, 0);
}

tree::TerminalNode *VHDLParser::Instantiated_unitContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::IdentifierContext *VHDLParser::Instantiated_unitContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Instantiated_unitContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

tree::TerminalNode *VHDLParser::Instantiated_unitContext::CONFIGURATION()
{
    return getToken(VHDLParser::CONFIGURATION, 0);
}

size_t VHDLParser::Instantiated_unitContext::getRuleIndex() const
{
    return VHDLParser::RuleInstantiated_unit;
}

void VHDLParser::Instantiated_unitContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterInstantiated_unit(this);
}

void VHDLParser::Instantiated_unitContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitInstantiated_unit(this);
}

std::any VHDLParser::Instantiated_unitContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitInstantiated_unit(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Instantiated_unitContext *VHDLParser::instantiated_unit()
{
    Instantiated_unitContext *_localctx = _tracker.createInstance<Instantiated_unitContext>(_ctx, getState());
    enterRule(_localctx, 242, VHDLParser::RuleInstantiated_unit);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1484);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::COMPONENT:
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER:
        case VHDLParser::STRING_LITERAL: {
            enterOuterAlt(_localctx, 1);
            setState(1471);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == VHDLParser::COMPONENT)
            {
                setState(1470);
                match(VHDLParser::COMPONENT);
            }
            setState(1473);
            name();
            break;
        }

        case VHDLParser::ENTITY: {
            enterOuterAlt(_localctx, 2);
            setState(1474);
            match(VHDLParser::ENTITY);
            setState(1475);
            name();
            setState(1480);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == VHDLParser::LPAREN)
            {
                setState(1476);
                match(VHDLParser::LPAREN);
                setState(1477);
                identifier();
                setState(1478);
                match(VHDLParser::RPAREN);
            }
            break;
        }

        case VHDLParser::CONFIGURATION: {
            enterOuterAlt(_localctx, 3);
            setState(1482);
            match(VHDLParser::CONFIGURATION);
            setState(1483);
            name();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Instantiation_listContext
//------------------------------------------------------------------

VHDLParser::Instantiation_listContext::Instantiation_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::IdentifierContext *> VHDLParser::Instantiation_listContext::identifier()
{
    return getRuleContexts<VHDLParser::IdentifierContext>();
}

VHDLParser::IdentifierContext *VHDLParser::Instantiation_listContext::identifier(size_t i)
{
    return getRuleContext<VHDLParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Instantiation_listContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Instantiation_listContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

tree::TerminalNode *VHDLParser::Instantiation_listContext::OTHERS()
{
    return getToken(VHDLParser::OTHERS, 0);
}

tree::TerminalNode *VHDLParser::Instantiation_listContext::ALL()
{
    return getToken(VHDLParser::ALL, 0);
}

size_t VHDLParser::Instantiation_listContext::getRuleIndex() const
{
    return VHDLParser::RuleInstantiation_list;
}

void VHDLParser::Instantiation_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterInstantiation_list(this);
}

void VHDLParser::Instantiation_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitInstantiation_list(this);
}

std::any VHDLParser::Instantiation_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitInstantiation_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Instantiation_listContext *VHDLParser::instantiation_list()
{
    Instantiation_listContext *_localctx = _tracker.createInstance<Instantiation_listContext>(_ctx, getState());
    enterRule(_localctx, 244, VHDLParser::RuleInstantiation_list);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1496);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER: {
            enterOuterAlt(_localctx, 1);
            setState(1486);
            identifier();
            setState(1491);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == VHDLParser::COMMA)
            {
                setState(1487);
                match(VHDLParser::COMMA);
                setState(1488);
                identifier();
                setState(1493);
                _errHandler->sync(this);
                _la = _input->LA(1);
            }
            break;
        }

        case VHDLParser::OTHERS: {
            enterOuterAlt(_localctx, 2);
            setState(1494);
            match(VHDLParser::OTHERS);
            break;
        }

        case VHDLParser::ALL: {
            enterOuterAlt(_localctx, 3);
            setState(1495);
            match(VHDLParser::ALL);
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Interface_constant_declarationContext
//------------------------------------------------------------------

VHDLParser::Interface_constant_declarationContext::Interface_constant_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Identifier_listContext *VHDLParser::Interface_constant_declarationContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Interface_constant_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Interface_constant_declarationContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

tree::TerminalNode *VHDLParser::Interface_constant_declarationContext::CONSTANT()
{
    return getToken(VHDLParser::CONSTANT, 0);
}

tree::TerminalNode *VHDLParser::Interface_constant_declarationContext::IN()
{
    return getToken(VHDLParser::IN, 0);
}

tree::TerminalNode *VHDLParser::Interface_constant_declarationContext::VARASGN()
{
    return getToken(VHDLParser::VARASGN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Interface_constant_declarationContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::Interface_constant_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleInterface_constant_declaration;
}

void VHDLParser::Interface_constant_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterInterface_constant_declaration(this);
}

void VHDLParser::Interface_constant_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitInterface_constant_declaration(this);
}

std::any VHDLParser::Interface_constant_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitInterface_constant_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Interface_constant_declarationContext *VHDLParser::interface_constant_declaration()
{
    Interface_constant_declarationContext *_localctx = _tracker.createInstance<Interface_constant_declarationContext>(_ctx, getState());
    enterRule(_localctx, 246, VHDLParser::RuleInterface_constant_declaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1499);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::CONSTANT)
        {
            setState(1498);
            match(VHDLParser::CONSTANT);
        }
        setState(1501);
        identifier_list();
        setState(1502);
        match(VHDLParser::COLON);
        setState(1504);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::IN)
        {
            setState(1503);
            match(VHDLParser::IN);
        }
        setState(1506);
        subtype_indication();
        setState(1509);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::VARASGN)
        {
            setState(1507);
            match(VHDLParser::VARASGN);
            setState(1508);
            expression();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Interface_declarationContext
//------------------------------------------------------------------

VHDLParser::Interface_declarationContext::Interface_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Interface_constant_declarationContext *VHDLParser::Interface_declarationContext::interface_constant_declaration()
{
    return getRuleContext<VHDLParser::Interface_constant_declarationContext>(0);
}

VHDLParser::Interface_signal_declarationContext *VHDLParser::Interface_declarationContext::interface_signal_declaration()
{
    return getRuleContext<VHDLParser::Interface_signal_declarationContext>(0);
}

VHDLParser::Interface_variable_declarationContext *VHDLParser::Interface_declarationContext::interface_variable_declaration()
{
    return getRuleContext<VHDLParser::Interface_variable_declarationContext>(0);
}

VHDLParser::Interface_file_declarationContext *VHDLParser::Interface_declarationContext::interface_file_declaration()
{
    return getRuleContext<VHDLParser::Interface_file_declarationContext>(0);
}

VHDLParser::Interface_terminal_declarationContext *VHDLParser::Interface_declarationContext::interface_terminal_declaration()
{
    return getRuleContext<VHDLParser::Interface_terminal_declarationContext>(0);
}

VHDLParser::Interface_quantity_declarationContext *VHDLParser::Interface_declarationContext::interface_quantity_declaration()
{
    return getRuleContext<VHDLParser::Interface_quantity_declarationContext>(0);
}

size_t VHDLParser::Interface_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleInterface_declaration;
}

void VHDLParser::Interface_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterInterface_declaration(this);
}

void VHDLParser::Interface_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitInterface_declaration(this);
}

std::any VHDLParser::Interface_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitInterface_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Interface_declarationContext *VHDLParser::interface_declaration()
{
    Interface_declarationContext *_localctx = _tracker.createInstance<Interface_declarationContext>(_ctx, getState());
    enterRule(_localctx, 248, VHDLParser::RuleInterface_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1517);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(1511);
            interface_constant_declaration();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(1512);
            interface_signal_declaration();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(1513);
            interface_variable_declaration();
            break;
        }

        case 4: {
            enterOuterAlt(_localctx, 4);
            setState(1514);
            interface_file_declaration();
            break;
        }

        case 5: {
            enterOuterAlt(_localctx, 5);
            setState(1515);
            interface_terminal_declaration();
            break;
        }

        case 6: {
            enterOuterAlt(_localctx, 6);
            setState(1516);
            interface_quantity_declaration();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Interface_elementContext
//------------------------------------------------------------------

VHDLParser::Interface_elementContext::Interface_elementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Interface_declarationContext *VHDLParser::Interface_elementContext::interface_declaration()
{
    return getRuleContext<VHDLParser::Interface_declarationContext>(0);
}

size_t VHDLParser::Interface_elementContext::getRuleIndex() const
{
    return VHDLParser::RuleInterface_element;
}

void VHDLParser::Interface_elementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterInterface_element(this);
}

void VHDLParser::Interface_elementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitInterface_element(this);
}

std::any VHDLParser::Interface_elementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitInterface_element(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Interface_elementContext *VHDLParser::interface_element()
{
    Interface_elementContext *_localctx = _tracker.createInstance<Interface_elementContext>(_ctx, getState());
    enterRule(_localctx, 250, VHDLParser::RuleInterface_element);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1519);
        interface_declaration();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Interface_file_declarationContext
//------------------------------------------------------------------

VHDLParser::Interface_file_declarationContext::Interface_file_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Interface_file_declarationContext::FILE()
{
    return getToken(VHDLParser::FILE, 0);
}

VHDLParser::Identifier_listContext *VHDLParser::Interface_file_declarationContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Interface_file_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Interface_file_declarationContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

size_t VHDLParser::Interface_file_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleInterface_file_declaration;
}

void VHDLParser::Interface_file_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterInterface_file_declaration(this);
}

void VHDLParser::Interface_file_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitInterface_file_declaration(this);
}

std::any VHDLParser::Interface_file_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitInterface_file_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Interface_file_declarationContext *VHDLParser::interface_file_declaration()
{
    Interface_file_declarationContext *_localctx = _tracker.createInstance<Interface_file_declarationContext>(_ctx, getState());
    enterRule(_localctx, 252, VHDLParser::RuleInterface_file_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1521);
        match(VHDLParser::FILE);
        setState(1522);
        identifier_list();
        setState(1523);
        match(VHDLParser::COLON);
        setState(1524);
        subtype_indication();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Interface_signal_listContext
//------------------------------------------------------------------

VHDLParser::Interface_signal_listContext::Interface_signal_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Interface_signal_declarationContext *> VHDLParser::Interface_signal_listContext::interface_signal_declaration()
{
    return getRuleContexts<VHDLParser::Interface_signal_declarationContext>();
}

VHDLParser::Interface_signal_declarationContext *VHDLParser::Interface_signal_listContext::interface_signal_declaration(size_t i)
{
    return getRuleContext<VHDLParser::Interface_signal_declarationContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Interface_signal_listContext::SEMI()
{
    return getTokens(VHDLParser::SEMI);
}

tree::TerminalNode *VHDLParser::Interface_signal_listContext::SEMI(size_t i)
{
    return getToken(VHDLParser::SEMI, i);
}

size_t VHDLParser::Interface_signal_listContext::getRuleIndex() const
{
    return VHDLParser::RuleInterface_signal_list;
}

void VHDLParser::Interface_signal_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterInterface_signal_list(this);
}

void VHDLParser::Interface_signal_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitInterface_signal_list(this);
}

std::any VHDLParser::Interface_signal_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitInterface_signal_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Interface_signal_listContext *VHDLParser::interface_signal_list()
{
    Interface_signal_listContext *_localctx = _tracker.createInstance<Interface_signal_listContext>(_ctx, getState());
    enterRule(_localctx, 254, VHDLParser::RuleInterface_signal_list);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1526);
        interface_signal_declaration();
        setState(1531);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::SEMI)
        {
            setState(1527);
            match(VHDLParser::SEMI);
            setState(1528);
            interface_signal_declaration();
            setState(1533);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Interface_port_listContext
//------------------------------------------------------------------

VHDLParser::Interface_port_listContext::Interface_port_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Interface_port_declarationContext *> VHDLParser::Interface_port_listContext::interface_port_declaration()
{
    return getRuleContexts<VHDLParser::Interface_port_declarationContext>();
}

VHDLParser::Interface_port_declarationContext *VHDLParser::Interface_port_listContext::interface_port_declaration(size_t i)
{
    return getRuleContext<VHDLParser::Interface_port_declarationContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Interface_port_listContext::SEMI()
{
    return getTokens(VHDLParser::SEMI);
}

tree::TerminalNode *VHDLParser::Interface_port_listContext::SEMI(size_t i)
{
    return getToken(VHDLParser::SEMI, i);
}

size_t VHDLParser::Interface_port_listContext::getRuleIndex() const
{
    return VHDLParser::RuleInterface_port_list;
}

void VHDLParser::Interface_port_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterInterface_port_list(this);
}

void VHDLParser::Interface_port_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitInterface_port_list(this);
}

std::any VHDLParser::Interface_port_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitInterface_port_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Interface_port_listContext *VHDLParser::interface_port_list()
{
    Interface_port_listContext *_localctx = _tracker.createInstance<Interface_port_listContext>(_ctx, getState());
    enterRule(_localctx, 256, VHDLParser::RuleInterface_port_list);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1534);
        interface_port_declaration();
        setState(1539);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::SEMI)
        {
            setState(1535);
            match(VHDLParser::SEMI);
            setState(1536);
            interface_port_declaration();
            setState(1541);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Interface_listContext
//------------------------------------------------------------------

VHDLParser::Interface_listContext::Interface_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Interface_elementContext *> VHDLParser::Interface_listContext::interface_element()
{
    return getRuleContexts<VHDLParser::Interface_elementContext>();
}

VHDLParser::Interface_elementContext *VHDLParser::Interface_listContext::interface_element(size_t i)
{
    return getRuleContext<VHDLParser::Interface_elementContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Interface_listContext::SEMI()
{
    return getTokens(VHDLParser::SEMI);
}

tree::TerminalNode *VHDLParser::Interface_listContext::SEMI(size_t i)
{
    return getToken(VHDLParser::SEMI, i);
}

size_t VHDLParser::Interface_listContext::getRuleIndex() const
{
    return VHDLParser::RuleInterface_list;
}

void VHDLParser::Interface_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterInterface_list(this);
}

void VHDLParser::Interface_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitInterface_list(this);
}

std::any VHDLParser::Interface_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitInterface_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Interface_listContext *VHDLParser::interface_list()
{
    Interface_listContext *_localctx = _tracker.createInstance<Interface_listContext>(_ctx, getState());
    enterRule(_localctx, 258, VHDLParser::RuleInterface_list);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1542);
        interface_element();
        setState(1547);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::SEMI)
        {
            setState(1543);
            match(VHDLParser::SEMI);
            setState(1544);
            interface_element();
            setState(1549);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Interface_quantity_declarationContext
//------------------------------------------------------------------

VHDLParser::Interface_quantity_declarationContext::Interface_quantity_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Interface_quantity_declarationContext::QUANTITY()
{
    return getToken(VHDLParser::QUANTITY, 0);
}

VHDLParser::Identifier_listContext *VHDLParser::Interface_quantity_declarationContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Interface_quantity_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Interface_quantity_declarationContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

tree::TerminalNode *VHDLParser::Interface_quantity_declarationContext::VARASGN()
{
    return getToken(VHDLParser::VARASGN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Interface_quantity_declarationContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

tree::TerminalNode *VHDLParser::Interface_quantity_declarationContext::IN()
{
    return getToken(VHDLParser::IN, 0);
}

tree::TerminalNode *VHDLParser::Interface_quantity_declarationContext::OUT()
{
    return getToken(VHDLParser::OUT, 0);
}

size_t VHDLParser::Interface_quantity_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleInterface_quantity_declaration;
}

void VHDLParser::Interface_quantity_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterInterface_quantity_declaration(this);
}

void VHDLParser::Interface_quantity_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitInterface_quantity_declaration(this);
}

std::any VHDLParser::Interface_quantity_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitInterface_quantity_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Interface_quantity_declarationContext *VHDLParser::interface_quantity_declaration()
{
    Interface_quantity_declarationContext *_localctx = _tracker.createInstance<Interface_quantity_declarationContext>(_ctx, getState());
    enterRule(_localctx, 260, VHDLParser::RuleInterface_quantity_declaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1550);
        match(VHDLParser::QUANTITY);
        setState(1551);
        identifier_list();
        setState(1552);
        match(VHDLParser::COLON);
        setState(1554);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::IN

            || _la == VHDLParser::OUT)
        {
            setState(1553);
            _la = _input->LA(1);
            if (!(_la == VHDLParser::IN

                  || _la == VHDLParser::OUT))
            {
                _errHandler->recoverInline(this);
            }
            else
            {
                _errHandler->reportMatch(this);
                consume();
            }
        }
        setState(1556);
        subtype_indication();
        setState(1559);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::VARASGN)
        {
            setState(1557);
            match(VHDLParser::VARASGN);
            setState(1558);
            expression();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Interface_port_declarationContext
//------------------------------------------------------------------

VHDLParser::Interface_port_declarationContext::Interface_port_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Identifier_listContext *VHDLParser::Interface_port_declarationContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Interface_port_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Interface_port_declarationContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

VHDLParser::Signal_modeContext *VHDLParser::Interface_port_declarationContext::signal_mode()
{
    return getRuleContext<VHDLParser::Signal_modeContext>(0);
}

tree::TerminalNode *VHDLParser::Interface_port_declarationContext::BUS()
{
    return getToken(VHDLParser::BUS, 0);
}

tree::TerminalNode *VHDLParser::Interface_port_declarationContext::VARASGN()
{
    return getToken(VHDLParser::VARASGN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Interface_port_declarationContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::Interface_port_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleInterface_port_declaration;
}

void VHDLParser::Interface_port_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterInterface_port_declaration(this);
}

void VHDLParser::Interface_port_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitInterface_port_declaration(this);
}

std::any VHDLParser::Interface_port_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitInterface_port_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Interface_port_declarationContext *VHDLParser::interface_port_declaration()
{
    Interface_port_declarationContext *_localctx = _tracker.createInstance<Interface_port_declarationContext>(_ctx, getState());
    enterRule(_localctx, 262, VHDLParser::RuleInterface_port_declaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1561);
        identifier_list();
        setState(1562);
        match(VHDLParser::COLON);
        setState(1564);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & -9223335478093086720) != 0))
        {
            setState(1563);
            signal_mode();
        }
        setState(1566);
        subtype_indication();
        setState(1568);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BUS)
        {
            setState(1567);
            match(VHDLParser::BUS);
        }
        setState(1572);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::VARASGN)
        {
            setState(1570);
            match(VHDLParser::VARASGN);
            setState(1571);
            expression();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Interface_signal_declarationContext
//------------------------------------------------------------------

VHDLParser::Interface_signal_declarationContext::Interface_signal_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Interface_signal_declarationContext::SIGNAL()
{
    return getToken(VHDLParser::SIGNAL, 0);
}

VHDLParser::Identifier_listContext *VHDLParser::Interface_signal_declarationContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Interface_signal_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Interface_signal_declarationContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

VHDLParser::Signal_modeContext *VHDLParser::Interface_signal_declarationContext::signal_mode()
{
    return getRuleContext<VHDLParser::Signal_modeContext>(0);
}

tree::TerminalNode *VHDLParser::Interface_signal_declarationContext::BUS()
{
    return getToken(VHDLParser::BUS, 0);
}

tree::TerminalNode *VHDLParser::Interface_signal_declarationContext::VARASGN()
{
    return getToken(VHDLParser::VARASGN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Interface_signal_declarationContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::Interface_signal_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleInterface_signal_declaration;
}

void VHDLParser::Interface_signal_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterInterface_signal_declaration(this);
}

void VHDLParser::Interface_signal_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitInterface_signal_declaration(this);
}

std::any VHDLParser::Interface_signal_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitInterface_signal_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Interface_signal_declarationContext *VHDLParser::interface_signal_declaration()
{
    Interface_signal_declarationContext *_localctx = _tracker.createInstance<Interface_signal_declarationContext>(_ctx, getState());
    enterRule(_localctx, 264, VHDLParser::RuleInterface_signal_declaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1574);
        match(VHDLParser::SIGNAL);
        setState(1575);
        identifier_list();
        setState(1576);
        match(VHDLParser::COLON);
        setState(1578);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & -9223335478093086720) != 0))
        {
            setState(1577);
            signal_mode();
        }
        setState(1580);
        subtype_indication();
        setState(1582);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BUS)
        {
            setState(1581);
            match(VHDLParser::BUS);
        }
        setState(1586);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::VARASGN)
        {
            setState(1584);
            match(VHDLParser::VARASGN);
            setState(1585);
            expression();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Interface_terminal_declarationContext
//------------------------------------------------------------------

VHDLParser::Interface_terminal_declarationContext::Interface_terminal_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Interface_terminal_declarationContext::TERMINAL()
{
    return getToken(VHDLParser::TERMINAL, 0);
}

VHDLParser::Identifier_listContext *VHDLParser::Interface_terminal_declarationContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Interface_terminal_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Subnature_indicationContext *VHDLParser::Interface_terminal_declarationContext::subnature_indication()
{
    return getRuleContext<VHDLParser::Subnature_indicationContext>(0);
}

size_t VHDLParser::Interface_terminal_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleInterface_terminal_declaration;
}

void VHDLParser::Interface_terminal_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterInterface_terminal_declaration(this);
}

void VHDLParser::Interface_terminal_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitInterface_terminal_declaration(this);
}

std::any VHDLParser::Interface_terminal_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitInterface_terminal_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Interface_terminal_declarationContext *VHDLParser::interface_terminal_declaration()
{
    Interface_terminal_declarationContext *_localctx = _tracker.createInstance<Interface_terminal_declarationContext>(_ctx, getState());
    enterRule(_localctx, 266, VHDLParser::RuleInterface_terminal_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1588);
        match(VHDLParser::TERMINAL);
        setState(1589);
        identifier_list();
        setState(1590);
        match(VHDLParser::COLON);
        setState(1591);
        subnature_indication();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Interface_variable_declarationContext
//------------------------------------------------------------------

VHDLParser::Interface_variable_declarationContext::Interface_variable_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Identifier_listContext *VHDLParser::Interface_variable_declarationContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Interface_variable_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Interface_variable_declarationContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

tree::TerminalNode *VHDLParser::Interface_variable_declarationContext::VARIABLE()
{
    return getToken(VHDLParser::VARIABLE, 0);
}

VHDLParser::Signal_modeContext *VHDLParser::Interface_variable_declarationContext::signal_mode()
{
    return getRuleContext<VHDLParser::Signal_modeContext>(0);
}

tree::TerminalNode *VHDLParser::Interface_variable_declarationContext::VARASGN()
{
    return getToken(VHDLParser::VARASGN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Interface_variable_declarationContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::Interface_variable_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleInterface_variable_declaration;
}

void VHDLParser::Interface_variable_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterInterface_variable_declaration(this);
}

void VHDLParser::Interface_variable_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitInterface_variable_declaration(this);
}

std::any VHDLParser::Interface_variable_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitInterface_variable_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Interface_variable_declarationContext *VHDLParser::interface_variable_declaration()
{
    Interface_variable_declarationContext *_localctx = _tracker.createInstance<Interface_variable_declarationContext>(_ctx, getState());
    enterRule(_localctx, 268, VHDLParser::RuleInterface_variable_declaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1594);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::VARIABLE)
        {
            setState(1593);
            match(VHDLParser::VARIABLE);
        }
        setState(1596);
        identifier_list();
        setState(1597);
        match(VHDLParser::COLON);
        setState(1599);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & -9223335478093086720) != 0))
        {
            setState(1598);
            signal_mode();
        }
        setState(1601);
        subtype_indication();
        setState(1604);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::VARASGN)
        {
            setState(1602);
            match(VHDLParser::VARASGN);
            setState(1603);
            expression();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Iteration_schemeContext
//------------------------------------------------------------------

VHDLParser::Iteration_schemeContext::Iteration_schemeContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Iteration_schemeContext::WHILE()
{
    return getToken(VHDLParser::WHILE, 0);
}

VHDLParser::ConditionContext *VHDLParser::Iteration_schemeContext::condition()
{
    return getRuleContext<VHDLParser::ConditionContext>(0);
}

tree::TerminalNode *VHDLParser::Iteration_schemeContext::FOR()
{
    return getToken(VHDLParser::FOR, 0);
}

VHDLParser::Parameter_specificationContext *VHDLParser::Iteration_schemeContext::parameter_specification()
{
    return getRuleContext<VHDLParser::Parameter_specificationContext>(0);
}

size_t VHDLParser::Iteration_schemeContext::getRuleIndex() const
{
    return VHDLParser::RuleIteration_scheme;
}

void VHDLParser::Iteration_schemeContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterIteration_scheme(this);
}

void VHDLParser::Iteration_schemeContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitIteration_scheme(this);
}

std::any VHDLParser::Iteration_schemeContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitIteration_scheme(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Iteration_schemeContext *VHDLParser::iteration_scheme()
{
    Iteration_schemeContext *_localctx = _tracker.createInstance<Iteration_schemeContext>(_ctx, getState());
    enterRule(_localctx, 270, VHDLParser::RuleIteration_scheme);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1610);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::WHILE: {
            enterOuterAlt(_localctx, 1);
            setState(1606);
            match(VHDLParser::WHILE);
            setState(1607);
            condition();
            break;
        }

        case VHDLParser::FOR: {
            enterOuterAlt(_localctx, 2);
            setState(1608);
            match(VHDLParser::FOR);
            setState(1609);
            parameter_specification();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Label_colonContext
//------------------------------------------------------------------

VHDLParser::Label_colonContext::Label_colonContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::IdentifierContext *VHDLParser::Label_colonContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Label_colonContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

size_t VHDLParser::Label_colonContext::getRuleIndex() const
{
    return VHDLParser::RuleLabel_colon;
}

void VHDLParser::Label_colonContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterLabel_colon(this);
}

void VHDLParser::Label_colonContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitLabel_colon(this);
}

std::any VHDLParser::Label_colonContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitLabel_colon(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Label_colonContext *VHDLParser::label_colon()
{
    Label_colonContext *_localctx = _tracker.createInstance<Label_colonContext>(_ctx, getState());
    enterRule(_localctx, 272, VHDLParser::RuleLabel_colon);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1612);
        identifier();
        setState(1613);
        match(VHDLParser::COLON);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Library_clauseContext
//------------------------------------------------------------------

VHDLParser::Library_clauseContext::Library_clauseContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Library_clauseContext::LIBRARY()
{
    return getToken(VHDLParser::LIBRARY, 0);
}

VHDLParser::Logical_name_listContext *VHDLParser::Library_clauseContext::logical_name_list()
{
    return getRuleContext<VHDLParser::Logical_name_listContext>(0);
}

tree::TerminalNode *VHDLParser::Library_clauseContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Library_clauseContext::getRuleIndex() const
{
    return VHDLParser::RuleLibrary_clause;
}

void VHDLParser::Library_clauseContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterLibrary_clause(this);
}

void VHDLParser::Library_clauseContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitLibrary_clause(this);
}

std::any VHDLParser::Library_clauseContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitLibrary_clause(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Library_clauseContext *VHDLParser::library_clause()
{
    Library_clauseContext *_localctx = _tracker.createInstance<Library_clauseContext>(_ctx, getState());
    enterRule(_localctx, 274, VHDLParser::RuleLibrary_clause);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1615);
        match(VHDLParser::LIBRARY);
        setState(1616);
        logical_name_list();
        setState(1617);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Library_unitContext
//------------------------------------------------------------------

VHDLParser::Library_unitContext::Library_unitContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Secondary_unitContext *VHDLParser::Library_unitContext::secondary_unit()
{
    return getRuleContext<VHDLParser::Secondary_unitContext>(0);
}

VHDLParser::Primary_unitContext *VHDLParser::Library_unitContext::primary_unit()
{
    return getRuleContext<VHDLParser::Primary_unitContext>(0);
}

size_t VHDLParser::Library_unitContext::getRuleIndex() const
{
    return VHDLParser::RuleLibrary_unit;
}

void VHDLParser::Library_unitContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterLibrary_unit(this);
}

void VHDLParser::Library_unitContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitLibrary_unit(this);
}

std::any VHDLParser::Library_unitContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitLibrary_unit(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Library_unitContext *VHDLParser::library_unit()
{
    Library_unitContext *_localctx = _tracker.createInstance<Library_unitContext>(_ctx, getState());
    enterRule(_localctx, 276, VHDLParser::RuleLibrary_unit);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1621);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(1619);
            secondary_unit();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(1620);
            primary_unit();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- LiteralContext
//------------------------------------------------------------------

VHDLParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::LiteralContext::NULL_()
{
    return getToken(VHDLParser::NULL_, 0);
}

tree::TerminalNode *VHDLParser::LiteralContext::BIT_STRING_LITERAL()
{
    return getToken(VHDLParser::BIT_STRING_LITERAL, 0);
}

tree::TerminalNode *VHDLParser::LiteralContext::STRING_LITERAL()
{
    return getToken(VHDLParser::STRING_LITERAL, 0);
}

VHDLParser::Enumeration_literalContext *VHDLParser::LiteralContext::enumeration_literal()
{
    return getRuleContext<VHDLParser::Enumeration_literalContext>(0);
}

VHDLParser::Numeric_literalContext *VHDLParser::LiteralContext::numeric_literal()
{
    return getRuleContext<VHDLParser::Numeric_literalContext>(0);
}

size_t VHDLParser::LiteralContext::getRuleIndex() const
{
    return VHDLParser::RuleLiteral;
}

void VHDLParser::LiteralContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterLiteral(this);
}

void VHDLParser::LiteralContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitLiteral(this);
}

std::any VHDLParser::LiteralContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitLiteral(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::LiteralContext *VHDLParser::literal()
{
    LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
    enterRule(_localctx, 278, VHDLParser::RuleLiteral);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1628);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::NULL_: {
            enterOuterAlt(_localctx, 1);
            setState(1623);
            match(VHDLParser::NULL_);
            break;
        }

        case VHDLParser::BIT_STRING_LITERAL: {
            enterOuterAlt(_localctx, 2);
            setState(1624);
            match(VHDLParser::BIT_STRING_LITERAL);
            break;
        }

        case VHDLParser::STRING_LITERAL: {
            enterOuterAlt(_localctx, 3);
            setState(1625);
            match(VHDLParser::STRING_LITERAL);
            break;
        }

        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER:
        case VHDLParser::CHARACTER_LITERAL: {
            enterOuterAlt(_localctx, 4);
            setState(1626);
            enumeration_literal();
            break;
        }

        case VHDLParser::BASE_LITERAL:
        case VHDLParser::REAL_LITERAL:
        case VHDLParser::INTEGER: {
            enterOuterAlt(_localctx, 5);
            setState(1627);
            numeric_literal();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Logical_nameContext
//------------------------------------------------------------------

VHDLParser::Logical_nameContext::Logical_nameContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::IdentifierContext *VHDLParser::Logical_nameContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

size_t VHDLParser::Logical_nameContext::getRuleIndex() const
{
    return VHDLParser::RuleLogical_name;
}

void VHDLParser::Logical_nameContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterLogical_name(this);
}

void VHDLParser::Logical_nameContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitLogical_name(this);
}

std::any VHDLParser::Logical_nameContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitLogical_name(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Logical_nameContext *VHDLParser::logical_name()
{
    Logical_nameContext *_localctx = _tracker.createInstance<Logical_nameContext>(_ctx, getState());
    enterRule(_localctx, 280, VHDLParser::RuleLogical_name);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1630);
        identifier();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Logical_name_listContext
//------------------------------------------------------------------

VHDLParser::Logical_name_listContext::Logical_name_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Logical_nameContext *> VHDLParser::Logical_name_listContext::logical_name()
{
    return getRuleContexts<VHDLParser::Logical_nameContext>();
}

VHDLParser::Logical_nameContext *VHDLParser::Logical_name_listContext::logical_name(size_t i)
{
    return getRuleContext<VHDLParser::Logical_nameContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Logical_name_listContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Logical_name_listContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

size_t VHDLParser::Logical_name_listContext::getRuleIndex() const
{
    return VHDLParser::RuleLogical_name_list;
}

void VHDLParser::Logical_name_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterLogical_name_list(this);
}

void VHDLParser::Logical_name_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitLogical_name_list(this);
}

std::any VHDLParser::Logical_name_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitLogical_name_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Logical_name_listContext *VHDLParser::logical_name_list()
{
    Logical_name_listContext *_localctx = _tracker.createInstance<Logical_name_listContext>(_ctx, getState());
    enterRule(_localctx, 282, VHDLParser::RuleLogical_name_list);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1632);
        logical_name();
        setState(1637);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::COMMA)
        {
            setState(1633);
            match(VHDLParser::COMMA);
            setState(1634);
            logical_name();
            setState(1639);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Logical_operatorContext
//------------------------------------------------------------------

VHDLParser::Logical_operatorContext::Logical_operatorContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Logical_operatorContext::AND()
{
    return getToken(VHDLParser::AND, 0);
}

tree::TerminalNode *VHDLParser::Logical_operatorContext::OR()
{
    return getToken(VHDLParser::OR, 0);
}

tree::TerminalNode *VHDLParser::Logical_operatorContext::NAND()
{
    return getToken(VHDLParser::NAND, 0);
}

tree::TerminalNode *VHDLParser::Logical_operatorContext::NOR()
{
    return getToken(VHDLParser::NOR, 0);
}

tree::TerminalNode *VHDLParser::Logical_operatorContext::XOR()
{
    return getToken(VHDLParser::XOR, 0);
}

tree::TerminalNode *VHDLParser::Logical_operatorContext::XNOR()
{
    return getToken(VHDLParser::XNOR, 0);
}

size_t VHDLParser::Logical_operatorContext::getRuleIndex() const
{
    return VHDLParser::RuleLogical_operator;
}

void VHDLParser::Logical_operatorContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterLogical_operator(this);
}

void VHDLParser::Logical_operatorContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitLogical_operator(this);
}

std::any VHDLParser::Logical_operatorContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitLogical_operator(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Logical_operatorContext *VHDLParser::logical_operator()
{
    Logical_operatorContext *_localctx = _tracker.createInstance<Logical_operatorContext>(_ctx, getState());
    enterRule(_localctx, 284, VHDLParser::RuleLogical_operator);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1640);
        _la = _input->LA(1);
        if (!((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 2342997706139500672) != 0) || _la == VHDLParser::XNOR

              || _la == VHDLParser::XOR))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Loop_statementContext
//------------------------------------------------------------------

VHDLParser::Loop_statementContext::Loop_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::Loop_statementContext::LOOP()
{
    return getTokens(VHDLParser::LOOP);
}

tree::TerminalNode *VHDLParser::Loop_statementContext::LOOP(size_t i)
{
    return getToken(VHDLParser::LOOP, i);
}

VHDLParser::Sequence_of_statementsContext *VHDLParser::Loop_statementContext::sequence_of_statements()
{
    return getRuleContext<VHDLParser::Sequence_of_statementsContext>(0);
}

tree::TerminalNode *VHDLParser::Loop_statementContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::Loop_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Loop_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

VHDLParser::Iteration_schemeContext *VHDLParser::Loop_statementContext::iteration_scheme()
{
    return getRuleContext<VHDLParser::Iteration_schemeContext>(0);
}

VHDLParser::IdentifierContext *VHDLParser::Loop_statementContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

size_t VHDLParser::Loop_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleLoop_statement;
}

void VHDLParser::Loop_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterLoop_statement(this);
}

void VHDLParser::Loop_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitLoop_statement(this);
}

std::any VHDLParser::Loop_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitLoop_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Loop_statementContext *VHDLParser::loop_statement()
{
    Loop_statementContext *_localctx = _tracker.createInstance<Loop_statementContext>(_ctx, getState());
    enterRule(_localctx, 286, VHDLParser::RuleLoop_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1643);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1642);
            label_colon();
        }
        setState(1646);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::FOR || _la == VHDLParser::WHILE)
        {
            setState(1645);
            iteration_scheme();
        }
        setState(1648);
        match(VHDLParser::LOOP);
        setState(1649);
        sequence_of_statements();
        setState(1650);
        match(VHDLParser::END);
        setState(1651);
        match(VHDLParser::LOOP);
        setState(1653);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1652);
            identifier();
        }
        setState(1655);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Signal_modeContext
//------------------------------------------------------------------

VHDLParser::Signal_modeContext::Signal_modeContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Signal_modeContext::IN()
{
    return getToken(VHDLParser::IN, 0);
}

tree::TerminalNode *VHDLParser::Signal_modeContext::OUT()
{
    return getToken(VHDLParser::OUT, 0);
}

tree::TerminalNode *VHDLParser::Signal_modeContext::INOUT()
{
    return getToken(VHDLParser::INOUT, 0);
}

tree::TerminalNode *VHDLParser::Signal_modeContext::BUFFER()
{
    return getToken(VHDLParser::BUFFER, 0);
}

tree::TerminalNode *VHDLParser::Signal_modeContext::LINKAGE()
{
    return getToken(VHDLParser::LINKAGE, 0);
}

size_t VHDLParser::Signal_modeContext::getRuleIndex() const
{
    return VHDLParser::RuleSignal_mode;
}

void VHDLParser::Signal_modeContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSignal_mode(this);
}

void VHDLParser::Signal_modeContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSignal_mode(this);
}

std::any VHDLParser::Signal_modeContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSignal_mode(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Signal_modeContext *VHDLParser::signal_mode()
{
    Signal_modeContext *_localctx = _tracker.createInstance<Signal_modeContext>(_ctx, getState());
    enterRule(_localctx, 288, VHDLParser::RuleSignal_mode);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1657);
        _la = _input->LA(1);
        if (!((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & -9223335478093086720) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Multiplying_operatorContext
//------------------------------------------------------------------

VHDLParser::Multiplying_operatorContext::Multiplying_operatorContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Multiplying_operatorContext::MUL()
{
    return getToken(VHDLParser::MUL, 0);
}

tree::TerminalNode *VHDLParser::Multiplying_operatorContext::DIV()
{
    return getToken(VHDLParser::DIV, 0);
}

tree::TerminalNode *VHDLParser::Multiplying_operatorContext::MOD()
{
    return getToken(VHDLParser::MOD, 0);
}

tree::TerminalNode *VHDLParser::Multiplying_operatorContext::REM()
{
    return getToken(VHDLParser::REM, 0);
}

size_t VHDLParser::Multiplying_operatorContext::getRuleIndex() const
{
    return VHDLParser::RuleMultiplying_operator;
}

void VHDLParser::Multiplying_operatorContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterMultiplying_operator(this);
}

void VHDLParser::Multiplying_operatorContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitMultiplying_operator(this);
}

std::any VHDLParser::Multiplying_operatorContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitMultiplying_operator(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Multiplying_operatorContext *VHDLParser::multiplying_operator()
{
    Multiplying_operatorContext *_localctx = _tracker.createInstance<Multiplying_operatorContext>(_ctx, getState());
    enterRule(_localctx, 290, VHDLParser::RuleMultiplying_operator);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1659);
        _la = _input->LA(1);
        if (!(_la == VHDLParser::MOD

              || _la == VHDLParser::REM || _la == VHDLParser::MUL

              || _la == VHDLParser::DIV))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- NameContext
//------------------------------------------------------------------

VHDLParser::NameContext::NameContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::IdentifierContext *VHDLParser::NameContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::NameContext::STRING_LITERAL()
{
    return getToken(VHDLParser::STRING_LITERAL, 0);
}

std::vector<VHDLParser::Name_partContext *> VHDLParser::NameContext::name_part()
{
    return getRuleContexts<VHDLParser::Name_partContext>();
}

VHDLParser::Name_partContext *VHDLParser::NameContext::name_part(size_t i)
{
    return getRuleContext<VHDLParser::Name_partContext>(i);
}

size_t VHDLParser::NameContext::getRuleIndex() const
{
    return VHDLParser::RuleName;
}

void VHDLParser::NameContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterName(this);
}

void VHDLParser::NameContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitName(this);
}

std::any VHDLParser::NameContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitName(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::NameContext *VHDLParser::name()
{
    NameContext *_localctx = _tracker.createInstance<NameContext>(_ctx, getState());
    enterRule(_localctx, 292, VHDLParser::RuleName);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(1663);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER: {
            setState(1661);
            identifier();
            break;
        }

        case VHDLParser::STRING_LITERAL: {
            setState(1662);
            match(VHDLParser::STRING_LITERAL);
            break;
        }

        default:
            throw NoViableAltException(this);
        }
        setState(1668);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(1665);
                name_part();
            }
            setState(1670);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Name_partContext
//------------------------------------------------------------------

VHDLParser::Name_partContext::Name_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Selected_name_partContext *VHDLParser::Name_partContext::selected_name_part()
{
    return getRuleContext<VHDLParser::Selected_name_partContext>(0);
}

VHDLParser::Function_call_or_indexed_name_partContext *VHDLParser::Name_partContext::function_call_or_indexed_name_part()
{
    return getRuleContext<VHDLParser::Function_call_or_indexed_name_partContext>(0);
}

VHDLParser::Slice_name_partContext *VHDLParser::Name_partContext::slice_name_part()
{
    return getRuleContext<VHDLParser::Slice_name_partContext>(0);
}

VHDLParser::Attribute_name_partContext *VHDLParser::Name_partContext::attribute_name_part()
{
    return getRuleContext<VHDLParser::Attribute_name_partContext>(0);
}

size_t VHDLParser::Name_partContext::getRuleIndex() const
{
    return VHDLParser::RuleName_part;
}

void VHDLParser::Name_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterName_part(this);
}

void VHDLParser::Name_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitName_part(this);
}

std::any VHDLParser::Name_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitName_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Name_partContext *VHDLParser::name_part()
{
    Name_partContext *_localctx = _tracker.createInstance<Name_partContext>(_ctx, getState());
    enterRule(_localctx, 294, VHDLParser::RuleName_part);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1675);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 170, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(1671);
            selected_name_part();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(1672);
            function_call_or_indexed_name_part();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(1673);
            slice_name_part();
            break;
        }

        case 4: {
            enterOuterAlt(_localctx, 4);
            setState(1674);
            attribute_name_part();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Selected_nameContext
//------------------------------------------------------------------

VHDLParser::Selected_nameContext::Selected_nameContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::IdentifierContext *VHDLParser::Selected_nameContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

std::vector<tree::TerminalNode *> VHDLParser::Selected_nameContext::DOT()
{
    return getTokens(VHDLParser::DOT);
}

tree::TerminalNode *VHDLParser::Selected_nameContext::DOT(size_t i)
{
    return getToken(VHDLParser::DOT, i);
}

std::vector<VHDLParser::SuffixContext *> VHDLParser::Selected_nameContext::suffix()
{
    return getRuleContexts<VHDLParser::SuffixContext>();
}

VHDLParser::SuffixContext *VHDLParser::Selected_nameContext::suffix(size_t i)
{
    return getRuleContext<VHDLParser::SuffixContext>(i);
}

size_t VHDLParser::Selected_nameContext::getRuleIndex() const
{
    return VHDLParser::RuleSelected_name;
}

void VHDLParser::Selected_nameContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSelected_name(this);
}

void VHDLParser::Selected_nameContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSelected_name(this);
}

std::any VHDLParser::Selected_nameContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSelected_name(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Selected_nameContext *VHDLParser::selected_name()
{
    Selected_nameContext *_localctx = _tracker.createInstance<Selected_nameContext>(_ctx, getState());
    enterRule(_localctx, 296, VHDLParser::RuleSelected_name);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1677);
        identifier();
        setState(1682);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::DOT)
        {
            setState(1678);
            match(VHDLParser::DOT);
            setState(1679);
            suffix();
            setState(1684);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Selected_name_partContext
//------------------------------------------------------------------

VHDLParser::Selected_name_partContext::Selected_name_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::Selected_name_partContext::DOT()
{
    return getTokens(VHDLParser::DOT);
}

tree::TerminalNode *VHDLParser::Selected_name_partContext::DOT(size_t i)
{
    return getToken(VHDLParser::DOT, i);
}

std::vector<VHDLParser::SuffixContext *> VHDLParser::Selected_name_partContext::suffix()
{
    return getRuleContexts<VHDLParser::SuffixContext>();
}

VHDLParser::SuffixContext *VHDLParser::Selected_name_partContext::suffix(size_t i)
{
    return getRuleContext<VHDLParser::SuffixContext>(i);
}

size_t VHDLParser::Selected_name_partContext::getRuleIndex() const
{
    return VHDLParser::RuleSelected_name_part;
}

void VHDLParser::Selected_name_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSelected_name_part(this);
}

void VHDLParser::Selected_name_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSelected_name_part(this);
}

std::any VHDLParser::Selected_name_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSelected_name_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Selected_name_partContext *VHDLParser::selected_name_part()
{
    Selected_name_partContext *_localctx = _tracker.createInstance<Selected_name_partContext>(_ctx, getState());
    enterRule(_localctx, 298, VHDLParser::RuleSelected_name_part);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(1687);
        _errHandler->sync(this);
        alt = 1;
        do
        {
            switch (alt)
            {
            case 1: {
                setState(1685);
                match(VHDLParser::DOT);
                setState(1686);
                suffix();
                break;
            }

            default:
                throw NoViableAltException(this);
            }
            setState(1689);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Function_call_or_indexed_name_partContext
//------------------------------------------------------------------

VHDLParser::Function_call_or_indexed_name_partContext::Function_call_or_indexed_name_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Function_call_or_indexed_name_partContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::Actual_parameter_partContext *VHDLParser::Function_call_or_indexed_name_partContext::actual_parameter_part()
{
    return getRuleContext<VHDLParser::Actual_parameter_partContext>(0);
}

tree::TerminalNode *VHDLParser::Function_call_or_indexed_name_partContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

size_t VHDLParser::Function_call_or_indexed_name_partContext::getRuleIndex() const
{
    return VHDLParser::RuleFunction_call_or_indexed_name_part;
}

void VHDLParser::Function_call_or_indexed_name_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterFunction_call_or_indexed_name_part(this);
}

void VHDLParser::Function_call_or_indexed_name_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitFunction_call_or_indexed_name_part(this);
}

std::any VHDLParser::Function_call_or_indexed_name_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitFunction_call_or_indexed_name_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Function_call_or_indexed_name_partContext *VHDLParser::function_call_or_indexed_name_part()
{
    Function_call_or_indexed_name_partContext *_localctx = _tracker.createInstance<Function_call_or_indexed_name_partContext>(_ctx, getState());
    enterRule(_localctx, 300, VHDLParser::RuleFunction_call_or_indexed_name_part);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1691);
        match(VHDLParser::LPAREN);
        setState(1692);
        actual_parameter_part();
        setState(1693);
        match(VHDLParser::RPAREN);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Slice_name_partContext
//------------------------------------------------------------------

VHDLParser::Slice_name_partContext::Slice_name_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Slice_name_partContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::Discrete_rangeContext *VHDLParser::Slice_name_partContext::discrete_range()
{
    return getRuleContext<VHDLParser::Discrete_rangeContext>(0);
}

tree::TerminalNode *VHDLParser::Slice_name_partContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

size_t VHDLParser::Slice_name_partContext::getRuleIndex() const
{
    return VHDLParser::RuleSlice_name_part;
}

void VHDLParser::Slice_name_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSlice_name_part(this);
}

void VHDLParser::Slice_name_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSlice_name_part(this);
}

std::any VHDLParser::Slice_name_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSlice_name_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Slice_name_partContext *VHDLParser::slice_name_part()
{
    Slice_name_partContext *_localctx = _tracker.createInstance<Slice_name_partContext>(_ctx, getState());
    enterRule(_localctx, 302, VHDLParser::RuleSlice_name_part);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1695);
        match(VHDLParser::LPAREN);
        setState(1696);
        discrete_range();
        setState(1697);
        match(VHDLParser::RPAREN);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Attribute_name_partContext
//------------------------------------------------------------------

VHDLParser::Attribute_name_partContext::Attribute_name_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Attribute_name_partContext::APOSTROPHE()
{
    return getToken(VHDLParser::APOSTROPHE, 0);
}

VHDLParser::Attribute_designatorContext *VHDLParser::Attribute_name_partContext::attribute_designator()
{
    return getRuleContext<VHDLParser::Attribute_designatorContext>(0);
}

VHDLParser::SignatureContext *VHDLParser::Attribute_name_partContext::signature()
{
    return getRuleContext<VHDLParser::SignatureContext>(0);
}

tree::TerminalNode *VHDLParser::Attribute_name_partContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Attribute_name_partContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

tree::TerminalNode *VHDLParser::Attribute_name_partContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

size_t VHDLParser::Attribute_name_partContext::getRuleIndex() const
{
    return VHDLParser::RuleAttribute_name_part;
}

void VHDLParser::Attribute_name_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterAttribute_name_part(this);
}

void VHDLParser::Attribute_name_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitAttribute_name_part(this);
}

std::any VHDLParser::Attribute_name_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitAttribute_name_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Attribute_name_partContext *VHDLParser::attribute_name_part()
{
    Attribute_name_partContext *_localctx = _tracker.createInstance<Attribute_name_partContext>(_ctx, getState());
    enterRule(_localctx, 304, VHDLParser::RuleAttribute_name_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1700);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::LBRACKET)
        {
            setState(1699);
            signature();
        }
        setState(1702);
        match(VHDLParser::APOSTROPHE);
        setState(1703);
        attribute_designator();
        setState(1708);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx))
        {
        case 1: {
            setState(1704);
            match(VHDLParser::LPAREN);
            setState(1705);
            expression();
            setState(1706);
            match(VHDLParser::RPAREN);
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Nature_declarationContext
//------------------------------------------------------------------

VHDLParser::Nature_declarationContext::Nature_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Nature_declarationContext::NATURE()
{
    return getToken(VHDLParser::NATURE, 0);
}

VHDLParser::IdentifierContext *VHDLParser::Nature_declarationContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Nature_declarationContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::Nature_definitionContext *VHDLParser::Nature_declarationContext::nature_definition()
{
    return getRuleContext<VHDLParser::Nature_definitionContext>(0);
}

tree::TerminalNode *VHDLParser::Nature_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Nature_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleNature_declaration;
}

void VHDLParser::Nature_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterNature_declaration(this);
}

void VHDLParser::Nature_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitNature_declaration(this);
}

std::any VHDLParser::Nature_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitNature_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Nature_declarationContext *VHDLParser::nature_declaration()
{
    Nature_declarationContext *_localctx = _tracker.createInstance<Nature_declarationContext>(_ctx, getState());
    enterRule(_localctx, 306, VHDLParser::RuleNature_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1710);
        match(VHDLParser::NATURE);
        setState(1711);
        identifier();
        setState(1712);
        match(VHDLParser::IS);
        setState(1713);
        nature_definition();
        setState(1714);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Nature_definitionContext
//------------------------------------------------------------------

VHDLParser::Nature_definitionContext::Nature_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Scalar_nature_definitionContext *VHDLParser::Nature_definitionContext::scalar_nature_definition()
{
    return getRuleContext<VHDLParser::Scalar_nature_definitionContext>(0);
}

VHDLParser::Composite_nature_definitionContext *VHDLParser::Nature_definitionContext::composite_nature_definition()
{
    return getRuleContext<VHDLParser::Composite_nature_definitionContext>(0);
}

size_t VHDLParser::Nature_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleNature_definition;
}

void VHDLParser::Nature_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterNature_definition(this);
}

void VHDLParser::Nature_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitNature_definition(this);
}

std::any VHDLParser::Nature_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitNature_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Nature_definitionContext *VHDLParser::nature_definition()
{
    Nature_definitionContext *_localctx = _tracker.createInstance<Nature_definitionContext>(_ctx, getState());
    enterRule(_localctx, 308, VHDLParser::RuleNature_definition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1718);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER:
        case VHDLParser::STRING_LITERAL: {
            enterOuterAlt(_localctx, 1);
            setState(1716);
            scalar_nature_definition();
            break;
        }

        case VHDLParser::ARRAY:
        case VHDLParser::RECORD: {
            enterOuterAlt(_localctx, 2);
            setState(1717);
            composite_nature_definition();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Nature_element_declarationContext
//------------------------------------------------------------------

VHDLParser::Nature_element_declarationContext::Nature_element_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Identifier_listContext *VHDLParser::Nature_element_declarationContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Nature_element_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Element_subnature_definitionContext *VHDLParser::Nature_element_declarationContext::element_subnature_definition()
{
    return getRuleContext<VHDLParser::Element_subnature_definitionContext>(0);
}

size_t VHDLParser::Nature_element_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleNature_element_declaration;
}

void VHDLParser::Nature_element_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterNature_element_declaration(this);
}

void VHDLParser::Nature_element_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitNature_element_declaration(this);
}

std::any VHDLParser::Nature_element_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitNature_element_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Nature_element_declarationContext *VHDLParser::nature_element_declaration()
{
    Nature_element_declarationContext *_localctx = _tracker.createInstance<Nature_element_declarationContext>(_ctx, getState());
    enterRule(_localctx, 310, VHDLParser::RuleNature_element_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1720);
        identifier_list();
        setState(1721);
        match(VHDLParser::COLON);
        setState(1722);
        element_subnature_definition();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Next_statementContext
//------------------------------------------------------------------

VHDLParser::Next_statementContext::Next_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Next_statementContext::NEXT()
{
    return getToken(VHDLParser::NEXT, 0);
}

tree::TerminalNode *VHDLParser::Next_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Next_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

VHDLParser::IdentifierContext *VHDLParser::Next_statementContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Next_statementContext::WHEN()
{
    return getToken(VHDLParser::WHEN, 0);
}

VHDLParser::ConditionContext *VHDLParser::Next_statementContext::condition()
{
    return getRuleContext<VHDLParser::ConditionContext>(0);
}

size_t VHDLParser::Next_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleNext_statement;
}

void VHDLParser::Next_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterNext_statement(this);
}

void VHDLParser::Next_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitNext_statement(this);
}

std::any VHDLParser::Next_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitNext_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Next_statementContext *VHDLParser::next_statement()
{
    Next_statementContext *_localctx = _tracker.createInstance<Next_statementContext>(_ctx, getState());
    enterRule(_localctx, 312, VHDLParser::RuleNext_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1725);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1724);
            label_colon();
        }
        setState(1727);
        match(VHDLParser::NEXT);
        setState(1729);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1728);
            identifier();
        }
        setState(1733);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::WHEN)
        {
            setState(1731);
            match(VHDLParser::WHEN);
            setState(1732);
            condition();
        }
        setState(1735);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Numeric_literalContext
//------------------------------------------------------------------

VHDLParser::Numeric_literalContext::Numeric_literalContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Abstract_literalContext *VHDLParser::Numeric_literalContext::abstract_literal()
{
    return getRuleContext<VHDLParser::Abstract_literalContext>(0);
}

VHDLParser::Physical_literalContext *VHDLParser::Numeric_literalContext::physical_literal()
{
    return getRuleContext<VHDLParser::Physical_literalContext>(0);
}

size_t VHDLParser::Numeric_literalContext::getRuleIndex() const
{
    return VHDLParser::RuleNumeric_literal;
}

void VHDLParser::Numeric_literalContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterNumeric_literal(this);
}

void VHDLParser::Numeric_literalContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitNumeric_literal(this);
}

std::any VHDLParser::Numeric_literalContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitNumeric_literal(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Numeric_literalContext *VHDLParser::numeric_literal()
{
    Numeric_literalContext *_localctx = _tracker.createInstance<Numeric_literalContext>(_ctx, getState());
    enterRule(_localctx, 314, VHDLParser::RuleNumeric_literal);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1739);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(1737);
            abstract_literal();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(1738);
            physical_literal();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Object_declarationContext
//------------------------------------------------------------------

VHDLParser::Object_declarationContext::Object_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Constant_declarationContext *VHDLParser::Object_declarationContext::constant_declaration()
{
    return getRuleContext<VHDLParser::Constant_declarationContext>(0);
}

VHDLParser::Signal_declarationContext *VHDLParser::Object_declarationContext::signal_declaration()
{
    return getRuleContext<VHDLParser::Signal_declarationContext>(0);
}

VHDLParser::Variable_declarationContext *VHDLParser::Object_declarationContext::variable_declaration()
{
    return getRuleContext<VHDLParser::Variable_declarationContext>(0);
}

VHDLParser::File_declarationContext *VHDLParser::Object_declarationContext::file_declaration()
{
    return getRuleContext<VHDLParser::File_declarationContext>(0);
}

VHDLParser::Terminal_declarationContext *VHDLParser::Object_declarationContext::terminal_declaration()
{
    return getRuleContext<VHDLParser::Terminal_declarationContext>(0);
}

VHDLParser::Quantity_declarationContext *VHDLParser::Object_declarationContext::quantity_declaration()
{
    return getRuleContext<VHDLParser::Quantity_declarationContext>(0);
}

size_t VHDLParser::Object_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleObject_declaration;
}

void VHDLParser::Object_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterObject_declaration(this);
}

void VHDLParser::Object_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitObject_declaration(this);
}

std::any VHDLParser::Object_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitObject_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Object_declarationContext *VHDLParser::object_declaration()
{
    Object_declarationContext *_localctx = _tracker.createInstance<Object_declarationContext>(_ctx, getState());
    enterRule(_localctx, 316, VHDLParser::RuleObject_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1747);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::CONSTANT: {
            enterOuterAlt(_localctx, 1);
            setState(1741);
            constant_declaration();
            break;
        }

        case VHDLParser::SIGNAL: {
            enterOuterAlt(_localctx, 2);
            setState(1742);
            signal_declaration();
            break;
        }

        case VHDLParser::SHARED:
        case VHDLParser::VARIABLE: {
            enterOuterAlt(_localctx, 3);
            setState(1743);
            variable_declaration();
            break;
        }

        case VHDLParser::FILE: {
            enterOuterAlt(_localctx, 4);
            setState(1744);
            file_declaration();
            break;
        }

        case VHDLParser::TERMINAL: {
            enterOuterAlt(_localctx, 5);
            setState(1745);
            terminal_declaration();
            break;
        }

        case VHDLParser::QUANTITY: {
            enterOuterAlt(_localctx, 6);
            setState(1746);
            quantity_declaration();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- OptsContext
//------------------------------------------------------------------

VHDLParser::OptsContext::OptsContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::OptsContext::GUARDED()
{
    return getToken(VHDLParser::GUARDED, 0);
}

VHDLParser::Delay_mechanismContext *VHDLParser::OptsContext::delay_mechanism()
{
    return getRuleContext<VHDLParser::Delay_mechanismContext>(0);
}

size_t VHDLParser::OptsContext::getRuleIndex() const
{
    return VHDLParser::RuleOpts;
}

void VHDLParser::OptsContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterOpts(this);
}

void VHDLParser::OptsContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitOpts(this);
}

std::any VHDLParser::OptsContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitOpts(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::OptsContext *VHDLParser::opts()
{
    OptsContext *_localctx = _tracker.createInstance<OptsContext>(_ctx, getState());
    enterRule(_localctx, 318, VHDLParser::RuleOpts);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1750);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::GUARDED)
        {
            setState(1749);
            match(VHDLParser::GUARDED);
        }
        setState(1753);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 39) & ~0x3fULL) == 0) && ((1ULL << (_la - 39)) & 1152921538966585345) != 0))
        {
            setState(1752);
            delay_mechanism();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Package_bodyContext
//------------------------------------------------------------------

VHDLParser::Package_bodyContext::Package_bodyContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::Package_bodyContext::PACKAGE()
{
    return getTokens(VHDLParser::PACKAGE);
}

tree::TerminalNode *VHDLParser::Package_bodyContext::PACKAGE(size_t i)
{
    return getToken(VHDLParser::PACKAGE, i);
}

std::vector<tree::TerminalNode *> VHDLParser::Package_bodyContext::BODY()
{
    return getTokens(VHDLParser::BODY);
}

tree::TerminalNode *VHDLParser::Package_bodyContext::BODY(size_t i)
{
    return getToken(VHDLParser::BODY, i);
}

std::vector<VHDLParser::IdentifierContext *> VHDLParser::Package_bodyContext::identifier()
{
    return getRuleContexts<VHDLParser::IdentifierContext>();
}

VHDLParser::IdentifierContext *VHDLParser::Package_bodyContext::identifier(size_t i)
{
    return getRuleContext<VHDLParser::IdentifierContext>(i);
}

tree::TerminalNode *VHDLParser::Package_bodyContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::Package_body_declarative_partContext *VHDLParser::Package_bodyContext::package_body_declarative_part()
{
    return getRuleContext<VHDLParser::Package_body_declarative_partContext>(0);
}

tree::TerminalNode *VHDLParser::Package_bodyContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::Package_bodyContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Package_bodyContext::getRuleIndex() const
{
    return VHDLParser::RulePackage_body;
}

void VHDLParser::Package_bodyContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterPackage_body(this);
}

void VHDLParser::Package_bodyContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitPackage_body(this);
}

std::any VHDLParser::Package_bodyContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitPackage_body(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Package_bodyContext *VHDLParser::package_body()
{
    Package_bodyContext *_localctx = _tracker.createInstance<Package_bodyContext>(_ctx, getState());
    enterRule(_localctx, 320, VHDLParser::RulePackage_body);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1755);
        match(VHDLParser::PACKAGE);
        setState(1756);
        match(VHDLParser::BODY);
        setState(1757);
        identifier();
        setState(1758);
        match(VHDLParser::IS);
        setState(1759);
        package_body_declarative_part();
        setState(1760);
        match(VHDLParser::END);
        setState(1763);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::PACKAGE)
        {
            setState(1761);
            match(VHDLParser::PACKAGE);
            setState(1762);
            match(VHDLParser::BODY);
        }
        setState(1766);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1765);
            identifier();
        }
        setState(1768);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Package_body_declarative_itemContext
//------------------------------------------------------------------

VHDLParser::Package_body_declarative_itemContext::Package_body_declarative_itemContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Subprogram_declarationContext *VHDLParser::Package_body_declarative_itemContext::subprogram_declaration()
{
    return getRuleContext<VHDLParser::Subprogram_declarationContext>(0);
}

VHDLParser::Subprogram_bodyContext *VHDLParser::Package_body_declarative_itemContext::subprogram_body()
{
    return getRuleContext<VHDLParser::Subprogram_bodyContext>(0);
}

VHDLParser::Type_declarationContext *VHDLParser::Package_body_declarative_itemContext::type_declaration()
{
    return getRuleContext<VHDLParser::Type_declarationContext>(0);
}

VHDLParser::Subtype_declarationContext *VHDLParser::Package_body_declarative_itemContext::subtype_declaration()
{
    return getRuleContext<VHDLParser::Subtype_declarationContext>(0);
}

VHDLParser::Constant_declarationContext *VHDLParser::Package_body_declarative_itemContext::constant_declaration()
{
    return getRuleContext<VHDLParser::Constant_declarationContext>(0);
}

VHDLParser::Variable_declarationContext *VHDLParser::Package_body_declarative_itemContext::variable_declaration()
{
    return getRuleContext<VHDLParser::Variable_declarationContext>(0);
}

VHDLParser::File_declarationContext *VHDLParser::Package_body_declarative_itemContext::file_declaration()
{
    return getRuleContext<VHDLParser::File_declarationContext>(0);
}

VHDLParser::Alias_declarationContext *VHDLParser::Package_body_declarative_itemContext::alias_declaration()
{
    return getRuleContext<VHDLParser::Alias_declarationContext>(0);
}

VHDLParser::Use_clauseContext *VHDLParser::Package_body_declarative_itemContext::use_clause()
{
    return getRuleContext<VHDLParser::Use_clauseContext>(0);
}

VHDLParser::Group_template_declarationContext *VHDLParser::Package_body_declarative_itemContext::group_template_declaration()
{
    return getRuleContext<VHDLParser::Group_template_declarationContext>(0);
}

VHDLParser::Group_declarationContext *VHDLParser::Package_body_declarative_itemContext::group_declaration()
{
    return getRuleContext<VHDLParser::Group_declarationContext>(0);
}

size_t VHDLParser::Package_body_declarative_itemContext::getRuleIndex() const
{
    return VHDLParser::RulePackage_body_declarative_item;
}

void VHDLParser::Package_body_declarative_itemContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterPackage_body_declarative_item(this);
}

void VHDLParser::Package_body_declarative_itemContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitPackage_body_declarative_item(this);
}

std::any VHDLParser::Package_body_declarative_itemContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitPackage_body_declarative_item(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Package_body_declarative_itemContext *VHDLParser::package_body_declarative_item()
{
    Package_body_declarative_itemContext *_localctx = _tracker.createInstance<Package_body_declarative_itemContext>(_ctx, getState());
    enterRule(_localctx, 322, VHDLParser::RulePackage_body_declarative_item);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1781);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 185, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(1770);
            subprogram_declaration();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(1771);
            subprogram_body();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(1772);
            type_declaration();
            break;
        }

        case 4: {
            enterOuterAlt(_localctx, 4);
            setState(1773);
            subtype_declaration();
            break;
        }

        case 5: {
            enterOuterAlt(_localctx, 5);
            setState(1774);
            constant_declaration();
            break;
        }

        case 6: {
            enterOuterAlt(_localctx, 6);
            setState(1775);
            variable_declaration();
            break;
        }

        case 7: {
            enterOuterAlt(_localctx, 7);
            setState(1776);
            file_declaration();
            break;
        }

        case 8: {
            enterOuterAlt(_localctx, 8);
            setState(1777);
            alias_declaration();
            break;
        }

        case 9: {
            enterOuterAlt(_localctx, 9);
            setState(1778);
            use_clause();
            break;
        }

        case 10: {
            enterOuterAlt(_localctx, 10);
            setState(1779);
            group_template_declaration();
            break;
        }

        case 11: {
            enterOuterAlt(_localctx, 11);
            setState(1780);
            group_declaration();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Package_body_declarative_partContext
//------------------------------------------------------------------

VHDLParser::Package_body_declarative_partContext::Package_body_declarative_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Package_body_declarative_itemContext *> VHDLParser::Package_body_declarative_partContext::package_body_declarative_item()
{
    return getRuleContexts<VHDLParser::Package_body_declarative_itemContext>();
}

VHDLParser::Package_body_declarative_itemContext *VHDLParser::Package_body_declarative_partContext::package_body_declarative_item(size_t i)
{
    return getRuleContext<VHDLParser::Package_body_declarative_itemContext>(i);
}

size_t VHDLParser::Package_body_declarative_partContext::getRuleIndex() const
{
    return VHDLParser::RulePackage_body_declarative_part;
}

void VHDLParser::Package_body_declarative_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterPackage_body_declarative_part(this);
}

void VHDLParser::Package_body_declarative_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitPackage_body_declarative_part(this);
}

std::any VHDLParser::Package_body_declarative_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitPackage_body_declarative_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Package_body_declarative_partContext *VHDLParser::package_body_declarative_part()
{
    Package_body_declarative_partContext *_localctx = _tracker.createInstance<Package_body_declarative_partContext>(_ctx, getState());
    enterRule(_localctx, 324, VHDLParser::RulePackage_body_declarative_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1786);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 157305274400) != 0) || ((((_la - 68) & ~0x3fULL) == 0) && ((1ULL << (_la - 68)) & 210487083013) != 0))
        {
            setState(1783);
            package_body_declarative_item();
            setState(1788);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Package_declarationContext
//------------------------------------------------------------------

VHDLParser::Package_declarationContext::Package_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::Package_declarationContext::PACKAGE()
{
    return getTokens(VHDLParser::PACKAGE);
}

tree::TerminalNode *VHDLParser::Package_declarationContext::PACKAGE(size_t i)
{
    return getToken(VHDLParser::PACKAGE, i);
}

std::vector<VHDLParser::IdentifierContext *> VHDLParser::Package_declarationContext::identifier()
{
    return getRuleContexts<VHDLParser::IdentifierContext>();
}

VHDLParser::IdentifierContext *VHDLParser::Package_declarationContext::identifier(size_t i)
{
    return getRuleContext<VHDLParser::IdentifierContext>(i);
}

tree::TerminalNode *VHDLParser::Package_declarationContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::Package_declarative_partContext *VHDLParser::Package_declarationContext::package_declarative_part()
{
    return getRuleContext<VHDLParser::Package_declarative_partContext>(0);
}

tree::TerminalNode *VHDLParser::Package_declarationContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::Package_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Package_declarationContext::getRuleIndex() const
{
    return VHDLParser::RulePackage_declaration;
}

void VHDLParser::Package_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterPackage_declaration(this);
}

void VHDLParser::Package_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitPackage_declaration(this);
}

std::any VHDLParser::Package_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitPackage_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Package_declarationContext *VHDLParser::package_declaration()
{
    Package_declarationContext *_localctx = _tracker.createInstance<Package_declarationContext>(_ctx, getState());
    enterRule(_localctx, 326, VHDLParser::RulePackage_declaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1789);
        match(VHDLParser::PACKAGE);
        setState(1790);
        identifier();
        setState(1791);
        match(VHDLParser::IS);
        setState(1792);
        package_declarative_part();
        setState(1793);
        match(VHDLParser::END);
        setState(1795);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::PACKAGE)
        {
            setState(1794);
            match(VHDLParser::PACKAGE);
        }
        setState(1798);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1797);
            identifier();
        }
        setState(1800);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Package_declarative_itemContext
//------------------------------------------------------------------

VHDLParser::Package_declarative_itemContext::Package_declarative_itemContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Subprogram_declarationContext *VHDLParser::Package_declarative_itemContext::subprogram_declaration()
{
    return getRuleContext<VHDLParser::Subprogram_declarationContext>(0);
}

VHDLParser::Subprogram_bodyContext *VHDLParser::Package_declarative_itemContext::subprogram_body()
{
    return getRuleContext<VHDLParser::Subprogram_bodyContext>(0);
}

VHDLParser::Type_declarationContext *VHDLParser::Package_declarative_itemContext::type_declaration()
{
    return getRuleContext<VHDLParser::Type_declarationContext>(0);
}

VHDLParser::Subtype_declarationContext *VHDLParser::Package_declarative_itemContext::subtype_declaration()
{
    return getRuleContext<VHDLParser::Subtype_declarationContext>(0);
}

VHDLParser::Constant_declarationContext *VHDLParser::Package_declarative_itemContext::constant_declaration()
{
    return getRuleContext<VHDLParser::Constant_declarationContext>(0);
}

VHDLParser::Signal_declarationContext *VHDLParser::Package_declarative_itemContext::signal_declaration()
{
    return getRuleContext<VHDLParser::Signal_declarationContext>(0);
}

VHDLParser::Variable_declarationContext *VHDLParser::Package_declarative_itemContext::variable_declaration()
{
    return getRuleContext<VHDLParser::Variable_declarationContext>(0);
}

VHDLParser::File_declarationContext *VHDLParser::Package_declarative_itemContext::file_declaration()
{
    return getRuleContext<VHDLParser::File_declarationContext>(0);
}

VHDLParser::Alias_declarationContext *VHDLParser::Package_declarative_itemContext::alias_declaration()
{
    return getRuleContext<VHDLParser::Alias_declarationContext>(0);
}

VHDLParser::Component_declarationContext *VHDLParser::Package_declarative_itemContext::component_declaration()
{
    return getRuleContext<VHDLParser::Component_declarationContext>(0);
}

VHDLParser::Attribute_declarationContext *VHDLParser::Package_declarative_itemContext::attribute_declaration()
{
    return getRuleContext<VHDLParser::Attribute_declarationContext>(0);
}

VHDLParser::Attribute_specificationContext *VHDLParser::Package_declarative_itemContext::attribute_specification()
{
    return getRuleContext<VHDLParser::Attribute_specificationContext>(0);
}

VHDLParser::Disconnection_specificationContext *VHDLParser::Package_declarative_itemContext::disconnection_specification()
{
    return getRuleContext<VHDLParser::Disconnection_specificationContext>(0);
}

VHDLParser::Use_clauseContext *VHDLParser::Package_declarative_itemContext::use_clause()
{
    return getRuleContext<VHDLParser::Use_clauseContext>(0);
}

VHDLParser::Group_template_declarationContext *VHDLParser::Package_declarative_itemContext::group_template_declaration()
{
    return getRuleContext<VHDLParser::Group_template_declarationContext>(0);
}

VHDLParser::Group_declarationContext *VHDLParser::Package_declarative_itemContext::group_declaration()
{
    return getRuleContext<VHDLParser::Group_declarationContext>(0);
}

VHDLParser::Nature_declarationContext *VHDLParser::Package_declarative_itemContext::nature_declaration()
{
    return getRuleContext<VHDLParser::Nature_declarationContext>(0);
}

VHDLParser::Subnature_declarationContext *VHDLParser::Package_declarative_itemContext::subnature_declaration()
{
    return getRuleContext<VHDLParser::Subnature_declarationContext>(0);
}

VHDLParser::Terminal_declarationContext *VHDLParser::Package_declarative_itemContext::terminal_declaration()
{
    return getRuleContext<VHDLParser::Terminal_declarationContext>(0);
}

size_t VHDLParser::Package_declarative_itemContext::getRuleIndex() const
{
    return VHDLParser::RulePackage_declarative_item;
}

void VHDLParser::Package_declarative_itemContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterPackage_declarative_item(this);
}

void VHDLParser::Package_declarative_itemContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitPackage_declarative_item(this);
}

std::any VHDLParser::Package_declarative_itemContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitPackage_declarative_item(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Package_declarative_itemContext *VHDLParser::package_declarative_item()
{
    Package_declarative_itemContext *_localctx = _tracker.createInstance<Package_declarative_itemContext>(_ctx, getState());
    enterRule(_localctx, 328, VHDLParser::RulePackage_declarative_item);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1821);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 189, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(1802);
            subprogram_declaration();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(1803);
            subprogram_body();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(1804);
            type_declaration();
            break;
        }

        case 4: {
            enterOuterAlt(_localctx, 4);
            setState(1805);
            subtype_declaration();
            break;
        }

        case 5: {
            enterOuterAlt(_localctx, 5);
            setState(1806);
            constant_declaration();
            break;
        }

        case 6: {
            enterOuterAlt(_localctx, 6);
            setState(1807);
            signal_declaration();
            break;
        }

        case 7: {
            enterOuterAlt(_localctx, 7);
            setState(1808);
            variable_declaration();
            break;
        }

        case 8: {
            enterOuterAlt(_localctx, 8);
            setState(1809);
            file_declaration();
            break;
        }

        case 9: {
            enterOuterAlt(_localctx, 9);
            setState(1810);
            alias_declaration();
            break;
        }

        case 10: {
            enterOuterAlt(_localctx, 10);
            setState(1811);
            component_declaration();
            break;
        }

        case 11: {
            enterOuterAlt(_localctx, 11);
            setState(1812);
            attribute_declaration();
            break;
        }

        case 12: {
            enterOuterAlt(_localctx, 12);
            setState(1813);
            attribute_specification();
            break;
        }

        case 13: {
            enterOuterAlt(_localctx, 13);
            setState(1814);
            disconnection_specification();
            break;
        }

        case 14: {
            enterOuterAlt(_localctx, 14);
            setState(1815);
            use_clause();
            break;
        }

        case 15: {
            enterOuterAlt(_localctx, 15);
            setState(1816);
            group_template_declaration();
            break;
        }

        case 16: {
            enterOuterAlt(_localctx, 16);
            setState(1817);
            group_declaration();
            break;
        }

        case 17: {
            enterOuterAlt(_localctx, 17);
            setState(1818);
            nature_declaration();
            break;
        }

        case 18: {
            enterOuterAlt(_localctx, 18);
            setState(1819);
            subnature_declaration();
            break;
        }

        case 19: {
            enterOuterAlt(_localctx, 19);
            setState(1820);
            terminal_declaration();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Package_declarative_partContext
//------------------------------------------------------------------

VHDLParser::Package_declarative_partContext::Package_declarative_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Package_declarative_itemContext *> VHDLParser::Package_declarative_partContext::package_declarative_item()
{
    return getRuleContexts<VHDLParser::Package_declarative_itemContext>();
}

VHDLParser::Package_declarative_itemContext *VHDLParser::Package_declarative_partContext::package_declarative_item(size_t i)
{
    return getRuleContext<VHDLParser::Package_declarative_itemContext>(i);
}

size_t VHDLParser::Package_declarative_partContext::getRuleIndex() const
{
    return VHDLParser::RulePackage_declarative_part;
}

void VHDLParser::Package_declarative_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterPackage_declarative_part(this);
}

void VHDLParser::Package_declarative_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitPackage_declarative_part(this);
}

std::any VHDLParser::Package_declarative_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitPackage_declarative_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Package_declarative_partContext *VHDLParser::package_declarative_part()
{
    Package_declarative_partContext *_localctx = _tracker.createInstance<Package_declarative_partContext>(_ctx, getState());
    enterRule(_localctx, 330, VHDLParser::RulePackage_declarative_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1826);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 2251957123680288) != 0) || ((((_la - 68) & ~0x3fULL) == 0) && ((1ULL << (_la - 68)) & 210571231237) != 0))
        {
            setState(1823);
            package_declarative_item();
            setState(1828);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Parameter_specificationContext
//------------------------------------------------------------------

VHDLParser::Parameter_specificationContext::Parameter_specificationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::IdentifierContext *VHDLParser::Parameter_specificationContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Parameter_specificationContext::IN()
{
    return getToken(VHDLParser::IN, 0);
}

VHDLParser::Discrete_rangeContext *VHDLParser::Parameter_specificationContext::discrete_range()
{
    return getRuleContext<VHDLParser::Discrete_rangeContext>(0);
}

size_t VHDLParser::Parameter_specificationContext::getRuleIndex() const
{
    return VHDLParser::RuleParameter_specification;
}

void VHDLParser::Parameter_specificationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterParameter_specification(this);
}

void VHDLParser::Parameter_specificationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitParameter_specification(this);
}

std::any VHDLParser::Parameter_specificationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitParameter_specification(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Parameter_specificationContext *VHDLParser::parameter_specification()
{
    Parameter_specificationContext *_localctx = _tracker.createInstance<Parameter_specificationContext>(_ctx, getState());
    enterRule(_localctx, 332, VHDLParser::RuleParameter_specification);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1829);
        identifier();
        setState(1830);
        match(VHDLParser::IN);
        setState(1831);
        discrete_range();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Physical_literalContext
//------------------------------------------------------------------

VHDLParser::Physical_literalContext::Physical_literalContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Abstract_literalContext *VHDLParser::Physical_literalContext::abstract_literal()
{
    return getRuleContext<VHDLParser::Abstract_literalContext>(0);
}

VHDLParser::IdentifierContext *VHDLParser::Physical_literalContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

size_t VHDLParser::Physical_literalContext::getRuleIndex() const
{
    return VHDLParser::RulePhysical_literal;
}

void VHDLParser::Physical_literalContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterPhysical_literal(this);
}

void VHDLParser::Physical_literalContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitPhysical_literal(this);
}

std::any VHDLParser::Physical_literalContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitPhysical_literal(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Physical_literalContext *VHDLParser::physical_literal()
{
    Physical_literalContext *_localctx = _tracker.createInstance<Physical_literalContext>(_ctx, getState());
    enterRule(_localctx, 334, VHDLParser::RulePhysical_literal);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1833);
        abstract_literal();

        setState(1834);
        identifier();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Physical_type_definitionContext
//------------------------------------------------------------------

VHDLParser::Physical_type_definitionContext::Physical_type_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Range_constraintContext *VHDLParser::Physical_type_definitionContext::range_constraint()
{
    return getRuleContext<VHDLParser::Range_constraintContext>(0);
}

std::vector<tree::TerminalNode *> VHDLParser::Physical_type_definitionContext::UNITS()
{
    return getTokens(VHDLParser::UNITS);
}

tree::TerminalNode *VHDLParser::Physical_type_definitionContext::UNITS(size_t i)
{
    return getToken(VHDLParser::UNITS, i);
}

VHDLParser::Base_unit_declarationContext *VHDLParser::Physical_type_definitionContext::base_unit_declaration()
{
    return getRuleContext<VHDLParser::Base_unit_declarationContext>(0);
}

tree::TerminalNode *VHDLParser::Physical_type_definitionContext::END()
{
    return getToken(VHDLParser::END, 0);
}

std::vector<VHDLParser::Secondary_unit_declarationContext *> VHDLParser::Physical_type_definitionContext::secondary_unit_declaration()
{
    return getRuleContexts<VHDLParser::Secondary_unit_declarationContext>();
}

VHDLParser::Secondary_unit_declarationContext *VHDLParser::Physical_type_definitionContext::secondary_unit_declaration(size_t i)
{
    return getRuleContext<VHDLParser::Secondary_unit_declarationContext>(i);
}

VHDLParser::IdentifierContext *VHDLParser::Physical_type_definitionContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

size_t VHDLParser::Physical_type_definitionContext::getRuleIndex() const
{
    return VHDLParser::RulePhysical_type_definition;
}

void VHDLParser::Physical_type_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterPhysical_type_definition(this);
}

void VHDLParser::Physical_type_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitPhysical_type_definition(this);
}

std::any VHDLParser::Physical_type_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitPhysical_type_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Physical_type_definitionContext *VHDLParser::physical_type_definition()
{
    Physical_type_definitionContext *_localctx = _tracker.createInstance<Physical_type_definitionContext>(_ctx, getState());
    enterRule(_localctx, 336, VHDLParser::RulePhysical_type_definition);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1836);
        range_constraint();
        setState(1837);
        match(VHDLParser::UNITS);
        setState(1838);
        base_unit_declaration();
        setState(1842);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::BASIC_IDENTIFIER

               || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1839);
            secondary_unit_declaration();
            setState(1844);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(1845);
        match(VHDLParser::END);
        setState(1846);
        match(VHDLParser::UNITS);
        setState(1848);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1847);
            identifier();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Port_clauseContext
//------------------------------------------------------------------

VHDLParser::Port_clauseContext::Port_clauseContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Port_clauseContext::PORT()
{
    return getToken(VHDLParser::PORT, 0);
}

tree::TerminalNode *VHDLParser::Port_clauseContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::Port_listContext *VHDLParser::Port_clauseContext::port_list()
{
    return getRuleContext<VHDLParser::Port_listContext>(0);
}

tree::TerminalNode *VHDLParser::Port_clauseContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

tree::TerminalNode *VHDLParser::Port_clauseContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Port_clauseContext::getRuleIndex() const
{
    return VHDLParser::RulePort_clause;
}

void VHDLParser::Port_clauseContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterPort_clause(this);
}

void VHDLParser::Port_clauseContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitPort_clause(this);
}

std::any VHDLParser::Port_clauseContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitPort_clause(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Port_clauseContext *VHDLParser::port_clause()
{
    Port_clauseContext *_localctx = _tracker.createInstance<Port_clauseContext>(_ctx, getState());
    enterRule(_localctx, 338, VHDLParser::RulePort_clause);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1850);
        match(VHDLParser::PORT);
        setState(1851);
        match(VHDLParser::LPAREN);
        setState(1852);
        port_list();
        setState(1853);
        match(VHDLParser::RPAREN);
        setState(1854);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Port_listContext
//------------------------------------------------------------------

VHDLParser::Port_listContext::Port_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Interface_port_listContext *VHDLParser::Port_listContext::interface_port_list()
{
    return getRuleContext<VHDLParser::Interface_port_listContext>(0);
}

size_t VHDLParser::Port_listContext::getRuleIndex() const
{
    return VHDLParser::RulePort_list;
}

void VHDLParser::Port_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterPort_list(this);
}

void VHDLParser::Port_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitPort_list(this);
}

std::any VHDLParser::Port_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitPort_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Port_listContext *VHDLParser::port_list()
{
    Port_listContext *_localctx = _tracker.createInstance<Port_listContext>(_ctx, getState());
    enterRule(_localctx, 340, VHDLParser::RulePort_list);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1856);
        interface_port_list();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Port_map_aspectContext
//------------------------------------------------------------------

VHDLParser::Port_map_aspectContext::Port_map_aspectContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Port_map_aspectContext::PORT()
{
    return getToken(VHDLParser::PORT, 0);
}

tree::TerminalNode *VHDLParser::Port_map_aspectContext::MAP()
{
    return getToken(VHDLParser::MAP, 0);
}

tree::TerminalNode *VHDLParser::Port_map_aspectContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::Association_listContext *VHDLParser::Port_map_aspectContext::association_list()
{
    return getRuleContext<VHDLParser::Association_listContext>(0);
}

tree::TerminalNode *VHDLParser::Port_map_aspectContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

size_t VHDLParser::Port_map_aspectContext::getRuleIndex() const
{
    return VHDLParser::RulePort_map_aspect;
}

void VHDLParser::Port_map_aspectContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterPort_map_aspect(this);
}

void VHDLParser::Port_map_aspectContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitPort_map_aspect(this);
}

std::any VHDLParser::Port_map_aspectContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitPort_map_aspect(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Port_map_aspectContext *VHDLParser::port_map_aspect()
{
    Port_map_aspectContext *_localctx = _tracker.createInstance<Port_map_aspectContext>(_ctx, getState());
    enterRule(_localctx, 342, VHDLParser::RulePort_map_aspect);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1858);
        match(VHDLParser::PORT);
        setState(1859);
        match(VHDLParser::MAP);
        setState(1860);
        match(VHDLParser::LPAREN);
        setState(1861);
        association_list();
        setState(1862);
        match(VHDLParser::RPAREN);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- PrimaryContext
//------------------------------------------------------------------

VHDLParser::PrimaryContext::PrimaryContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::LiteralContext *VHDLParser::PrimaryContext::literal()
{
    return getRuleContext<VHDLParser::LiteralContext>(0);
}

VHDLParser::Qualified_expressionContext *VHDLParser::PrimaryContext::qualified_expression()
{
    return getRuleContext<VHDLParser::Qualified_expressionContext>(0);
}

tree::TerminalNode *VHDLParser::PrimaryContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::PrimaryContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

tree::TerminalNode *VHDLParser::PrimaryContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

VHDLParser::AllocatorContext *VHDLParser::PrimaryContext::allocator()
{
    return getRuleContext<VHDLParser::AllocatorContext>(0);
}

VHDLParser::AggregateContext *VHDLParser::PrimaryContext::aggregate()
{
    return getRuleContext<VHDLParser::AggregateContext>(0);
}

VHDLParser::NameContext *VHDLParser::PrimaryContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

size_t VHDLParser::PrimaryContext::getRuleIndex() const
{
    return VHDLParser::RulePrimary;
}

void VHDLParser::PrimaryContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterPrimary(this);
}

void VHDLParser::PrimaryContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitPrimary(this);
}

std::any VHDLParser::PrimaryContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitPrimary(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::PrimaryContext *VHDLParser::primary()
{
    PrimaryContext *_localctx = _tracker.createInstance<PrimaryContext>(_ctx, getState());
    enterRule(_localctx, 344, VHDLParser::RulePrimary);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1873);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(1864);
            literal();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(1865);
            qualified_expression();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(1866);
            match(VHDLParser::LPAREN);
            setState(1867);
            expression();
            setState(1868);
            match(VHDLParser::RPAREN);
            break;
        }

        case 4: {
            enterOuterAlt(_localctx, 4);
            setState(1870);
            allocator();
            break;
        }

        case 5: {
            enterOuterAlt(_localctx, 5);
            setState(1871);
            aggregate();
            break;
        }

        case 6: {
            enterOuterAlt(_localctx, 6);
            setState(1872);
            name();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Primary_unitContext
//------------------------------------------------------------------

VHDLParser::Primary_unitContext::Primary_unitContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Entity_declarationContext *VHDLParser::Primary_unitContext::entity_declaration()
{
    return getRuleContext<VHDLParser::Entity_declarationContext>(0);
}

VHDLParser::Configuration_declarationContext *VHDLParser::Primary_unitContext::configuration_declaration()
{
    return getRuleContext<VHDLParser::Configuration_declarationContext>(0);
}

VHDLParser::Package_declarationContext *VHDLParser::Primary_unitContext::package_declaration()
{
    return getRuleContext<VHDLParser::Package_declarationContext>(0);
}

size_t VHDLParser::Primary_unitContext::getRuleIndex() const
{
    return VHDLParser::RulePrimary_unit;
}

void VHDLParser::Primary_unitContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterPrimary_unit(this);
}

void VHDLParser::Primary_unitContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitPrimary_unit(this);
}

std::any VHDLParser::Primary_unitContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitPrimary_unit(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Primary_unitContext *VHDLParser::primary_unit()
{
    Primary_unitContext *_localctx = _tracker.createInstance<Primary_unitContext>(_ctx, getState());
    enterRule(_localctx, 346, VHDLParser::RulePrimary_unit);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1878);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::ENTITY: {
            enterOuterAlt(_localctx, 1);
            setState(1875);
            entity_declaration();
            break;
        }

        case VHDLParser::CONFIGURATION: {
            enterOuterAlt(_localctx, 2);
            setState(1876);
            configuration_declaration();
            break;
        }

        case VHDLParser::PACKAGE: {
            enterOuterAlt(_localctx, 3);
            setState(1877);
            package_declaration();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Procedural_declarative_itemContext
//------------------------------------------------------------------

VHDLParser::Procedural_declarative_itemContext::Procedural_declarative_itemContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Subprogram_declarationContext *VHDLParser::Procedural_declarative_itemContext::subprogram_declaration()
{
    return getRuleContext<VHDLParser::Subprogram_declarationContext>(0);
}

VHDLParser::Subprogram_bodyContext *VHDLParser::Procedural_declarative_itemContext::subprogram_body()
{
    return getRuleContext<VHDLParser::Subprogram_bodyContext>(0);
}

VHDLParser::Type_declarationContext *VHDLParser::Procedural_declarative_itemContext::type_declaration()
{
    return getRuleContext<VHDLParser::Type_declarationContext>(0);
}

VHDLParser::Subtype_declarationContext *VHDLParser::Procedural_declarative_itemContext::subtype_declaration()
{
    return getRuleContext<VHDLParser::Subtype_declarationContext>(0);
}

VHDLParser::Constant_declarationContext *VHDLParser::Procedural_declarative_itemContext::constant_declaration()
{
    return getRuleContext<VHDLParser::Constant_declarationContext>(0);
}

VHDLParser::Variable_declarationContext *VHDLParser::Procedural_declarative_itemContext::variable_declaration()
{
    return getRuleContext<VHDLParser::Variable_declarationContext>(0);
}

VHDLParser::Alias_declarationContext *VHDLParser::Procedural_declarative_itemContext::alias_declaration()
{
    return getRuleContext<VHDLParser::Alias_declarationContext>(0);
}

VHDLParser::Attribute_declarationContext *VHDLParser::Procedural_declarative_itemContext::attribute_declaration()
{
    return getRuleContext<VHDLParser::Attribute_declarationContext>(0);
}

VHDLParser::Attribute_specificationContext *VHDLParser::Procedural_declarative_itemContext::attribute_specification()
{
    return getRuleContext<VHDLParser::Attribute_specificationContext>(0);
}

VHDLParser::Use_clauseContext *VHDLParser::Procedural_declarative_itemContext::use_clause()
{
    return getRuleContext<VHDLParser::Use_clauseContext>(0);
}

VHDLParser::Group_template_declarationContext *VHDLParser::Procedural_declarative_itemContext::group_template_declaration()
{
    return getRuleContext<VHDLParser::Group_template_declarationContext>(0);
}

VHDLParser::Group_declarationContext *VHDLParser::Procedural_declarative_itemContext::group_declaration()
{
    return getRuleContext<VHDLParser::Group_declarationContext>(0);
}

size_t VHDLParser::Procedural_declarative_itemContext::getRuleIndex() const
{
    return VHDLParser::RuleProcedural_declarative_item;
}

void VHDLParser::Procedural_declarative_itemContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterProcedural_declarative_item(this);
}

void VHDLParser::Procedural_declarative_itemContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitProcedural_declarative_item(this);
}

std::any VHDLParser::Procedural_declarative_itemContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitProcedural_declarative_item(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Procedural_declarative_itemContext *VHDLParser::procedural_declarative_item()
{
    Procedural_declarative_itemContext *_localctx = _tracker.createInstance<Procedural_declarative_itemContext>(_ctx, getState());
    enterRule(_localctx, 348, VHDLParser::RuleProcedural_declarative_item);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1892);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(1880);
            subprogram_declaration();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(1881);
            subprogram_body();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(1882);
            type_declaration();
            break;
        }

        case 4: {
            enterOuterAlt(_localctx, 4);
            setState(1883);
            subtype_declaration();
            break;
        }

        case 5: {
            enterOuterAlt(_localctx, 5);
            setState(1884);
            constant_declaration();
            break;
        }

        case 6: {
            enterOuterAlt(_localctx, 6);
            setState(1885);
            variable_declaration();
            break;
        }

        case 7: {
            enterOuterAlt(_localctx, 7);
            setState(1886);
            alias_declaration();
            break;
        }

        case 8: {
            enterOuterAlt(_localctx, 8);
            setState(1887);
            attribute_declaration();
            break;
        }

        case 9: {
            enterOuterAlt(_localctx, 9);
            setState(1888);
            attribute_specification();
            break;
        }

        case 10: {
            enterOuterAlt(_localctx, 10);
            setState(1889);
            use_clause();
            break;
        }

        case 11: {
            enterOuterAlt(_localctx, 11);
            setState(1890);
            group_template_declaration();
            break;
        }

        case 12: {
            enterOuterAlt(_localctx, 12);
            setState(1891);
            group_declaration();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Procedural_declarative_partContext
//------------------------------------------------------------------

VHDLParser::Procedural_declarative_partContext::Procedural_declarative_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Procedural_declarative_itemContext *> VHDLParser::Procedural_declarative_partContext::procedural_declarative_item()
{
    return getRuleContexts<VHDLParser::Procedural_declarative_itemContext>();
}

VHDLParser::Procedural_declarative_itemContext *VHDLParser::Procedural_declarative_partContext::procedural_declarative_item(size_t i)
{
    return getRuleContext<VHDLParser::Procedural_declarative_itemContext>(i);
}

size_t VHDLParser::Procedural_declarative_partContext::getRuleIndex() const
{
    return VHDLParser::RuleProcedural_declarative_part;
}

void VHDLParser::Procedural_declarative_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterProcedural_declarative_part(this);
}

void VHDLParser::Procedural_declarative_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitProcedural_declarative_part(this);
}

std::any VHDLParser::Procedural_declarative_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitProcedural_declarative_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Procedural_declarative_partContext *VHDLParser::procedural_declarative_part()
{
    Procedural_declarative_partContext *_localctx = _tracker.createInstance<Procedural_declarative_partContext>(_ctx, getState());
    enterRule(_localctx, 350, VHDLParser::RuleProcedural_declarative_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1897);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 156768405536) != 0) || ((((_la - 68) & ~0x3fULL) == 0) && ((1ULL << (_la - 68)) & 210487083013) != 0))
        {
            setState(1894);
            procedural_declarative_item();
            setState(1899);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Procedural_statement_partContext
//------------------------------------------------------------------

VHDLParser::Procedural_statement_partContext::Procedural_statement_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Sequential_statementContext *> VHDLParser::Procedural_statement_partContext::sequential_statement()
{
    return getRuleContexts<VHDLParser::Sequential_statementContext>();
}

VHDLParser::Sequential_statementContext *VHDLParser::Procedural_statement_partContext::sequential_statement(size_t i)
{
    return getRuleContext<VHDLParser::Sequential_statementContext>(i);
}

size_t VHDLParser::Procedural_statement_partContext::getRuleIndex() const
{
    return VHDLParser::RuleProcedural_statement_part;
}

void VHDLParser::Procedural_statement_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterProcedural_statement_part(this);
}

void VHDLParser::Procedural_statement_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitProcedural_statement_part(this);
}

std::any VHDLParser::Procedural_statement_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitProcedural_statement_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Procedural_statement_partContext *VHDLParser::procedural_statement_part()
{
    Procedural_statement_partContext *_localctx = _tracker.createInstance<Procedural_statement_partContext>(_ctx, getState());
    enterRule(_localctx, 352, VHDLParser::RuleProcedural_statement_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1903);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 153263194880902144) != 0) || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 4611969143879499779) != 0))
        {
            setState(1900);
            sequential_statement();
            setState(1905);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Procedure_callContext
//------------------------------------------------------------------

VHDLParser::Procedure_callContext::Procedure_callContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Selected_nameContext *VHDLParser::Procedure_callContext::selected_name()
{
    return getRuleContext<VHDLParser::Selected_nameContext>(0);
}

tree::TerminalNode *VHDLParser::Procedure_callContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::Actual_parameter_partContext *VHDLParser::Procedure_callContext::actual_parameter_part()
{
    return getRuleContext<VHDLParser::Actual_parameter_partContext>(0);
}

tree::TerminalNode *VHDLParser::Procedure_callContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

size_t VHDLParser::Procedure_callContext::getRuleIndex() const
{
    return VHDLParser::RuleProcedure_call;
}

void VHDLParser::Procedure_callContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterProcedure_call(this);
}

void VHDLParser::Procedure_callContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitProcedure_call(this);
}

std::any VHDLParser::Procedure_callContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitProcedure_call(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Procedure_callContext *VHDLParser::procedure_call()
{
    Procedure_callContext *_localctx = _tracker.createInstance<Procedure_callContext>(_ctx, getState());
    enterRule(_localctx, 354, VHDLParser::RuleProcedure_call);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1906);
        selected_name();
        setState(1911);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::LPAREN)
        {
            setState(1907);
            match(VHDLParser::LPAREN);
            setState(1908);
            actual_parameter_part();
            setState(1909);
            match(VHDLParser::RPAREN);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Procedure_call_statementContext
//------------------------------------------------------------------

VHDLParser::Procedure_call_statementContext::Procedure_call_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Procedure_callContext *VHDLParser::Procedure_call_statementContext::procedure_call()
{
    return getRuleContext<VHDLParser::Procedure_callContext>(0);
}

tree::TerminalNode *VHDLParser::Procedure_call_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Procedure_call_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

size_t VHDLParser::Procedure_call_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleProcedure_call_statement;
}

void VHDLParser::Procedure_call_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterProcedure_call_statement(this);
}

void VHDLParser::Procedure_call_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitProcedure_call_statement(this);
}

std::any VHDLParser::Procedure_call_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitProcedure_call_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Procedure_call_statementContext *VHDLParser::procedure_call_statement()
{
    Procedure_call_statementContext *_localctx = _tracker.createInstance<Procedure_call_statementContext>(_ctx, getState());
    enterRule(_localctx, 356, VHDLParser::RuleProcedure_call_statement);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1914);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 199, _ctx))
        {
        case 1: {
            setState(1913);
            label_colon();
            break;
        }

        default:
            break;
        }
        setState(1916);
        procedure_call();
        setState(1917);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Process_declarative_itemContext
//------------------------------------------------------------------

VHDLParser::Process_declarative_itemContext::Process_declarative_itemContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Subprogram_declarationContext *VHDLParser::Process_declarative_itemContext::subprogram_declaration()
{
    return getRuleContext<VHDLParser::Subprogram_declarationContext>(0);
}

VHDLParser::Subprogram_bodyContext *VHDLParser::Process_declarative_itemContext::subprogram_body()
{
    return getRuleContext<VHDLParser::Subprogram_bodyContext>(0);
}

VHDLParser::Type_declarationContext *VHDLParser::Process_declarative_itemContext::type_declaration()
{
    return getRuleContext<VHDLParser::Type_declarationContext>(0);
}

VHDLParser::Subtype_declarationContext *VHDLParser::Process_declarative_itemContext::subtype_declaration()
{
    return getRuleContext<VHDLParser::Subtype_declarationContext>(0);
}

VHDLParser::Constant_declarationContext *VHDLParser::Process_declarative_itemContext::constant_declaration()
{
    return getRuleContext<VHDLParser::Constant_declarationContext>(0);
}

VHDLParser::Variable_declarationContext *VHDLParser::Process_declarative_itemContext::variable_declaration()
{
    return getRuleContext<VHDLParser::Variable_declarationContext>(0);
}

VHDLParser::File_declarationContext *VHDLParser::Process_declarative_itemContext::file_declaration()
{
    return getRuleContext<VHDLParser::File_declarationContext>(0);
}

VHDLParser::Alias_declarationContext *VHDLParser::Process_declarative_itemContext::alias_declaration()
{
    return getRuleContext<VHDLParser::Alias_declarationContext>(0);
}

VHDLParser::Attribute_declarationContext *VHDLParser::Process_declarative_itemContext::attribute_declaration()
{
    return getRuleContext<VHDLParser::Attribute_declarationContext>(0);
}

VHDLParser::Attribute_specificationContext *VHDLParser::Process_declarative_itemContext::attribute_specification()
{
    return getRuleContext<VHDLParser::Attribute_specificationContext>(0);
}

VHDLParser::Use_clauseContext *VHDLParser::Process_declarative_itemContext::use_clause()
{
    return getRuleContext<VHDLParser::Use_clauseContext>(0);
}

VHDLParser::Group_template_declarationContext *VHDLParser::Process_declarative_itemContext::group_template_declaration()
{
    return getRuleContext<VHDLParser::Group_template_declarationContext>(0);
}

VHDLParser::Group_declarationContext *VHDLParser::Process_declarative_itemContext::group_declaration()
{
    return getRuleContext<VHDLParser::Group_declarationContext>(0);
}

size_t VHDLParser::Process_declarative_itemContext::getRuleIndex() const
{
    return VHDLParser::RuleProcess_declarative_item;
}

void VHDLParser::Process_declarative_itemContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterProcess_declarative_item(this);
}

void VHDLParser::Process_declarative_itemContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitProcess_declarative_item(this);
}

std::any VHDLParser::Process_declarative_itemContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitProcess_declarative_item(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Process_declarative_itemContext *VHDLParser::process_declarative_item()
{
    Process_declarative_itemContext *_localctx = _tracker.createInstance<Process_declarative_itemContext>(_ctx, getState());
    enterRule(_localctx, 358, VHDLParser::RuleProcess_declarative_item);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1932);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(1919);
            subprogram_declaration();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(1920);
            subprogram_body();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(1921);
            type_declaration();
            break;
        }

        case 4: {
            enterOuterAlt(_localctx, 4);
            setState(1922);
            subtype_declaration();
            break;
        }

        case 5: {
            enterOuterAlt(_localctx, 5);
            setState(1923);
            constant_declaration();
            break;
        }

        case 6: {
            enterOuterAlt(_localctx, 6);
            setState(1924);
            variable_declaration();
            break;
        }

        case 7: {
            enterOuterAlt(_localctx, 7);
            setState(1925);
            file_declaration();
            break;
        }

        case 8: {
            enterOuterAlt(_localctx, 8);
            setState(1926);
            alias_declaration();
            break;
        }

        case 9: {
            enterOuterAlt(_localctx, 9);
            setState(1927);
            attribute_declaration();
            break;
        }

        case 10: {
            enterOuterAlt(_localctx, 10);
            setState(1928);
            attribute_specification();
            break;
        }

        case 11: {
            enterOuterAlt(_localctx, 11);
            setState(1929);
            use_clause();
            break;
        }

        case 12: {
            enterOuterAlt(_localctx, 12);
            setState(1930);
            group_template_declaration();
            break;
        }

        case 13: {
            enterOuterAlt(_localctx, 13);
            setState(1931);
            group_declaration();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Process_declarative_partContext
//------------------------------------------------------------------

VHDLParser::Process_declarative_partContext::Process_declarative_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Process_declarative_itemContext *> VHDLParser::Process_declarative_partContext::process_declarative_item()
{
    return getRuleContexts<VHDLParser::Process_declarative_itemContext>();
}

VHDLParser::Process_declarative_itemContext *VHDLParser::Process_declarative_partContext::process_declarative_item(size_t i)
{
    return getRuleContext<VHDLParser::Process_declarative_itemContext>(i);
}

size_t VHDLParser::Process_declarative_partContext::getRuleIndex() const
{
    return VHDLParser::RuleProcess_declarative_part;
}

void VHDLParser::Process_declarative_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterProcess_declarative_part(this);
}

void VHDLParser::Process_declarative_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitProcess_declarative_part(this);
}

std::any VHDLParser::Process_declarative_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitProcess_declarative_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Process_declarative_partContext *VHDLParser::process_declarative_part()
{
    Process_declarative_partContext *_localctx = _tracker.createInstance<Process_declarative_partContext>(_ctx, getState());
    enterRule(_localctx, 360, VHDLParser::RuleProcess_declarative_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1937);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 157305276448) != 0) || ((((_la - 68) & ~0x3fULL) == 0) && ((1ULL << (_la - 68)) & 210487083013) != 0))
        {
            setState(1934);
            process_declarative_item();
            setState(1939);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Process_statementContext
//------------------------------------------------------------------

VHDLParser::Process_statementContext::Process_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::Process_statementContext::PROCESS()
{
    return getTokens(VHDLParser::PROCESS);
}

tree::TerminalNode *VHDLParser::Process_statementContext::PROCESS(size_t i)
{
    return getToken(VHDLParser::PROCESS, i);
}

VHDLParser::Process_declarative_partContext *VHDLParser::Process_statementContext::process_declarative_part()
{
    return getRuleContext<VHDLParser::Process_declarative_partContext>(0);
}

tree::TerminalNode *VHDLParser::Process_statementContext::BEGIN()
{
    return getToken(VHDLParser::BEGIN, 0);
}

VHDLParser::Process_statement_partContext *VHDLParser::Process_statementContext::process_statement_part()
{
    return getRuleContext<VHDLParser::Process_statement_partContext>(0);
}

tree::TerminalNode *VHDLParser::Process_statementContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::Process_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Process_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

std::vector<tree::TerminalNode *> VHDLParser::Process_statementContext::POSTPONED()
{
    return getTokens(VHDLParser::POSTPONED);
}

tree::TerminalNode *VHDLParser::Process_statementContext::POSTPONED(size_t i)
{
    return getToken(VHDLParser::POSTPONED, i);
}

tree::TerminalNode *VHDLParser::Process_statementContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::Sensitivity_listContext *VHDLParser::Process_statementContext::sensitivity_list()
{
    return getRuleContext<VHDLParser::Sensitivity_listContext>(0);
}

tree::TerminalNode *VHDLParser::Process_statementContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

tree::TerminalNode *VHDLParser::Process_statementContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::IdentifierContext *VHDLParser::Process_statementContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

size_t VHDLParser::Process_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleProcess_statement;
}

void VHDLParser::Process_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterProcess_statement(this);
}

void VHDLParser::Process_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitProcess_statement(this);
}

std::any VHDLParser::Process_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitProcess_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Process_statementContext *VHDLParser::process_statement()
{
    Process_statementContext *_localctx = _tracker.createInstance<Process_statementContext>(_ctx, getState());
    enterRule(_localctx, 362, VHDLParser::RuleProcess_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1941);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1940);
            label_colon();
        }
        setState(1944);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::POSTPONED)
        {
            setState(1943);
            match(VHDLParser::POSTPONED);
        }
        setState(1946);
        match(VHDLParser::PROCESS);
        setState(1951);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::LPAREN)
        {
            setState(1947);
            match(VHDLParser::LPAREN);
            setState(1948);
            sensitivity_list();
            setState(1949);
            match(VHDLParser::RPAREN);
        }
        setState(1954);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::IS)
        {
            setState(1953);
            match(VHDLParser::IS);
        }
        setState(1956);
        process_declarative_part();
        setState(1957);
        match(VHDLParser::BEGIN);
        setState(1958);
        process_statement_part();
        setState(1959);
        match(VHDLParser::END);
        setState(1961);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::POSTPONED)
        {
            setState(1960);
            match(VHDLParser::POSTPONED);
        }
        setState(1963);
        match(VHDLParser::PROCESS);
        setState(1965);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(1964);
            identifier();
        }
        setState(1967);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Process_statement_partContext
//------------------------------------------------------------------

VHDLParser::Process_statement_partContext::Process_statement_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Sequential_statementContext *> VHDLParser::Process_statement_partContext::sequential_statement()
{
    return getRuleContexts<VHDLParser::Sequential_statementContext>();
}

VHDLParser::Sequential_statementContext *VHDLParser::Process_statement_partContext::sequential_statement(size_t i)
{
    return getRuleContext<VHDLParser::Sequential_statementContext>(i);
}

size_t VHDLParser::Process_statement_partContext::getRuleIndex() const
{
    return VHDLParser::RuleProcess_statement_part;
}

void VHDLParser::Process_statement_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterProcess_statement_part(this);
}

void VHDLParser::Process_statement_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitProcess_statement_part(this);
}

std::any VHDLParser::Process_statement_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitProcess_statement_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Process_statement_partContext *VHDLParser::process_statement_part()
{
    Process_statement_partContext *_localctx = _tracker.createInstance<Process_statement_partContext>(_ctx, getState());
    enterRule(_localctx, 364, VHDLParser::RuleProcess_statement_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1972);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 153263194880902144) != 0) || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 4611969143879499779) != 0))
        {
            setState(1969);
            sequential_statement();
            setState(1974);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Qualified_expressionContext
//------------------------------------------------------------------

VHDLParser::Qualified_expressionContext::Qualified_expressionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Subtype_indicationContext *VHDLParser::Qualified_expressionContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

tree::TerminalNode *VHDLParser::Qualified_expressionContext::APOSTROPHE()
{
    return getToken(VHDLParser::APOSTROPHE, 0);
}

VHDLParser::AggregateContext *VHDLParser::Qualified_expressionContext::aggregate()
{
    return getRuleContext<VHDLParser::AggregateContext>(0);
}

tree::TerminalNode *VHDLParser::Qualified_expressionContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Qualified_expressionContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

tree::TerminalNode *VHDLParser::Qualified_expressionContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

size_t VHDLParser::Qualified_expressionContext::getRuleIndex() const
{
    return VHDLParser::RuleQualified_expression;
}

void VHDLParser::Qualified_expressionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterQualified_expression(this);
}

void VHDLParser::Qualified_expressionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitQualified_expression(this);
}

std::any VHDLParser::Qualified_expressionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitQualified_expression(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Qualified_expressionContext *VHDLParser::qualified_expression()
{
    Qualified_expressionContext *_localctx = _tracker.createInstance<Qualified_expressionContext>(_ctx, getState());
    enterRule(_localctx, 366, VHDLParser::RuleQualified_expression);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(1975);
        subtype_indication();
        setState(1976);
        match(VHDLParser::APOSTROPHE);
        setState(1982);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 209, _ctx))
        {
        case 1: {
            setState(1977);
            aggregate();
            break;
        }

        case 2: {
            setState(1978);
            match(VHDLParser::LPAREN);
            setState(1979);
            expression();
            setState(1980);
            match(VHDLParser::RPAREN);
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Quantity_declarationContext
//------------------------------------------------------------------

VHDLParser::Quantity_declarationContext::Quantity_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Free_quantity_declarationContext *VHDLParser::Quantity_declarationContext::free_quantity_declaration()
{
    return getRuleContext<VHDLParser::Free_quantity_declarationContext>(0);
}

VHDLParser::Branch_quantity_declarationContext *VHDLParser::Quantity_declarationContext::branch_quantity_declaration()
{
    return getRuleContext<VHDLParser::Branch_quantity_declarationContext>(0);
}

VHDLParser::Source_quantity_declarationContext *VHDLParser::Quantity_declarationContext::source_quantity_declaration()
{
    return getRuleContext<VHDLParser::Source_quantity_declarationContext>(0);
}

size_t VHDLParser::Quantity_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleQuantity_declaration;
}

void VHDLParser::Quantity_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterQuantity_declaration(this);
}

void VHDLParser::Quantity_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitQuantity_declaration(this);
}

std::any VHDLParser::Quantity_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitQuantity_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Quantity_declarationContext *VHDLParser::quantity_declaration()
{
    Quantity_declarationContext *_localctx = _tracker.createInstance<Quantity_declarationContext>(_ctx, getState());
    enterRule(_localctx, 368, VHDLParser::RuleQuantity_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1987);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 210, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(1984);
            free_quantity_declaration();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(1985);
            branch_quantity_declaration();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(1986);
            source_quantity_declaration();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Quantity_listContext
//------------------------------------------------------------------

VHDLParser::Quantity_listContext::Quantity_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::NameContext *> VHDLParser::Quantity_listContext::name()
{
    return getRuleContexts<VHDLParser::NameContext>();
}

VHDLParser::NameContext *VHDLParser::Quantity_listContext::name(size_t i)
{
    return getRuleContext<VHDLParser::NameContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Quantity_listContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Quantity_listContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

tree::TerminalNode *VHDLParser::Quantity_listContext::OTHERS()
{
    return getToken(VHDLParser::OTHERS, 0);
}

tree::TerminalNode *VHDLParser::Quantity_listContext::ALL()
{
    return getToken(VHDLParser::ALL, 0);
}

size_t VHDLParser::Quantity_listContext::getRuleIndex() const
{
    return VHDLParser::RuleQuantity_list;
}

void VHDLParser::Quantity_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterQuantity_list(this);
}

void VHDLParser::Quantity_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitQuantity_list(this);
}

std::any VHDLParser::Quantity_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitQuantity_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Quantity_listContext *VHDLParser::quantity_list()
{
    Quantity_listContext *_localctx = _tracker.createInstance<Quantity_listContext>(_ctx, getState());
    enterRule(_localctx, 370, VHDLParser::RuleQuantity_list);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(1999);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER:
        case VHDLParser::STRING_LITERAL: {
            enterOuterAlt(_localctx, 1);
            setState(1989);
            name();
            setState(1994);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == VHDLParser::COMMA)
            {
                setState(1990);
                match(VHDLParser::COMMA);
                setState(1991);
                name();
                setState(1996);
                _errHandler->sync(this);
                _la = _input->LA(1);
            }
            break;
        }

        case VHDLParser::OTHERS: {
            enterOuterAlt(_localctx, 2);
            setState(1997);
            match(VHDLParser::OTHERS);
            break;
        }

        case VHDLParser::ALL: {
            enterOuterAlt(_localctx, 3);
            setState(1998);
            match(VHDLParser::ALL);
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Quantity_specificationContext
//------------------------------------------------------------------

VHDLParser::Quantity_specificationContext::Quantity_specificationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Quantity_listContext *VHDLParser::Quantity_specificationContext::quantity_list()
{
    return getRuleContext<VHDLParser::Quantity_listContext>(0);
}

tree::TerminalNode *VHDLParser::Quantity_specificationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::NameContext *VHDLParser::Quantity_specificationContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

size_t VHDLParser::Quantity_specificationContext::getRuleIndex() const
{
    return VHDLParser::RuleQuantity_specification;
}

void VHDLParser::Quantity_specificationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterQuantity_specification(this);
}

void VHDLParser::Quantity_specificationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitQuantity_specification(this);
}

std::any VHDLParser::Quantity_specificationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitQuantity_specification(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Quantity_specificationContext *VHDLParser::quantity_specification()
{
    Quantity_specificationContext *_localctx = _tracker.createInstance<Quantity_specificationContext>(_ctx, getState());
    enterRule(_localctx, 372, VHDLParser::RuleQuantity_specification);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2001);
        quantity_list();
        setState(2002);
        match(VHDLParser::COLON);
        setState(2003);
        name();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Range_declContext
//------------------------------------------------------------------

VHDLParser::Range_declContext::Range_declContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Explicit_rangeContext *VHDLParser::Range_declContext::explicit_range()
{
    return getRuleContext<VHDLParser::Explicit_rangeContext>(0);
}

VHDLParser::NameContext *VHDLParser::Range_declContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

size_t VHDLParser::Range_declContext::getRuleIndex() const
{
    return VHDLParser::RuleRange_decl;
}

void VHDLParser::Range_declContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterRange_decl(this);
}

void VHDLParser::Range_declContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitRange_decl(this);
}

std::any VHDLParser::Range_declContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitRange_decl(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Range_declContext *VHDLParser::range_decl()
{
    Range_declContext *_localctx = _tracker.createInstance<Range_declContext>(_ctx, getState());
    enterRule(_localctx, 374, VHDLParser::RuleRange_decl);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(2007);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 213, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(2005);
            explicit_range();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(2006);
            name();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Explicit_rangeContext
//------------------------------------------------------------------

VHDLParser::Explicit_rangeContext::Explicit_rangeContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Simple_expressionContext *> VHDLParser::Explicit_rangeContext::simple_expression()
{
    return getRuleContexts<VHDLParser::Simple_expressionContext>();
}

VHDLParser::Simple_expressionContext *VHDLParser::Explicit_rangeContext::simple_expression(size_t i)
{
    return getRuleContext<VHDLParser::Simple_expressionContext>(i);
}

VHDLParser::DirectionContext *VHDLParser::Explicit_rangeContext::direction()
{
    return getRuleContext<VHDLParser::DirectionContext>(0);
}

size_t VHDLParser::Explicit_rangeContext::getRuleIndex() const
{
    return VHDLParser::RuleExplicit_range;
}

void VHDLParser::Explicit_rangeContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterExplicit_range(this);
}

void VHDLParser::Explicit_rangeContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitExplicit_range(this);
}

std::any VHDLParser::Explicit_rangeContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitExplicit_range(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Explicit_rangeContext *VHDLParser::explicit_range()
{
    Explicit_rangeContext *_localctx = _tracker.createInstance<Explicit_rangeContext>(_ctx, getState());
    enterRule(_localctx, 376, VHDLParser::RuleExplicit_range);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2009);
        simple_expression();
        setState(2013);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 214, _ctx))
        {
        case 1: {
            setState(2010);
            direction();
            setState(2011);
            simple_expression();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Range_constraintContext
//------------------------------------------------------------------

VHDLParser::Range_constraintContext::Range_constraintContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Range_constraintContext::RANGE()
{
    return getToken(VHDLParser::RANGE, 0);
}

VHDLParser::Range_declContext *VHDLParser::Range_constraintContext::range_decl()
{
    return getRuleContext<VHDLParser::Range_declContext>(0);
}

size_t VHDLParser::Range_constraintContext::getRuleIndex() const
{
    return VHDLParser::RuleRange_constraint;
}

void VHDLParser::Range_constraintContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterRange_constraint(this);
}

void VHDLParser::Range_constraintContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitRange_constraint(this);
}

std::any VHDLParser::Range_constraintContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitRange_constraint(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Range_constraintContext *VHDLParser::range_constraint()
{
    Range_constraintContext *_localctx = _tracker.createInstance<Range_constraintContext>(_ctx, getState());
    enterRule(_localctx, 378, VHDLParser::RuleRange_constraint);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2015);
        match(VHDLParser::RANGE);
        setState(2016);
        range_decl();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Record_nature_definitionContext
//------------------------------------------------------------------

VHDLParser::Record_nature_definitionContext::Record_nature_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::Record_nature_definitionContext::RECORD()
{
    return getTokens(VHDLParser::RECORD);
}

tree::TerminalNode *VHDLParser::Record_nature_definitionContext::RECORD(size_t i)
{
    return getToken(VHDLParser::RECORD, i);
}

tree::TerminalNode *VHDLParser::Record_nature_definitionContext::END()
{
    return getToken(VHDLParser::END, 0);
}

std::vector<VHDLParser::Nature_element_declarationContext *> VHDLParser::Record_nature_definitionContext::nature_element_declaration()
{
    return getRuleContexts<VHDLParser::Nature_element_declarationContext>();
}

VHDLParser::Nature_element_declarationContext *VHDLParser::Record_nature_definitionContext::nature_element_declaration(size_t i)
{
    return getRuleContext<VHDLParser::Nature_element_declarationContext>(i);
}

VHDLParser::IdentifierContext *VHDLParser::Record_nature_definitionContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

size_t VHDLParser::Record_nature_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleRecord_nature_definition;
}

void VHDLParser::Record_nature_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterRecord_nature_definition(this);
}

void VHDLParser::Record_nature_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitRecord_nature_definition(this);
}

std::any VHDLParser::Record_nature_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitRecord_nature_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Record_nature_definitionContext *VHDLParser::record_nature_definition()
{
    Record_nature_definitionContext *_localctx = _tracker.createInstance<Record_nature_definitionContext>(_ctx, getState());
    enterRule(_localctx, 380, VHDLParser::RuleRecord_nature_definition);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2018);
        match(VHDLParser::RECORD);
        setState(2020);
        _errHandler->sync(this);
        _la = _input->LA(1);
        do
        {
            setState(2019);
            nature_element_declaration();
            setState(2022);
            _errHandler->sync(this);
            _la = _input->LA(1);
        } while (_la == VHDLParser::BASIC_IDENTIFIER

                 || _la == VHDLParser::EXTENDED_IDENTIFIER);
        setState(2024);
        match(VHDLParser::END);
        setState(2025);
        match(VHDLParser::RECORD);
        setState(2027);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(2026);
            identifier();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Record_type_definitionContext
//------------------------------------------------------------------

VHDLParser::Record_type_definitionContext::Record_type_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::Record_type_definitionContext::RECORD()
{
    return getTokens(VHDLParser::RECORD);
}

tree::TerminalNode *VHDLParser::Record_type_definitionContext::RECORD(size_t i)
{
    return getToken(VHDLParser::RECORD, i);
}

tree::TerminalNode *VHDLParser::Record_type_definitionContext::END()
{
    return getToken(VHDLParser::END, 0);
}

std::vector<VHDLParser::Element_declarationContext *> VHDLParser::Record_type_definitionContext::element_declaration()
{
    return getRuleContexts<VHDLParser::Element_declarationContext>();
}

VHDLParser::Element_declarationContext *VHDLParser::Record_type_definitionContext::element_declaration(size_t i)
{
    return getRuleContext<VHDLParser::Element_declarationContext>(i);
}

VHDLParser::IdentifierContext *VHDLParser::Record_type_definitionContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

size_t VHDLParser::Record_type_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleRecord_type_definition;
}

void VHDLParser::Record_type_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterRecord_type_definition(this);
}

void VHDLParser::Record_type_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitRecord_type_definition(this);
}

std::any VHDLParser::Record_type_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitRecord_type_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Record_type_definitionContext *VHDLParser::record_type_definition()
{
    Record_type_definitionContext *_localctx = _tracker.createInstance<Record_type_definitionContext>(_ctx, getState());
    enterRule(_localctx, 382, VHDLParser::RuleRecord_type_definition);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2029);
        match(VHDLParser::RECORD);
        setState(2031);
        _errHandler->sync(this);
        _la = _input->LA(1);
        do
        {
            setState(2030);
            element_declaration();
            setState(2033);
            _errHandler->sync(this);
            _la = _input->LA(1);
        } while (_la == VHDLParser::BASIC_IDENTIFIER

                 || _la == VHDLParser::EXTENDED_IDENTIFIER);
        setState(2035);
        match(VHDLParser::END);
        setState(2036);
        match(VHDLParser::RECORD);
        setState(2038);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(2037);
            identifier();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- RelationContext
//------------------------------------------------------------------

VHDLParser::RelationContext::RelationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Shift_expressionContext *> VHDLParser::RelationContext::shift_expression()
{
    return getRuleContexts<VHDLParser::Shift_expressionContext>();
}

VHDLParser::Shift_expressionContext *VHDLParser::RelationContext::shift_expression(size_t i)
{
    return getRuleContext<VHDLParser::Shift_expressionContext>(i);
}

VHDLParser::Relational_operatorContext *VHDLParser::RelationContext::relational_operator()
{
    return getRuleContext<VHDLParser::Relational_operatorContext>(0);
}

size_t VHDLParser::RelationContext::getRuleIndex() const
{
    return VHDLParser::RuleRelation;
}

void VHDLParser::RelationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterRelation(this);
}

void VHDLParser::RelationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitRelation(this);
}

std::any VHDLParser::RelationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitRelation(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::RelationContext *VHDLParser::relation()
{
    RelationContext *_localctx = _tracker.createInstance<RelationContext>(_ctx, getState());
    enterRule(_localctx, 384, VHDLParser::RuleRelation);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2040);
        shift_expression();
        setState(2044);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx))
        {
        case 1: {
            setState(2041);
            relational_operator();
            setState(2042);
            shift_expression();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Relational_operatorContext
//------------------------------------------------------------------

VHDLParser::Relational_operatorContext::Relational_operatorContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Relational_operatorContext::EQ()
{
    return getToken(VHDLParser::EQ, 0);
}

tree::TerminalNode *VHDLParser::Relational_operatorContext::NEQ()
{
    return getToken(VHDLParser::NEQ, 0);
}

tree::TerminalNode *VHDLParser::Relational_operatorContext::LOWERTHAN()
{
    return getToken(VHDLParser::LOWERTHAN, 0);
}

tree::TerminalNode *VHDLParser::Relational_operatorContext::LE()
{
    return getToken(VHDLParser::LE, 0);
}

tree::TerminalNode *VHDLParser::Relational_operatorContext::GREATERTHAN()
{
    return getToken(VHDLParser::GREATERTHAN, 0);
}

tree::TerminalNode *VHDLParser::Relational_operatorContext::GE()
{
    return getToken(VHDLParser::GE, 0);
}

size_t VHDLParser::Relational_operatorContext::getRuleIndex() const
{
    return VHDLParser::RuleRelational_operator;
}

void VHDLParser::Relational_operatorContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterRelational_operator(this);
}

void VHDLParser::Relational_operatorContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitRelational_operator(this);
}

std::any VHDLParser::Relational_operatorContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitRelational_operator(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Relational_operatorContext *VHDLParser::relational_operator()
{
    Relational_operatorContext *_localctx = _tracker.createInstance<Relational_operatorContext>(_ctx, getState());
    enterRule(_localctx, 386, VHDLParser::RuleRelational_operator);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2046);
        _la = _input->LA(1);
        if (!(((((_la - 131) & ~0x3fULL) == 0) && ((1ULL << (_la - 131)) & 3670027) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Report_statementContext
//------------------------------------------------------------------

VHDLParser::Report_statementContext::Report_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Report_statementContext::REPORT()
{
    return getToken(VHDLParser::REPORT, 0);
}

std::vector<VHDLParser::ExpressionContext *> VHDLParser::Report_statementContext::expression()
{
    return getRuleContexts<VHDLParser::ExpressionContext>();
}

VHDLParser::ExpressionContext *VHDLParser::Report_statementContext::expression(size_t i)
{
    return getRuleContext<VHDLParser::ExpressionContext>(i);
}

tree::TerminalNode *VHDLParser::Report_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Report_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

tree::TerminalNode *VHDLParser::Report_statementContext::SEVERITY()
{
    return getToken(VHDLParser::SEVERITY, 0);
}

size_t VHDLParser::Report_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleReport_statement;
}

void VHDLParser::Report_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterReport_statement(this);
}

void VHDLParser::Report_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitReport_statement(this);
}

std::any VHDLParser::Report_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitReport_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Report_statementContext *VHDLParser::report_statement()
{
    Report_statementContext *_localctx = _tracker.createInstance<Report_statementContext>(_ctx, getState());
    enterRule(_localctx, 388, VHDLParser::RuleReport_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2049);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(2048);
            label_colon();
        }
        setState(2051);
        match(VHDLParser::REPORT);
        setState(2052);
        expression();
        setState(2055);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::SEVERITY)
        {
            setState(2053);
            match(VHDLParser::SEVERITY);
            setState(2054);
            expression();
        }
        setState(2057);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Return_statementContext
//------------------------------------------------------------------

VHDLParser::Return_statementContext::Return_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Return_statementContext::RETURN()
{
    return getToken(VHDLParser::RETURN, 0);
}

tree::TerminalNode *VHDLParser::Return_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Return_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

VHDLParser::ExpressionContext *VHDLParser::Return_statementContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::Return_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleReturn_statement;
}

void VHDLParser::Return_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterReturn_statement(this);
}

void VHDLParser::Return_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitReturn_statement(this);
}

std::any VHDLParser::Return_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitReturn_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Return_statementContext *VHDLParser::return_statement()
{
    Return_statementContext *_localctx = _tracker.createInstance<Return_statementContext>(_ctx, getState());
    enterRule(_localctx, 390, VHDLParser::RuleReturn_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2060);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(2059);
            label_colon();
        }
        setState(2062);
        match(VHDLParser::RETURN);
        setState(2064);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 220676381741154306) != 0) || ((((_la - 112) & ~0x3fULL) == 0) && ((1ULL << (_la - 112)) & 70575439528163) != 0))
        {
            setState(2063);
            expression();
        }
        setState(2066);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Scalar_nature_definitionContext
//------------------------------------------------------------------

VHDLParser::Scalar_nature_definitionContext::Scalar_nature_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::NameContext *> VHDLParser::Scalar_nature_definitionContext::name()
{
    return getRuleContexts<VHDLParser::NameContext>();
}

VHDLParser::NameContext *VHDLParser::Scalar_nature_definitionContext::name(size_t i)
{
    return getRuleContext<VHDLParser::NameContext>(i);
}

tree::TerminalNode *VHDLParser::Scalar_nature_definitionContext::ACROSS()
{
    return getToken(VHDLParser::ACROSS, 0);
}

tree::TerminalNode *VHDLParser::Scalar_nature_definitionContext::THROUGH()
{
    return getToken(VHDLParser::THROUGH, 0);
}

tree::TerminalNode *VHDLParser::Scalar_nature_definitionContext::REFERENCE()
{
    return getToken(VHDLParser::REFERENCE, 0);
}

size_t VHDLParser::Scalar_nature_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleScalar_nature_definition;
}

void VHDLParser::Scalar_nature_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterScalar_nature_definition(this);
}

void VHDLParser::Scalar_nature_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitScalar_nature_definition(this);
}

std::any VHDLParser::Scalar_nature_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitScalar_nature_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Scalar_nature_definitionContext *VHDLParser::scalar_nature_definition()
{
    Scalar_nature_definitionContext *_localctx = _tracker.createInstance<Scalar_nature_definitionContext>(_ctx, getState());
    enterRule(_localctx, 392, VHDLParser::RuleScalar_nature_definition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2068);
        name();
        setState(2069);
        match(VHDLParser::ACROSS);
        setState(2070);
        name();
        setState(2071);
        match(VHDLParser::THROUGH);
        setState(2072);
        name();
        setState(2073);
        match(VHDLParser::REFERENCE);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Scalar_type_definitionContext
//------------------------------------------------------------------

VHDLParser::Scalar_type_definitionContext::Scalar_type_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Physical_type_definitionContext *VHDLParser::Scalar_type_definitionContext::physical_type_definition()
{
    return getRuleContext<VHDLParser::Physical_type_definitionContext>(0);
}

VHDLParser::Enumeration_type_definitionContext *VHDLParser::Scalar_type_definitionContext::enumeration_type_definition()
{
    return getRuleContext<VHDLParser::Enumeration_type_definitionContext>(0);
}

VHDLParser::Range_constraintContext *VHDLParser::Scalar_type_definitionContext::range_constraint()
{
    return getRuleContext<VHDLParser::Range_constraintContext>(0);
}

size_t VHDLParser::Scalar_type_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleScalar_type_definition;
}

void VHDLParser::Scalar_type_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterScalar_type_definition(this);
}

void VHDLParser::Scalar_type_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitScalar_type_definition(this);
}

std::any VHDLParser::Scalar_type_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitScalar_type_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Scalar_type_definitionContext *VHDLParser::scalar_type_definition()
{
    Scalar_type_definitionContext *_localctx = _tracker.createInstance<Scalar_type_definitionContext>(_ctx, getState());
    enterRule(_localctx, 394, VHDLParser::RuleScalar_type_definition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(2078);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 224, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(2075);
            physical_type_definition();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(2076);
            enumeration_type_definition();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(2077);
            range_constraint();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Secondary_unitContext
//------------------------------------------------------------------

VHDLParser::Secondary_unitContext::Secondary_unitContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Architecture_bodyContext *VHDLParser::Secondary_unitContext::architecture_body()
{
    return getRuleContext<VHDLParser::Architecture_bodyContext>(0);
}

VHDLParser::Package_bodyContext *VHDLParser::Secondary_unitContext::package_body()
{
    return getRuleContext<VHDLParser::Package_bodyContext>(0);
}

size_t VHDLParser::Secondary_unitContext::getRuleIndex() const
{
    return VHDLParser::RuleSecondary_unit;
}

void VHDLParser::Secondary_unitContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSecondary_unit(this);
}

void VHDLParser::Secondary_unitContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSecondary_unit(this);
}

std::any VHDLParser::Secondary_unitContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSecondary_unit(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Secondary_unitContext *VHDLParser::secondary_unit()
{
    Secondary_unitContext *_localctx = _tracker.createInstance<Secondary_unitContext>(_ctx, getState());
    enterRule(_localctx, 396, VHDLParser::RuleSecondary_unit);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(2082);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::ARCHITECTURE: {
            enterOuterAlt(_localctx, 1);
            setState(2080);
            architecture_body();
            break;
        }

        case VHDLParser::PACKAGE: {
            enterOuterAlt(_localctx, 2);
            setState(2081);
            package_body();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Secondary_unit_declarationContext
//------------------------------------------------------------------

VHDLParser::Secondary_unit_declarationContext::Secondary_unit_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::IdentifierContext *VHDLParser::Secondary_unit_declarationContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Secondary_unit_declarationContext::EQ()
{
    return getToken(VHDLParser::EQ, 0);
}

VHDLParser::Physical_literalContext *VHDLParser::Secondary_unit_declarationContext::physical_literal()
{
    return getRuleContext<VHDLParser::Physical_literalContext>(0);
}

tree::TerminalNode *VHDLParser::Secondary_unit_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Secondary_unit_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleSecondary_unit_declaration;
}

void VHDLParser::Secondary_unit_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSecondary_unit_declaration(this);
}

void VHDLParser::Secondary_unit_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSecondary_unit_declaration(this);
}

std::any VHDLParser::Secondary_unit_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSecondary_unit_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Secondary_unit_declarationContext *VHDLParser::secondary_unit_declaration()
{
    Secondary_unit_declarationContext *_localctx = _tracker.createInstance<Secondary_unit_declarationContext>(_ctx, getState());
    enterRule(_localctx, 398, VHDLParser::RuleSecondary_unit_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2084);
        identifier();
        setState(2085);
        match(VHDLParser::EQ);
        setState(2086);
        physical_literal();
        setState(2087);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Selected_signal_assignmentContext
//------------------------------------------------------------------

VHDLParser::Selected_signal_assignmentContext::Selected_signal_assignmentContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Selected_signal_assignmentContext::WITH()
{
    return getToken(VHDLParser::WITH, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Selected_signal_assignmentContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

tree::TerminalNode *VHDLParser::Selected_signal_assignmentContext::SELECT()
{
    return getToken(VHDLParser::SELECT, 0);
}

VHDLParser::TargetContext *VHDLParser::Selected_signal_assignmentContext::target()
{
    return getRuleContext<VHDLParser::TargetContext>(0);
}

tree::TerminalNode *VHDLParser::Selected_signal_assignmentContext::LE()
{
    return getToken(VHDLParser::LE, 0);
}

VHDLParser::OptsContext *VHDLParser::Selected_signal_assignmentContext::opts()
{
    return getRuleContext<VHDLParser::OptsContext>(0);
}

VHDLParser::Selected_waveformsContext *VHDLParser::Selected_signal_assignmentContext::selected_waveforms()
{
    return getRuleContext<VHDLParser::Selected_waveformsContext>(0);
}

tree::TerminalNode *VHDLParser::Selected_signal_assignmentContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Selected_signal_assignmentContext::getRuleIndex() const
{
    return VHDLParser::RuleSelected_signal_assignment;
}

void VHDLParser::Selected_signal_assignmentContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSelected_signal_assignment(this);
}

void VHDLParser::Selected_signal_assignmentContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSelected_signal_assignment(this);
}

std::any VHDLParser::Selected_signal_assignmentContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSelected_signal_assignment(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Selected_signal_assignmentContext *VHDLParser::selected_signal_assignment()
{
    Selected_signal_assignmentContext *_localctx = _tracker.createInstance<Selected_signal_assignmentContext>(_ctx, getState());
    enterRule(_localctx, 400, VHDLParser::RuleSelected_signal_assignment);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2089);
        match(VHDLParser::WITH);
        setState(2090);
        expression();
        setState(2091);
        match(VHDLParser::SELECT);
        setState(2092);
        target();
        setState(2093);
        match(VHDLParser::LE);
        setState(2094);
        opts();
        setState(2095);
        selected_waveforms();
        setState(2096);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Selected_waveformsContext
//------------------------------------------------------------------

VHDLParser::Selected_waveformsContext::Selected_waveformsContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::WaveformContext *> VHDLParser::Selected_waveformsContext::waveform()
{
    return getRuleContexts<VHDLParser::WaveformContext>();
}

VHDLParser::WaveformContext *VHDLParser::Selected_waveformsContext::waveform(size_t i)
{
    return getRuleContext<VHDLParser::WaveformContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Selected_waveformsContext::WHEN()
{
    return getTokens(VHDLParser::WHEN);
}

tree::TerminalNode *VHDLParser::Selected_waveformsContext::WHEN(size_t i)
{
    return getToken(VHDLParser::WHEN, i);
}

std::vector<VHDLParser::ChoicesContext *> VHDLParser::Selected_waveformsContext::choices()
{
    return getRuleContexts<VHDLParser::ChoicesContext>();
}

VHDLParser::ChoicesContext *VHDLParser::Selected_waveformsContext::choices(size_t i)
{
    return getRuleContext<VHDLParser::ChoicesContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Selected_waveformsContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Selected_waveformsContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

size_t VHDLParser::Selected_waveformsContext::getRuleIndex() const
{
    return VHDLParser::RuleSelected_waveforms;
}

void VHDLParser::Selected_waveformsContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSelected_waveforms(this);
}

void VHDLParser::Selected_waveformsContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSelected_waveforms(this);
}

std::any VHDLParser::Selected_waveformsContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSelected_waveforms(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Selected_waveformsContext *VHDLParser::selected_waveforms()
{
    Selected_waveformsContext *_localctx = _tracker.createInstance<Selected_waveformsContext>(_ctx, getState());
    enterRule(_localctx, 402, VHDLParser::RuleSelected_waveforms);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2098);
        waveform();
        setState(2099);
        match(VHDLParser::WHEN);
        setState(2100);
        choices();
        setState(2108);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::COMMA)
        {
            setState(2101);
            match(VHDLParser::COMMA);
            setState(2102);
            waveform();
            setState(2103);
            match(VHDLParser::WHEN);
            setState(2104);
            choices();
            setState(2110);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Sensitivity_clauseContext
//------------------------------------------------------------------

VHDLParser::Sensitivity_clauseContext::Sensitivity_clauseContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Sensitivity_clauseContext::ON()
{
    return getToken(VHDLParser::ON, 0);
}

VHDLParser::Sensitivity_listContext *VHDLParser::Sensitivity_clauseContext::sensitivity_list()
{
    return getRuleContext<VHDLParser::Sensitivity_listContext>(0);
}

size_t VHDLParser::Sensitivity_clauseContext::getRuleIndex() const
{
    return VHDLParser::RuleSensitivity_clause;
}

void VHDLParser::Sensitivity_clauseContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSensitivity_clause(this);
}

void VHDLParser::Sensitivity_clauseContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSensitivity_clause(this);
}

std::any VHDLParser::Sensitivity_clauseContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSensitivity_clause(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Sensitivity_clauseContext *VHDLParser::sensitivity_clause()
{
    Sensitivity_clauseContext *_localctx = _tracker.createInstance<Sensitivity_clauseContext>(_ctx, getState());
    enterRule(_localctx, 404, VHDLParser::RuleSensitivity_clause);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2111);
        match(VHDLParser::ON);
        setState(2112);
        sensitivity_list();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Sensitivity_listContext
//------------------------------------------------------------------

VHDLParser::Sensitivity_listContext::Sensitivity_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::NameContext *> VHDLParser::Sensitivity_listContext::name()
{
    return getRuleContexts<VHDLParser::NameContext>();
}

VHDLParser::NameContext *VHDLParser::Sensitivity_listContext::name(size_t i)
{
    return getRuleContext<VHDLParser::NameContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Sensitivity_listContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Sensitivity_listContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

size_t VHDLParser::Sensitivity_listContext::getRuleIndex() const
{
    return VHDLParser::RuleSensitivity_list;
}

void VHDLParser::Sensitivity_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSensitivity_list(this);
}

void VHDLParser::Sensitivity_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSensitivity_list(this);
}

std::any VHDLParser::Sensitivity_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSensitivity_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Sensitivity_listContext *VHDLParser::sensitivity_list()
{
    Sensitivity_listContext *_localctx = _tracker.createInstance<Sensitivity_listContext>(_ctx, getState());
    enterRule(_localctx, 406, VHDLParser::RuleSensitivity_list);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2114);
        name();
        setState(2119);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::COMMA)
        {
            setState(2115);
            match(VHDLParser::COMMA);
            setState(2116);
            name();
            setState(2121);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Sequence_of_statementsContext
//------------------------------------------------------------------

VHDLParser::Sequence_of_statementsContext::Sequence_of_statementsContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Sequential_statementContext *> VHDLParser::Sequence_of_statementsContext::sequential_statement()
{
    return getRuleContexts<VHDLParser::Sequential_statementContext>();
}

VHDLParser::Sequential_statementContext *VHDLParser::Sequence_of_statementsContext::sequential_statement(size_t i)
{
    return getRuleContext<VHDLParser::Sequential_statementContext>(i);
}

size_t VHDLParser::Sequence_of_statementsContext::getRuleIndex() const
{
    return VHDLParser::RuleSequence_of_statements;
}

void VHDLParser::Sequence_of_statementsContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSequence_of_statements(this);
}

void VHDLParser::Sequence_of_statementsContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSequence_of_statements(this);
}

std::any VHDLParser::Sequence_of_statementsContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSequence_of_statements(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Sequence_of_statementsContext *VHDLParser::sequence_of_statements()
{
    Sequence_of_statementsContext *_localctx = _tracker.createInstance<Sequence_of_statementsContext>(_ctx, getState());
    enterRule(_localctx, 408, VHDLParser::RuleSequence_of_statements);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2125);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 153263194880902144) != 0) || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 4611969143879499779) != 0))
        {
            setState(2122);
            sequential_statement();
            setState(2127);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Sequential_statementContext
//------------------------------------------------------------------

VHDLParser::Sequential_statementContext::Sequential_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Wait_statementContext *VHDLParser::Sequential_statementContext::wait_statement()
{
    return getRuleContext<VHDLParser::Wait_statementContext>(0);
}

VHDLParser::Assertion_statementContext *VHDLParser::Sequential_statementContext::assertion_statement()
{
    return getRuleContext<VHDLParser::Assertion_statementContext>(0);
}

VHDLParser::Report_statementContext *VHDLParser::Sequential_statementContext::report_statement()
{
    return getRuleContext<VHDLParser::Report_statementContext>(0);
}

VHDLParser::Signal_assignment_statementContext *VHDLParser::Sequential_statementContext::signal_assignment_statement()
{
    return getRuleContext<VHDLParser::Signal_assignment_statementContext>(0);
}

VHDLParser::Variable_assignment_statementContext *VHDLParser::Sequential_statementContext::variable_assignment_statement()
{
    return getRuleContext<VHDLParser::Variable_assignment_statementContext>(0);
}

VHDLParser::If_statementContext *VHDLParser::Sequential_statementContext::if_statement()
{
    return getRuleContext<VHDLParser::If_statementContext>(0);
}

VHDLParser::Case_statementContext *VHDLParser::Sequential_statementContext::case_statement()
{
    return getRuleContext<VHDLParser::Case_statementContext>(0);
}

VHDLParser::Loop_statementContext *VHDLParser::Sequential_statementContext::loop_statement()
{
    return getRuleContext<VHDLParser::Loop_statementContext>(0);
}

VHDLParser::Next_statementContext *VHDLParser::Sequential_statementContext::next_statement()
{
    return getRuleContext<VHDLParser::Next_statementContext>(0);
}

VHDLParser::Exit_statementContext *VHDLParser::Sequential_statementContext::exit_statement()
{
    return getRuleContext<VHDLParser::Exit_statementContext>(0);
}

VHDLParser::Return_statementContext *VHDLParser::Sequential_statementContext::return_statement()
{
    return getRuleContext<VHDLParser::Return_statementContext>(0);
}

tree::TerminalNode *VHDLParser::Sequential_statementContext::NULL_()
{
    return getToken(VHDLParser::NULL_, 0);
}

tree::TerminalNode *VHDLParser::Sequential_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Sequential_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

VHDLParser::Break_statementContext *VHDLParser::Sequential_statementContext::break_statement()
{
    return getRuleContext<VHDLParser::Break_statementContext>(0);
}

VHDLParser::Procedure_call_statementContext *VHDLParser::Sequential_statementContext::procedure_call_statement()
{
    return getRuleContext<VHDLParser::Procedure_call_statementContext>(0);
}

size_t VHDLParser::Sequential_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleSequential_statement;
}

void VHDLParser::Sequential_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSequential_statement(this);
}

void VHDLParser::Sequential_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSequential_statement(this);
}

std::any VHDLParser::Sequential_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSequential_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Sequential_statementContext *VHDLParser::sequential_statement()
{
    Sequential_statementContext *_localctx = _tracker.createInstance<Sequential_statementContext>(_ctx, getState());
    enterRule(_localctx, 410, VHDLParser::RuleSequential_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(2146);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(2128);
            wait_statement();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(2129);
            assertion_statement();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(2130);
            report_statement();
            break;
        }

        case 4: {
            enterOuterAlt(_localctx, 4);
            setState(2131);
            signal_assignment_statement();
            break;
        }

        case 5: {
            enterOuterAlt(_localctx, 5);
            setState(2132);
            variable_assignment_statement();
            break;
        }

        case 6: {
            enterOuterAlt(_localctx, 6);
            setState(2133);
            if_statement();
            break;
        }

        case 7: {
            enterOuterAlt(_localctx, 7);
            setState(2134);
            case_statement();
            break;
        }

        case 8: {
            enterOuterAlt(_localctx, 8);
            setState(2135);
            loop_statement();
            break;
        }

        case 9: {
            enterOuterAlt(_localctx, 9);
            setState(2136);
            next_statement();
            break;
        }

        case 10: {
            enterOuterAlt(_localctx, 10);
            setState(2137);
            exit_statement();
            break;
        }

        case 11: {
            enterOuterAlt(_localctx, 11);
            setState(2138);
            return_statement();
            break;
        }

        case 12: {
            enterOuterAlt(_localctx, 12);
            setState(2140);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == VHDLParser::BASIC_IDENTIFIER

                || _la == VHDLParser::EXTENDED_IDENTIFIER)
            {
                setState(2139);
                label_colon();
            }
            setState(2142);
            match(VHDLParser::NULL_);
            setState(2143);
            match(VHDLParser::SEMI);
            break;
        }

        case 13: {
            enterOuterAlt(_localctx, 13);
            setState(2144);
            break_statement();
            break;
        }

        case 14: {
            enterOuterAlt(_localctx, 14);
            setState(2145);
            procedure_call_statement();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Shift_expressionContext
//------------------------------------------------------------------

VHDLParser::Shift_expressionContext::Shift_expressionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Simple_expressionContext *> VHDLParser::Shift_expressionContext::simple_expression()
{
    return getRuleContexts<VHDLParser::Simple_expressionContext>();
}

VHDLParser::Simple_expressionContext *VHDLParser::Shift_expressionContext::simple_expression(size_t i)
{
    return getRuleContext<VHDLParser::Simple_expressionContext>(i);
}

VHDLParser::Shift_operatorContext *VHDLParser::Shift_expressionContext::shift_operator()
{
    return getRuleContext<VHDLParser::Shift_operatorContext>(0);
}

size_t VHDLParser::Shift_expressionContext::getRuleIndex() const
{
    return VHDLParser::RuleShift_expression;
}

void VHDLParser::Shift_expressionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterShift_expression(this);
}

void VHDLParser::Shift_expressionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitShift_expression(this);
}

std::any VHDLParser::Shift_expressionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitShift_expression(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Shift_expressionContext *VHDLParser::shift_expression()
{
    Shift_expressionContext *_localctx = _tracker.createInstance<Shift_expressionContext>(_ctx, getState());
    enterRule(_localctx, 412, VHDLParser::RuleShift_expression);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2148);
        simple_expression();
        setState(2152);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx))
        {
        case 1: {
            setState(2149);
            shift_operator();
            setState(2150);
            simple_expression();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Shift_operatorContext
//------------------------------------------------------------------

VHDLParser::Shift_operatorContext::Shift_operatorContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Shift_operatorContext::SLL()
{
    return getToken(VHDLParser::SLL, 0);
}

tree::TerminalNode *VHDLParser::Shift_operatorContext::SRL()
{
    return getToken(VHDLParser::SRL, 0);
}

tree::TerminalNode *VHDLParser::Shift_operatorContext::SLA()
{
    return getToken(VHDLParser::SLA, 0);
}

tree::TerminalNode *VHDLParser::Shift_operatorContext::SRA()
{
    return getToken(VHDLParser::SRA, 0);
}

tree::TerminalNode *VHDLParser::Shift_operatorContext::ROL()
{
    return getToken(VHDLParser::ROL, 0);
}

tree::TerminalNode *VHDLParser::Shift_operatorContext::ROR()
{
    return getToken(VHDLParser::ROR, 0);
}

size_t VHDLParser::Shift_operatorContext::getRuleIndex() const
{
    return VHDLParser::RuleShift_operator;
}

void VHDLParser::Shift_operatorContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterShift_operator(this);
}

void VHDLParser::Shift_operatorContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitShift_operator(this);
}

std::any VHDLParser::Shift_operatorContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitShift_operator(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Shift_operatorContext *VHDLParser::shift_operator()
{
    Shift_operatorContext *_localctx = _tracker.createInstance<Shift_operatorContext>(_ctx, getState());
    enterRule(_localctx, 414, VHDLParser::RuleShift_operator);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2154);
        _la = _input->LA(1);
        if (!(((((_la - 81) & ~0x3fULL) == 0) && ((1ULL << (_la - 81)) & 1731) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Signal_assignment_statementContext
//------------------------------------------------------------------

VHDLParser::Signal_assignment_statementContext::Signal_assignment_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::TargetContext *VHDLParser::Signal_assignment_statementContext::target()
{
    return getRuleContext<VHDLParser::TargetContext>(0);
}

tree::TerminalNode *VHDLParser::Signal_assignment_statementContext::LE()
{
    return getToken(VHDLParser::LE, 0);
}

VHDLParser::WaveformContext *VHDLParser::Signal_assignment_statementContext::waveform()
{
    return getRuleContext<VHDLParser::WaveformContext>(0);
}

tree::TerminalNode *VHDLParser::Signal_assignment_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Signal_assignment_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

VHDLParser::Delay_mechanismContext *VHDLParser::Signal_assignment_statementContext::delay_mechanism()
{
    return getRuleContext<VHDLParser::Delay_mechanismContext>(0);
}

size_t VHDLParser::Signal_assignment_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleSignal_assignment_statement;
}

void VHDLParser::Signal_assignment_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSignal_assignment_statement(this);
}

void VHDLParser::Signal_assignment_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSignal_assignment_statement(this);
}

std::any VHDLParser::Signal_assignment_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSignal_assignment_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Signal_assignment_statementContext *VHDLParser::signal_assignment_statement()
{
    Signal_assignment_statementContext *_localctx = _tracker.createInstance<Signal_assignment_statementContext>(_ctx, getState());
    enterRule(_localctx, 416, VHDLParser::RuleSignal_assignment_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2157);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx))
        {
        case 1: {
            setState(2156);
            label_colon();
            break;
        }

        default:
            break;
        }
        setState(2159);
        target();
        setState(2160);
        match(VHDLParser::LE);
        setState(2162);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 39) & ~0x3fULL) == 0) && ((1ULL << (_la - 39)) & 1152921538966585345) != 0))
        {
            setState(2161);
            delay_mechanism();
        }
        setState(2164);
        waveform();
        setState(2165);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Signal_declarationContext
//------------------------------------------------------------------

VHDLParser::Signal_declarationContext::Signal_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Signal_declarationContext::SIGNAL()
{
    return getToken(VHDLParser::SIGNAL, 0);
}

VHDLParser::Identifier_listContext *VHDLParser::Signal_declarationContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Signal_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Signal_declarationContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

tree::TerminalNode *VHDLParser::Signal_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Signal_kindContext *VHDLParser::Signal_declarationContext::signal_kind()
{
    return getRuleContext<VHDLParser::Signal_kindContext>(0);
}

tree::TerminalNode *VHDLParser::Signal_declarationContext::VARASGN()
{
    return getToken(VHDLParser::VARASGN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Signal_declarationContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::Signal_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleSignal_declaration;
}

void VHDLParser::Signal_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSignal_declaration(this);
}

void VHDLParser::Signal_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSignal_declaration(this);
}

std::any VHDLParser::Signal_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSignal_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Signal_declarationContext *VHDLParser::signal_declaration()
{
    Signal_declarationContext *_localctx = _tracker.createInstance<Signal_declarationContext>(_ctx, getState());
    enterRule(_localctx, 418, VHDLParser::RuleSignal_declaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2167);
        match(VHDLParser::SIGNAL);
        setState(2168);
        identifier_list();
        setState(2169);
        match(VHDLParser::COLON);
        setState(2170);
        subtype_indication();
        setState(2172);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BUS

            || _la == VHDLParser::REGISTER)
        {
            setState(2171);
            signal_kind();
        }
        setState(2176);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::VARASGN)
        {
            setState(2174);
            match(VHDLParser::VARASGN);
            setState(2175);
            expression();
        }
        setState(2178);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Signal_kindContext
//------------------------------------------------------------------

VHDLParser::Signal_kindContext::Signal_kindContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Signal_kindContext::REGISTER()
{
    return getToken(VHDLParser::REGISTER, 0);
}

tree::TerminalNode *VHDLParser::Signal_kindContext::BUS()
{
    return getToken(VHDLParser::BUS, 0);
}

size_t VHDLParser::Signal_kindContext::getRuleIndex() const
{
    return VHDLParser::RuleSignal_kind;
}

void VHDLParser::Signal_kindContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSignal_kind(this);
}

void VHDLParser::Signal_kindContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSignal_kind(this);
}

std::any VHDLParser::Signal_kindContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSignal_kind(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Signal_kindContext *VHDLParser::signal_kind()
{
    Signal_kindContext *_localctx = _tracker.createInstance<Signal_kindContext>(_ctx, getState());
    enterRule(_localctx, 420, VHDLParser::RuleSignal_kind);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2180);
        _la = _input->LA(1);
        if (!(_la == VHDLParser::BUS

              || _la == VHDLParser::REGISTER))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Signal_listContext
//------------------------------------------------------------------

VHDLParser::Signal_listContext::Signal_listContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::NameContext *> VHDLParser::Signal_listContext::name()
{
    return getRuleContexts<VHDLParser::NameContext>();
}

VHDLParser::NameContext *VHDLParser::Signal_listContext::name(size_t i)
{
    return getRuleContext<VHDLParser::NameContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Signal_listContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Signal_listContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

tree::TerminalNode *VHDLParser::Signal_listContext::OTHERS()
{
    return getToken(VHDLParser::OTHERS, 0);
}

tree::TerminalNode *VHDLParser::Signal_listContext::ALL()
{
    return getToken(VHDLParser::ALL, 0);
}

size_t VHDLParser::Signal_listContext::getRuleIndex() const
{
    return VHDLParser::RuleSignal_list;
}

void VHDLParser::Signal_listContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSignal_list(this);
}

void VHDLParser::Signal_listContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSignal_list(this);
}

std::any VHDLParser::Signal_listContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSignal_list(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Signal_listContext *VHDLParser::signal_list()
{
    Signal_listContext *_localctx = _tracker.createInstance<Signal_listContext>(_ctx, getState());
    enterRule(_localctx, 422, VHDLParser::RuleSignal_list);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(2192);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER:
        case VHDLParser::STRING_LITERAL: {
            enterOuterAlt(_localctx, 1);
            setState(2182);
            name();
            setState(2187);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == VHDLParser::COMMA)
            {
                setState(2183);
                match(VHDLParser::COMMA);
                setState(2184);
                name();
                setState(2189);
                _errHandler->sync(this);
                _la = _input->LA(1);
            }
            break;
        }

        case VHDLParser::OTHERS: {
            enterOuterAlt(_localctx, 2);
            setState(2190);
            match(VHDLParser::OTHERS);
            break;
        }

        case VHDLParser::ALL: {
            enterOuterAlt(_localctx, 3);
            setState(2191);
            match(VHDLParser::ALL);
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SignatureContext
//------------------------------------------------------------------

VHDLParser::SignatureContext::SignatureContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::SignatureContext::LBRACKET()
{
    return getToken(VHDLParser::LBRACKET, 0);
}

tree::TerminalNode *VHDLParser::SignatureContext::RBRACKET()
{
    return getToken(VHDLParser::RBRACKET, 0);
}

std::vector<VHDLParser::NameContext *> VHDLParser::SignatureContext::name()
{
    return getRuleContexts<VHDLParser::NameContext>();
}

VHDLParser::NameContext *VHDLParser::SignatureContext::name(size_t i)
{
    return getRuleContext<VHDLParser::NameContext>(i);
}

tree::TerminalNode *VHDLParser::SignatureContext::RETURN()
{
    return getToken(VHDLParser::RETURN, 0);
}

std::vector<tree::TerminalNode *> VHDLParser::SignatureContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::SignatureContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

size_t VHDLParser::SignatureContext::getRuleIndex() const
{
    return VHDLParser::RuleSignature;
}

void VHDLParser::SignatureContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSignature(this);
}

void VHDLParser::SignatureContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSignature(this);
}

std::any VHDLParser::SignatureContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSignature(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::SignatureContext *VHDLParser::signature()
{
    SignatureContext *_localctx = _tracker.createInstance<SignatureContext>(_ctx, getState());
    enterRule(_localctx, 424, VHDLParser::RuleSignature);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2194);
        match(VHDLParser::LBRACKET);
        setState(2203);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 118) & ~0x3fULL) == 0) && ((1ULL << (_la - 118)) & 515) != 0))
        {
            setState(2195);
            name();
            setState(2200);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == VHDLParser::COMMA)
            {
                setState(2196);
                match(VHDLParser::COMMA);
                setState(2197);
                name();
                setState(2202);
                _errHandler->sync(this);
                _la = _input->LA(1);
            }
        }
        setState(2207);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::RETURN)
        {
            setState(2205);
            match(VHDLParser::RETURN);
            setState(2206);
            name();
        }
        setState(2209);
        match(VHDLParser::RBRACKET);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Simple_expressionContext
//------------------------------------------------------------------

VHDLParser::Simple_expressionContext::Simple_expressionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::TermContext *> VHDLParser::Simple_expressionContext::term()
{
    return getRuleContexts<VHDLParser::TermContext>();
}

VHDLParser::TermContext *VHDLParser::Simple_expressionContext::term(size_t i)
{
    return getRuleContext<VHDLParser::TermContext>(i);
}

std::vector<VHDLParser::Adding_operatorContext *> VHDLParser::Simple_expressionContext::adding_operator()
{
    return getRuleContexts<VHDLParser::Adding_operatorContext>();
}

VHDLParser::Adding_operatorContext *VHDLParser::Simple_expressionContext::adding_operator(size_t i)
{
    return getRuleContext<VHDLParser::Adding_operatorContext>(i);
}

tree::TerminalNode *VHDLParser::Simple_expressionContext::PLUS()
{
    return getToken(VHDLParser::PLUS, 0);
}

tree::TerminalNode *VHDLParser::Simple_expressionContext::MINUS()
{
    return getToken(VHDLParser::MINUS, 0);
}

size_t VHDLParser::Simple_expressionContext::getRuleIndex() const
{
    return VHDLParser::RuleSimple_expression;
}

void VHDLParser::Simple_expressionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSimple_expression(this);
}

void VHDLParser::Simple_expressionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSimple_expression(this);
}

std::any VHDLParser::Simple_expressionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSimple_expression(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Simple_expressionContext *VHDLParser::simple_expression()
{
    Simple_expressionContext *_localctx = _tracker.createInstance<Simple_expressionContext>(_ctx, getState());
    enterRule(_localctx, 426, VHDLParser::RuleSimple_expression);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(2212);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::PLUS

            || _la == VHDLParser::MINUS)
        {
            setState(2211);
            _la = _input->LA(1);
            if (!(_la == VHDLParser::PLUS

                  || _la == VHDLParser::MINUS))
            {
                _errHandler->recoverInline(this);
            }
            else
            {
                _errHandler->reportMatch(this);
                consume();
            }
        }
        setState(2214);
        term();
        setState(2220);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(2215);
                adding_operator();
                setState(2216);
                term();
            }
            setState(2222);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Simple_simultaneous_statementContext
//------------------------------------------------------------------

VHDLParser::Simple_simultaneous_statementContext::Simple_simultaneous_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Simple_expressionContext *> VHDLParser::Simple_simultaneous_statementContext::simple_expression()
{
    return getRuleContexts<VHDLParser::Simple_expressionContext>();
}

VHDLParser::Simple_expressionContext *VHDLParser::Simple_simultaneous_statementContext::simple_expression(size_t i)
{
    return getRuleContext<VHDLParser::Simple_expressionContext>(i);
}

tree::TerminalNode *VHDLParser::Simple_simultaneous_statementContext::ASSIGN()
{
    return getToken(VHDLParser::ASSIGN, 0);
}

tree::TerminalNode *VHDLParser::Simple_simultaneous_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Simple_simultaneous_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

VHDLParser::Tolerance_aspectContext *VHDLParser::Simple_simultaneous_statementContext::tolerance_aspect()
{
    return getRuleContext<VHDLParser::Tolerance_aspectContext>(0);
}

size_t VHDLParser::Simple_simultaneous_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleSimple_simultaneous_statement;
}

void VHDLParser::Simple_simultaneous_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSimple_simultaneous_statement(this);
}

void VHDLParser::Simple_simultaneous_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSimple_simultaneous_statement(this);
}

std::any VHDLParser::Simple_simultaneous_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSimple_simultaneous_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Simple_simultaneous_statementContext *VHDLParser::simple_simultaneous_statement()
{
    Simple_simultaneous_statementContext *_localctx = _tracker.createInstance<Simple_simultaneous_statementContext>(_ctx, getState());
    enterRule(_localctx, 428, VHDLParser::RuleSimple_simultaneous_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2224);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx))
        {
        case 1: {
            setState(2223);
            label_colon();
            break;
        }

        default:
            break;
        }
        setState(2226);
        simple_expression();
        setState(2227);
        match(VHDLParser::ASSIGN);
        setState(2228);
        simple_expression();
        setState(2230);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::TOLERANCE)
        {
            setState(2229);
            tolerance_aspect();
        }
        setState(2232);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Simultaneous_alternativeContext
//------------------------------------------------------------------

VHDLParser::Simultaneous_alternativeContext::Simultaneous_alternativeContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Simultaneous_alternativeContext::WHEN()
{
    return getToken(VHDLParser::WHEN, 0);
}

VHDLParser::ChoicesContext *VHDLParser::Simultaneous_alternativeContext::choices()
{
    return getRuleContext<VHDLParser::ChoicesContext>(0);
}

tree::TerminalNode *VHDLParser::Simultaneous_alternativeContext::ARROW()
{
    return getToken(VHDLParser::ARROW, 0);
}

VHDLParser::Simultaneous_statement_partContext *VHDLParser::Simultaneous_alternativeContext::simultaneous_statement_part()
{
    return getRuleContext<VHDLParser::Simultaneous_statement_partContext>(0);
}

size_t VHDLParser::Simultaneous_alternativeContext::getRuleIndex() const
{
    return VHDLParser::RuleSimultaneous_alternative;
}

void VHDLParser::Simultaneous_alternativeContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSimultaneous_alternative(this);
}

void VHDLParser::Simultaneous_alternativeContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSimultaneous_alternative(this);
}

std::any VHDLParser::Simultaneous_alternativeContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSimultaneous_alternative(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Simultaneous_alternativeContext *VHDLParser::simultaneous_alternative()
{
    Simultaneous_alternativeContext *_localctx = _tracker.createInstance<Simultaneous_alternativeContext>(_ctx, getState());
    enterRule(_localctx, 430, VHDLParser::RuleSimultaneous_alternative);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2234);
        match(VHDLParser::WHEN);
        setState(2235);
        choices();
        setState(2236);
        match(VHDLParser::ARROW);
        setState(2237);
        simultaneous_statement_part();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Simultaneous_case_statementContext
//------------------------------------------------------------------

VHDLParser::Simultaneous_case_statementContext::Simultaneous_case_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::Simultaneous_case_statementContext::CASE()
{
    return getTokens(VHDLParser::CASE);
}

tree::TerminalNode *VHDLParser::Simultaneous_case_statementContext::CASE(size_t i)
{
    return getToken(VHDLParser::CASE, i);
}

VHDLParser::ExpressionContext *VHDLParser::Simultaneous_case_statementContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

tree::TerminalNode *VHDLParser::Simultaneous_case_statementContext::USE()
{
    return getToken(VHDLParser::USE, 0);
}

tree::TerminalNode *VHDLParser::Simultaneous_case_statementContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::Simultaneous_case_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Simultaneous_case_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

std::vector<VHDLParser::Simultaneous_alternativeContext *> VHDLParser::Simultaneous_case_statementContext::simultaneous_alternative()
{
    return getRuleContexts<VHDLParser::Simultaneous_alternativeContext>();
}

VHDLParser::Simultaneous_alternativeContext *VHDLParser::Simultaneous_case_statementContext::simultaneous_alternative(size_t i)
{
    return getRuleContext<VHDLParser::Simultaneous_alternativeContext>(i);
}

VHDLParser::IdentifierContext *VHDLParser::Simultaneous_case_statementContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

size_t VHDLParser::Simultaneous_case_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleSimultaneous_case_statement;
}

void VHDLParser::Simultaneous_case_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSimultaneous_case_statement(this);
}

void VHDLParser::Simultaneous_case_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSimultaneous_case_statement(this);
}

std::any VHDLParser::Simultaneous_case_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSimultaneous_case_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Simultaneous_case_statementContext *VHDLParser::simultaneous_case_statement()
{
    Simultaneous_case_statementContext *_localctx = _tracker.createInstance<Simultaneous_case_statementContext>(_ctx, getState());
    enterRule(_localctx, 432, VHDLParser::RuleSimultaneous_case_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2240);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(2239);
            label_colon();
        }
        setState(2242);
        match(VHDLParser::CASE);
        setState(2243);
        expression();
        setState(2244);
        match(VHDLParser::USE);
        setState(2246);
        _errHandler->sync(this);
        _la = _input->LA(1);
        do
        {
            setState(2245);
            simultaneous_alternative();
            setState(2248);
            _errHandler->sync(this);
            _la = _input->LA(1);
        } while (_la == VHDLParser::WHEN);
        setState(2250);
        match(VHDLParser::END);
        setState(2251);
        match(VHDLParser::CASE);
        setState(2253);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(2252);
            identifier();
        }
        setState(2255);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Simultaneous_if_statementContext
//------------------------------------------------------------------

VHDLParser::Simultaneous_if_statementContext::Simultaneous_if_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Simultaneous_if_statementContext::IF()
{
    return getToken(VHDLParser::IF, 0);
}

std::vector<VHDLParser::ConditionContext *> VHDLParser::Simultaneous_if_statementContext::condition()
{
    return getRuleContexts<VHDLParser::ConditionContext>();
}

VHDLParser::ConditionContext *VHDLParser::Simultaneous_if_statementContext::condition(size_t i)
{
    return getRuleContext<VHDLParser::ConditionContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::Simultaneous_if_statementContext::USE()
{
    return getTokens(VHDLParser::USE);
}

tree::TerminalNode *VHDLParser::Simultaneous_if_statementContext::USE(size_t i)
{
    return getToken(VHDLParser::USE, i);
}

std::vector<VHDLParser::Simultaneous_statement_partContext *> VHDLParser::Simultaneous_if_statementContext::simultaneous_statement_part()
{
    return getRuleContexts<VHDLParser::Simultaneous_statement_partContext>();
}

VHDLParser::Simultaneous_statement_partContext *VHDLParser::Simultaneous_if_statementContext::simultaneous_statement_part(size_t i)
{
    return getRuleContext<VHDLParser::Simultaneous_statement_partContext>(i);
}

tree::TerminalNode *VHDLParser::Simultaneous_if_statementContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::Simultaneous_if_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Simultaneous_if_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

std::vector<tree::TerminalNode *> VHDLParser::Simultaneous_if_statementContext::ELSIF()
{
    return getTokens(VHDLParser::ELSIF);
}

tree::TerminalNode *VHDLParser::Simultaneous_if_statementContext::ELSIF(size_t i)
{
    return getToken(VHDLParser::ELSIF, i);
}

tree::TerminalNode *VHDLParser::Simultaneous_if_statementContext::ELSE()
{
    return getToken(VHDLParser::ELSE, 0);
}

VHDLParser::IdentifierContext *VHDLParser::Simultaneous_if_statementContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

size_t VHDLParser::Simultaneous_if_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleSimultaneous_if_statement;
}

void VHDLParser::Simultaneous_if_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSimultaneous_if_statement(this);
}

void VHDLParser::Simultaneous_if_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSimultaneous_if_statement(this);
}

std::any VHDLParser::Simultaneous_if_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSimultaneous_if_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Simultaneous_if_statementContext *VHDLParser::simultaneous_if_statement()
{
    Simultaneous_if_statementContext *_localctx = _tracker.createInstance<Simultaneous_if_statementContext>(_ctx, getState());
    enterRule(_localctx, 434, VHDLParser::RuleSimultaneous_if_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2258);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(2257);
            label_colon();
        }
        setState(2260);
        match(VHDLParser::IF);
        setState(2261);
        condition();
        setState(2262);
        match(VHDLParser::USE);
        setState(2263);
        simultaneous_statement_part();
        setState(2271);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::ELSIF)
        {
            setState(2264);
            match(VHDLParser::ELSIF);
            setState(2265);
            condition();
            setState(2266);
            match(VHDLParser::USE);
            setState(2267);
            simultaneous_statement_part();
            setState(2273);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(2276);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::ELSE)
        {
            setState(2274);
            match(VHDLParser::ELSE);
            setState(2275);
            simultaneous_statement_part();
        }
        setState(2278);
        match(VHDLParser::END);
        setState(2279);
        match(VHDLParser::USE);
        setState(2281);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(2280);
            identifier();
        }
        setState(2283);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Simultaneous_procedural_statementContext
//------------------------------------------------------------------

VHDLParser::Simultaneous_procedural_statementContext::Simultaneous_procedural_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<tree::TerminalNode *> VHDLParser::Simultaneous_procedural_statementContext::PROCEDURAL()
{
    return getTokens(VHDLParser::PROCEDURAL);
}

tree::TerminalNode *VHDLParser::Simultaneous_procedural_statementContext::PROCEDURAL(size_t i)
{
    return getToken(VHDLParser::PROCEDURAL, i);
}

VHDLParser::Procedural_declarative_partContext *VHDLParser::Simultaneous_procedural_statementContext::procedural_declarative_part()
{
    return getRuleContext<VHDLParser::Procedural_declarative_partContext>(0);
}

tree::TerminalNode *VHDLParser::Simultaneous_procedural_statementContext::BEGIN()
{
    return getToken(VHDLParser::BEGIN, 0);
}

VHDLParser::Procedural_statement_partContext *VHDLParser::Simultaneous_procedural_statementContext::procedural_statement_part()
{
    return getRuleContext<VHDLParser::Procedural_statement_partContext>(0);
}

tree::TerminalNode *VHDLParser::Simultaneous_procedural_statementContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::Simultaneous_procedural_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Simultaneous_procedural_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

tree::TerminalNode *VHDLParser::Simultaneous_procedural_statementContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::IdentifierContext *VHDLParser::Simultaneous_procedural_statementContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

size_t VHDLParser::Simultaneous_procedural_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleSimultaneous_procedural_statement;
}

void VHDLParser::Simultaneous_procedural_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSimultaneous_procedural_statement(this);
}

void VHDLParser::Simultaneous_procedural_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSimultaneous_procedural_statement(this);
}

std::any VHDLParser::Simultaneous_procedural_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSimultaneous_procedural_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Simultaneous_procedural_statementContext *VHDLParser::simultaneous_procedural_statement()
{
    Simultaneous_procedural_statementContext *_localctx = _tracker.createInstance<Simultaneous_procedural_statementContext>(_ctx, getState());
    enterRule(_localctx, 436, VHDLParser::RuleSimultaneous_procedural_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2286);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(2285);
            label_colon();
        }
        setState(2288);
        match(VHDLParser::PROCEDURAL);
        setState(2290);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::IS)
        {
            setState(2289);
            match(VHDLParser::IS);
        }
        setState(2292);
        procedural_declarative_part();
        setState(2293);
        match(VHDLParser::BEGIN);
        setState(2294);
        procedural_statement_part();
        setState(2295);
        match(VHDLParser::END);
        setState(2296);
        match(VHDLParser::PROCEDURAL);
        setState(2298);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(2297);
            identifier();
        }
        setState(2300);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Simultaneous_statementContext
//------------------------------------------------------------------

VHDLParser::Simultaneous_statementContext::Simultaneous_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Simple_simultaneous_statementContext *VHDLParser::Simultaneous_statementContext::simple_simultaneous_statement()
{
    return getRuleContext<VHDLParser::Simple_simultaneous_statementContext>(0);
}

VHDLParser::Simultaneous_if_statementContext *VHDLParser::Simultaneous_statementContext::simultaneous_if_statement()
{
    return getRuleContext<VHDLParser::Simultaneous_if_statementContext>(0);
}

VHDLParser::Simultaneous_case_statementContext *VHDLParser::Simultaneous_statementContext::simultaneous_case_statement()
{
    return getRuleContext<VHDLParser::Simultaneous_case_statementContext>(0);
}

VHDLParser::Simultaneous_procedural_statementContext *VHDLParser::Simultaneous_statementContext::simultaneous_procedural_statement()
{
    return getRuleContext<VHDLParser::Simultaneous_procedural_statementContext>(0);
}

tree::TerminalNode *VHDLParser::Simultaneous_statementContext::NULL_()
{
    return getToken(VHDLParser::NULL_, 0);
}

tree::TerminalNode *VHDLParser::Simultaneous_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Simultaneous_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

size_t VHDLParser::Simultaneous_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleSimultaneous_statement;
}

void VHDLParser::Simultaneous_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSimultaneous_statement(this);
}

void VHDLParser::Simultaneous_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSimultaneous_statement(this);
}

std::any VHDLParser::Simultaneous_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSimultaneous_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Simultaneous_statementContext *VHDLParser::simultaneous_statement()
{
    Simultaneous_statementContext *_localctx = _tracker.createInstance<Simultaneous_statementContext>(_ctx, getState());
    enterRule(_localctx, 438, VHDLParser::RuleSimultaneous_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(2311);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 256, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(2302);
            simple_simultaneous_statement();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(2303);
            simultaneous_if_statement();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(2304);
            simultaneous_case_statement();
            break;
        }

        case 4: {
            enterOuterAlt(_localctx, 4);
            setState(2305);
            simultaneous_procedural_statement();
            break;
        }

        case 5: {
            enterOuterAlt(_localctx, 5);
            setState(2307);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == VHDLParser::BASIC_IDENTIFIER

                || _la == VHDLParser::EXTENDED_IDENTIFIER)
            {
                setState(2306);
                label_colon();
            }
            setState(2309);
            match(VHDLParser::NULL_);
            setState(2310);
            match(VHDLParser::SEMI);
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Simultaneous_statement_partContext
//------------------------------------------------------------------

VHDLParser::Simultaneous_statement_partContext::Simultaneous_statement_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Simultaneous_statementContext *> VHDLParser::Simultaneous_statement_partContext::simultaneous_statement()
{
    return getRuleContexts<VHDLParser::Simultaneous_statementContext>();
}

VHDLParser::Simultaneous_statementContext *VHDLParser::Simultaneous_statement_partContext::simultaneous_statement(size_t i)
{
    return getRuleContext<VHDLParser::Simultaneous_statementContext>(i);
}

size_t VHDLParser::Simultaneous_statement_partContext::getRuleIndex() const
{
    return VHDLParser::RuleSimultaneous_statement_part;
}

void VHDLParser::Simultaneous_statement_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSimultaneous_statement_part(this);
}

void VHDLParser::Simultaneous_statement_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSimultaneous_statement_part(this);
}

std::any VHDLParser::Simultaneous_statement_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSimultaneous_statement_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Simultaneous_statement_partContext *VHDLParser::simultaneous_statement_part()
{
    Simultaneous_statement_partContext *_localctx = _tracker.createInstance<Simultaneous_statement_partContext>(_ctx, getState());
    enterRule(_localctx, 440, VHDLParser::RuleSimultaneous_statement_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2316);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 220676450460893186) != 0) || ((((_la - 69) & ~0x3fULL) == 0) && ((1ULL << (_la - 69)) & 434342277343608833) != 0) ||
               ((((_la - 141) & ~0x3fULL) == 0) && ((1ULL << (_la - 141)) & 131457) != 0))
        {
            setState(2313);
            simultaneous_statement();
            setState(2318);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Source_aspectContext
//------------------------------------------------------------------

VHDLParser::Source_aspectContext::Source_aspectContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Source_aspectContext::SPECTRUM()
{
    return getToken(VHDLParser::SPECTRUM, 0);
}

std::vector<VHDLParser::Simple_expressionContext *> VHDLParser::Source_aspectContext::simple_expression()
{
    return getRuleContexts<VHDLParser::Simple_expressionContext>();
}

VHDLParser::Simple_expressionContext *VHDLParser::Source_aspectContext::simple_expression(size_t i)
{
    return getRuleContext<VHDLParser::Simple_expressionContext>(i);
}

tree::TerminalNode *VHDLParser::Source_aspectContext::COMMA()
{
    return getToken(VHDLParser::COMMA, 0);
}

tree::TerminalNode *VHDLParser::Source_aspectContext::NOISE()
{
    return getToken(VHDLParser::NOISE, 0);
}

size_t VHDLParser::Source_aspectContext::getRuleIndex() const
{
    return VHDLParser::RuleSource_aspect;
}

void VHDLParser::Source_aspectContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSource_aspect(this);
}

void VHDLParser::Source_aspectContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSource_aspect(this);
}

std::any VHDLParser::Source_aspectContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSource_aspect(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Source_aspectContext *VHDLParser::source_aspect()
{
    Source_aspectContext *_localctx = _tracker.createInstance<Source_aspectContext>(_ctx, getState());
    enterRule(_localctx, 442, VHDLParser::RuleSource_aspect);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(2326);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::SPECTRUM: {
            enterOuterAlt(_localctx, 1);
            setState(2319);
            match(VHDLParser::SPECTRUM);
            setState(2320);
            simple_expression();
            setState(2321);
            match(VHDLParser::COMMA);
            setState(2322);
            simple_expression();
            break;
        }

        case VHDLParser::NOISE: {
            enterOuterAlt(_localctx, 2);
            setState(2324);
            match(VHDLParser::NOISE);
            setState(2325);
            simple_expression();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Source_quantity_declarationContext
//------------------------------------------------------------------

VHDLParser::Source_quantity_declarationContext::Source_quantity_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Source_quantity_declarationContext::QUANTITY()
{
    return getToken(VHDLParser::QUANTITY, 0);
}

VHDLParser::Identifier_listContext *VHDLParser::Source_quantity_declarationContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Source_quantity_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Source_quantity_declarationContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

VHDLParser::Source_aspectContext *VHDLParser::Source_quantity_declarationContext::source_aspect()
{
    return getRuleContext<VHDLParser::Source_aspectContext>(0);
}

tree::TerminalNode *VHDLParser::Source_quantity_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Source_quantity_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleSource_quantity_declaration;
}

void VHDLParser::Source_quantity_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSource_quantity_declaration(this);
}

void VHDLParser::Source_quantity_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSource_quantity_declaration(this);
}

std::any VHDLParser::Source_quantity_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSource_quantity_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Source_quantity_declarationContext *VHDLParser::source_quantity_declaration()
{
    Source_quantity_declarationContext *_localctx = _tracker.createInstance<Source_quantity_declarationContext>(_ctx, getState());
    enterRule(_localctx, 444, VHDLParser::RuleSource_quantity_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2328);
        match(VHDLParser::QUANTITY);
        setState(2329);
        identifier_list();
        setState(2330);
        match(VHDLParser::COLON);
        setState(2331);
        subtype_indication();
        setState(2332);
        source_aspect();
        setState(2333);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Step_limit_specificationContext
//------------------------------------------------------------------

VHDLParser::Step_limit_specificationContext::Step_limit_specificationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Step_limit_specificationContext::LIMIT()
{
    return getToken(VHDLParser::LIMIT, 0);
}

VHDLParser::Quantity_specificationContext *VHDLParser::Step_limit_specificationContext::quantity_specification()
{
    return getRuleContext<VHDLParser::Quantity_specificationContext>(0);
}

tree::TerminalNode *VHDLParser::Step_limit_specificationContext::WITH()
{
    return getToken(VHDLParser::WITH, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Step_limit_specificationContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

tree::TerminalNode *VHDLParser::Step_limit_specificationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Step_limit_specificationContext::getRuleIndex() const
{
    return VHDLParser::RuleStep_limit_specification;
}

void VHDLParser::Step_limit_specificationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterStep_limit_specification(this);
}

void VHDLParser::Step_limit_specificationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitStep_limit_specification(this);
}

std::any VHDLParser::Step_limit_specificationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitStep_limit_specification(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Step_limit_specificationContext *VHDLParser::step_limit_specification()
{
    Step_limit_specificationContext *_localctx = _tracker.createInstance<Step_limit_specificationContext>(_ctx, getState());
    enterRule(_localctx, 446, VHDLParser::RuleStep_limit_specification);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2335);
        match(VHDLParser::LIMIT);
        setState(2336);
        quantity_specification();
        setState(2337);
        match(VHDLParser::WITH);
        setState(2338);
        expression();
        setState(2339);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Subnature_declarationContext
//------------------------------------------------------------------

VHDLParser::Subnature_declarationContext::Subnature_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Subnature_declarationContext::SUBNATURE()
{
    return getToken(VHDLParser::SUBNATURE, 0);
}

VHDLParser::IdentifierContext *VHDLParser::Subnature_declarationContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Subnature_declarationContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::Subnature_indicationContext *VHDLParser::Subnature_declarationContext::subnature_indication()
{
    return getRuleContext<VHDLParser::Subnature_indicationContext>(0);
}

tree::TerminalNode *VHDLParser::Subnature_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Subnature_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleSubnature_declaration;
}

void VHDLParser::Subnature_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSubnature_declaration(this);
}

void VHDLParser::Subnature_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSubnature_declaration(this);
}

std::any VHDLParser::Subnature_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSubnature_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Subnature_declarationContext *VHDLParser::subnature_declaration()
{
    Subnature_declarationContext *_localctx = _tracker.createInstance<Subnature_declarationContext>(_ctx, getState());
    enterRule(_localctx, 448, VHDLParser::RuleSubnature_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2341);
        match(VHDLParser::SUBNATURE);
        setState(2342);
        identifier();
        setState(2343);
        match(VHDLParser::IS);
        setState(2344);
        subnature_indication();
        setState(2345);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Subnature_indicationContext
//------------------------------------------------------------------

VHDLParser::Subnature_indicationContext::Subnature_indicationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::NameContext *VHDLParser::Subnature_indicationContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

VHDLParser::Index_constraintContext *VHDLParser::Subnature_indicationContext::index_constraint()
{
    return getRuleContext<VHDLParser::Index_constraintContext>(0);
}

tree::TerminalNode *VHDLParser::Subnature_indicationContext::TOLERANCE()
{
    return getToken(VHDLParser::TOLERANCE, 0);
}

std::vector<VHDLParser::ExpressionContext *> VHDLParser::Subnature_indicationContext::expression()
{
    return getRuleContexts<VHDLParser::ExpressionContext>();
}

VHDLParser::ExpressionContext *VHDLParser::Subnature_indicationContext::expression(size_t i)
{
    return getRuleContext<VHDLParser::ExpressionContext>(i);
}

tree::TerminalNode *VHDLParser::Subnature_indicationContext::ACROSS()
{
    return getToken(VHDLParser::ACROSS, 0);
}

tree::TerminalNode *VHDLParser::Subnature_indicationContext::THROUGH()
{
    return getToken(VHDLParser::THROUGH, 0);
}

size_t VHDLParser::Subnature_indicationContext::getRuleIndex() const
{
    return VHDLParser::RuleSubnature_indication;
}

void VHDLParser::Subnature_indicationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSubnature_indication(this);
}

void VHDLParser::Subnature_indicationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSubnature_indication(this);
}

std::any VHDLParser::Subnature_indicationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSubnature_indication(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Subnature_indicationContext *VHDLParser::subnature_indication()
{
    Subnature_indicationContext *_localctx = _tracker.createInstance<Subnature_indicationContext>(_ctx, getState());
    enterRule(_localctx, 450, VHDLParser::RuleSubnature_indication);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2347);
        name();
        setState(2349);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::LPAREN)
        {
            setState(2348);
            index_constraint();
        }
        setState(2357);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::TOLERANCE)
        {
            setState(2351);
            match(VHDLParser::TOLERANCE);
            setState(2352);
            expression();
            setState(2353);
            match(VHDLParser::ACROSS);
            setState(2354);
            expression();
            setState(2355);
            match(VHDLParser::THROUGH);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Subprogram_bodyContext
//------------------------------------------------------------------

VHDLParser::Subprogram_bodyContext::Subprogram_bodyContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Subprogram_specificationContext *VHDLParser::Subprogram_bodyContext::subprogram_specification()
{
    return getRuleContext<VHDLParser::Subprogram_specificationContext>(0);
}

tree::TerminalNode *VHDLParser::Subprogram_bodyContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::Subprogram_declarative_partContext *VHDLParser::Subprogram_bodyContext::subprogram_declarative_part()
{
    return getRuleContext<VHDLParser::Subprogram_declarative_partContext>(0);
}

tree::TerminalNode *VHDLParser::Subprogram_bodyContext::BEGIN()
{
    return getToken(VHDLParser::BEGIN, 0);
}

VHDLParser::Subprogram_statement_partContext *VHDLParser::Subprogram_bodyContext::subprogram_statement_part()
{
    return getRuleContext<VHDLParser::Subprogram_statement_partContext>(0);
}

tree::TerminalNode *VHDLParser::Subprogram_bodyContext::END()
{
    return getToken(VHDLParser::END, 0);
}

tree::TerminalNode *VHDLParser::Subprogram_bodyContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Subprogram_kindContext *VHDLParser::Subprogram_bodyContext::subprogram_kind()
{
    return getRuleContext<VHDLParser::Subprogram_kindContext>(0);
}

VHDLParser::DesignatorContext *VHDLParser::Subprogram_bodyContext::designator()
{
    return getRuleContext<VHDLParser::DesignatorContext>(0);
}

size_t VHDLParser::Subprogram_bodyContext::getRuleIndex() const
{
    return VHDLParser::RuleSubprogram_body;
}

void VHDLParser::Subprogram_bodyContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSubprogram_body(this);
}

void VHDLParser::Subprogram_bodyContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSubprogram_body(this);
}

std::any VHDLParser::Subprogram_bodyContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSubprogram_body(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Subprogram_bodyContext *VHDLParser::subprogram_body()
{
    Subprogram_bodyContext *_localctx = _tracker.createInstance<Subprogram_bodyContext>(_ctx, getState());
    enterRule(_localctx, 452, VHDLParser::RuleSubprogram_body);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2359);
        subprogram_specification();
        setState(2360);
        match(VHDLParser::IS);
        setState(2361);
        subprogram_declarative_part();
        setState(2362);
        match(VHDLParser::BEGIN);
        setState(2363);
        subprogram_statement_part();
        setState(2364);
        match(VHDLParser::END);
        setState(2366);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::FUNCTION

            || _la == VHDLParser::PROCEDURE)
        {
            setState(2365);
            subprogram_kind();
        }
        setState(2369);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 118) & ~0x3fULL) == 0) && ((1ULL << (_la - 118)) & 515) != 0))
        {
            setState(2368);
            designator();
        }
        setState(2371);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Subprogram_declarationContext
//------------------------------------------------------------------

VHDLParser::Subprogram_declarationContext::Subprogram_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Subprogram_specificationContext *VHDLParser::Subprogram_declarationContext::subprogram_specification()
{
    return getRuleContext<VHDLParser::Subprogram_specificationContext>(0);
}

tree::TerminalNode *VHDLParser::Subprogram_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Subprogram_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleSubprogram_declaration;
}

void VHDLParser::Subprogram_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSubprogram_declaration(this);
}

void VHDLParser::Subprogram_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSubprogram_declaration(this);
}

std::any VHDLParser::Subprogram_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSubprogram_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Subprogram_declarationContext *VHDLParser::subprogram_declaration()
{
    Subprogram_declarationContext *_localctx = _tracker.createInstance<Subprogram_declarationContext>(_ctx, getState());
    enterRule(_localctx, 454, VHDLParser::RuleSubprogram_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2373);
        subprogram_specification();
        setState(2374);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Subprogram_declarative_itemContext
//------------------------------------------------------------------

VHDLParser::Subprogram_declarative_itemContext::Subprogram_declarative_itemContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Subprogram_declarationContext *VHDLParser::Subprogram_declarative_itemContext::subprogram_declaration()
{
    return getRuleContext<VHDLParser::Subprogram_declarationContext>(0);
}

VHDLParser::Subprogram_bodyContext *VHDLParser::Subprogram_declarative_itemContext::subprogram_body()
{
    return getRuleContext<VHDLParser::Subprogram_bodyContext>(0);
}

VHDLParser::Type_declarationContext *VHDLParser::Subprogram_declarative_itemContext::type_declaration()
{
    return getRuleContext<VHDLParser::Type_declarationContext>(0);
}

VHDLParser::Subtype_declarationContext *VHDLParser::Subprogram_declarative_itemContext::subtype_declaration()
{
    return getRuleContext<VHDLParser::Subtype_declarationContext>(0);
}

VHDLParser::Constant_declarationContext *VHDLParser::Subprogram_declarative_itemContext::constant_declaration()
{
    return getRuleContext<VHDLParser::Constant_declarationContext>(0);
}

VHDLParser::Variable_declarationContext *VHDLParser::Subprogram_declarative_itemContext::variable_declaration()
{
    return getRuleContext<VHDLParser::Variable_declarationContext>(0);
}

VHDLParser::File_declarationContext *VHDLParser::Subprogram_declarative_itemContext::file_declaration()
{
    return getRuleContext<VHDLParser::File_declarationContext>(0);
}

VHDLParser::Alias_declarationContext *VHDLParser::Subprogram_declarative_itemContext::alias_declaration()
{
    return getRuleContext<VHDLParser::Alias_declarationContext>(0);
}

VHDLParser::Attribute_declarationContext *VHDLParser::Subprogram_declarative_itemContext::attribute_declaration()
{
    return getRuleContext<VHDLParser::Attribute_declarationContext>(0);
}

VHDLParser::Attribute_specificationContext *VHDLParser::Subprogram_declarative_itemContext::attribute_specification()
{
    return getRuleContext<VHDLParser::Attribute_specificationContext>(0);
}

VHDLParser::Use_clauseContext *VHDLParser::Subprogram_declarative_itemContext::use_clause()
{
    return getRuleContext<VHDLParser::Use_clauseContext>(0);
}

VHDLParser::Group_template_declarationContext *VHDLParser::Subprogram_declarative_itemContext::group_template_declaration()
{
    return getRuleContext<VHDLParser::Group_template_declarationContext>(0);
}

VHDLParser::Group_declarationContext *VHDLParser::Subprogram_declarative_itemContext::group_declaration()
{
    return getRuleContext<VHDLParser::Group_declarationContext>(0);
}

size_t VHDLParser::Subprogram_declarative_itemContext::getRuleIndex() const
{
    return VHDLParser::RuleSubprogram_declarative_item;
}

void VHDLParser::Subprogram_declarative_itemContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSubprogram_declarative_item(this);
}

void VHDLParser::Subprogram_declarative_itemContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSubprogram_declarative_item(this);
}

std::any VHDLParser::Subprogram_declarative_itemContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSubprogram_declarative_item(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Subprogram_declarative_itemContext *VHDLParser::subprogram_declarative_item()
{
    Subprogram_declarative_itemContext *_localctx = _tracker.createInstance<Subprogram_declarative_itemContext>(_ctx, getState());
    enterRule(_localctx, 456, VHDLParser::RuleSubprogram_declarative_item);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(2389);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 263, _ctx))
        {
        case 1: {
            enterOuterAlt(_localctx, 1);
            setState(2376);
            subprogram_declaration();
            break;
        }

        case 2: {
            enterOuterAlt(_localctx, 2);
            setState(2377);
            subprogram_body();
            break;
        }

        case 3: {
            enterOuterAlt(_localctx, 3);
            setState(2378);
            type_declaration();
            break;
        }

        case 4: {
            enterOuterAlt(_localctx, 4);
            setState(2379);
            subtype_declaration();
            break;
        }

        case 5: {
            enterOuterAlt(_localctx, 5);
            setState(2380);
            constant_declaration();
            break;
        }

        case 6: {
            enterOuterAlt(_localctx, 6);
            setState(2381);
            variable_declaration();
            break;
        }

        case 7: {
            enterOuterAlt(_localctx, 7);
            setState(2382);
            file_declaration();
            break;
        }

        case 8: {
            enterOuterAlt(_localctx, 8);
            setState(2383);
            alias_declaration();
            break;
        }

        case 9: {
            enterOuterAlt(_localctx, 9);
            setState(2384);
            attribute_declaration();
            break;
        }

        case 10: {
            enterOuterAlt(_localctx, 10);
            setState(2385);
            attribute_specification();
            break;
        }

        case 11: {
            enterOuterAlt(_localctx, 11);
            setState(2386);
            use_clause();
            break;
        }

        case 12: {
            enterOuterAlt(_localctx, 12);
            setState(2387);
            group_template_declaration();
            break;
        }

        case 13: {
            enterOuterAlt(_localctx, 13);
            setState(2388);
            group_declaration();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Subprogram_declarative_partContext
//------------------------------------------------------------------

VHDLParser::Subprogram_declarative_partContext::Subprogram_declarative_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Subprogram_declarative_itemContext *> VHDLParser::Subprogram_declarative_partContext::subprogram_declarative_item()
{
    return getRuleContexts<VHDLParser::Subprogram_declarative_itemContext>();
}

VHDLParser::Subprogram_declarative_itemContext *VHDLParser::Subprogram_declarative_partContext::subprogram_declarative_item(size_t i)
{
    return getRuleContext<VHDLParser::Subprogram_declarative_itemContext>(i);
}

size_t VHDLParser::Subprogram_declarative_partContext::getRuleIndex() const
{
    return VHDLParser::RuleSubprogram_declarative_part;
}

void VHDLParser::Subprogram_declarative_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSubprogram_declarative_part(this);
}

void VHDLParser::Subprogram_declarative_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSubprogram_declarative_part(this);
}

std::any VHDLParser::Subprogram_declarative_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSubprogram_declarative_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Subprogram_declarative_partContext *VHDLParser::subprogram_declarative_part()
{
    Subprogram_declarative_partContext *_localctx = _tracker.createInstance<Subprogram_declarative_partContext>(_ctx, getState());
    enterRule(_localctx, 458, VHDLParser::RuleSubprogram_declarative_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2394);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 157305276448) != 0) || ((((_la - 68) & ~0x3fULL) == 0) && ((1ULL << (_la - 68)) & 210487083013) != 0))
        {
            setState(2391);
            subprogram_declarative_item();
            setState(2396);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Subprogram_kindContext
//------------------------------------------------------------------

VHDLParser::Subprogram_kindContext::Subprogram_kindContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Subprogram_kindContext::PROCEDURE()
{
    return getToken(VHDLParser::PROCEDURE, 0);
}

tree::TerminalNode *VHDLParser::Subprogram_kindContext::FUNCTION()
{
    return getToken(VHDLParser::FUNCTION, 0);
}

size_t VHDLParser::Subprogram_kindContext::getRuleIndex() const
{
    return VHDLParser::RuleSubprogram_kind;
}

void VHDLParser::Subprogram_kindContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSubprogram_kind(this);
}

void VHDLParser::Subprogram_kindContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSubprogram_kind(this);
}

std::any VHDLParser::Subprogram_kindContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSubprogram_kind(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Subprogram_kindContext *VHDLParser::subprogram_kind()
{
    Subprogram_kindContext *_localctx = _tracker.createInstance<Subprogram_kindContext>(_ctx, getState());
    enterRule(_localctx, 460, VHDLParser::RuleSubprogram_kind);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2397);
        _la = _input->LA(1);
        if (!(_la == VHDLParser::FUNCTION

              || _la == VHDLParser::PROCEDURE))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Subprogram_specificationContext
//------------------------------------------------------------------

VHDLParser::Subprogram_specificationContext::Subprogram_specificationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Procedure_specificationContext *VHDLParser::Subprogram_specificationContext::procedure_specification()
{
    return getRuleContext<VHDLParser::Procedure_specificationContext>(0);
}

VHDLParser::Function_specificationContext *VHDLParser::Subprogram_specificationContext::function_specification()
{
    return getRuleContext<VHDLParser::Function_specificationContext>(0);
}

size_t VHDLParser::Subprogram_specificationContext::getRuleIndex() const
{
    return VHDLParser::RuleSubprogram_specification;
}

void VHDLParser::Subprogram_specificationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSubprogram_specification(this);
}

void VHDLParser::Subprogram_specificationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSubprogram_specification(this);
}

std::any VHDLParser::Subprogram_specificationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSubprogram_specification(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Subprogram_specificationContext *VHDLParser::subprogram_specification()
{
    Subprogram_specificationContext *_localctx = _tracker.createInstance<Subprogram_specificationContext>(_ctx, getState());
    enterRule(_localctx, 462, VHDLParser::RuleSubprogram_specification);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(2401);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::PROCEDURE: {
            enterOuterAlt(_localctx, 1);
            setState(2399);
            procedure_specification();
            break;
        }

        case VHDLParser::FUNCTION:
        case VHDLParser::IMPURE:
        case VHDLParser::PURE: {
            enterOuterAlt(_localctx, 2);
            setState(2400);
            function_specification();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Procedure_specificationContext
//------------------------------------------------------------------

VHDLParser::Procedure_specificationContext::Procedure_specificationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Procedure_specificationContext::PROCEDURE()
{
    return getToken(VHDLParser::PROCEDURE, 0);
}

VHDLParser::DesignatorContext *VHDLParser::Procedure_specificationContext::designator()
{
    return getRuleContext<VHDLParser::DesignatorContext>(0);
}

tree::TerminalNode *VHDLParser::Procedure_specificationContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::Formal_parameter_listContext *VHDLParser::Procedure_specificationContext::formal_parameter_list()
{
    return getRuleContext<VHDLParser::Formal_parameter_listContext>(0);
}

tree::TerminalNode *VHDLParser::Procedure_specificationContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

size_t VHDLParser::Procedure_specificationContext::getRuleIndex() const
{
    return VHDLParser::RuleProcedure_specification;
}

void VHDLParser::Procedure_specificationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterProcedure_specification(this);
}

void VHDLParser::Procedure_specificationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitProcedure_specification(this);
}

std::any VHDLParser::Procedure_specificationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitProcedure_specification(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Procedure_specificationContext *VHDLParser::procedure_specification()
{
    Procedure_specificationContext *_localctx = _tracker.createInstance<Procedure_specificationContext>(_ctx, getState());
    enterRule(_localctx, 464, VHDLParser::RuleProcedure_specification);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2403);
        match(VHDLParser::PROCEDURE);
        setState(2404);
        designator();
        setState(2409);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::LPAREN)
        {
            setState(2405);
            match(VHDLParser::LPAREN);
            setState(2406);
            formal_parameter_list();
            setState(2407);
            match(VHDLParser::RPAREN);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Function_specificationContext
//------------------------------------------------------------------

VHDLParser::Function_specificationContext::Function_specificationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Function_specificationContext::FUNCTION()
{
    return getToken(VHDLParser::FUNCTION, 0);
}

VHDLParser::DesignatorContext *VHDLParser::Function_specificationContext::designator()
{
    return getRuleContext<VHDLParser::DesignatorContext>(0);
}

tree::TerminalNode *VHDLParser::Function_specificationContext::RETURN()
{
    return getToken(VHDLParser::RETURN, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Function_specificationContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

tree::TerminalNode *VHDLParser::Function_specificationContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

VHDLParser::Formal_parameter_listContext *VHDLParser::Function_specificationContext::formal_parameter_list()
{
    return getRuleContext<VHDLParser::Formal_parameter_listContext>(0);
}

tree::TerminalNode *VHDLParser::Function_specificationContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

tree::TerminalNode *VHDLParser::Function_specificationContext::PURE()
{
    return getToken(VHDLParser::PURE, 0);
}

tree::TerminalNode *VHDLParser::Function_specificationContext::IMPURE()
{
    return getToken(VHDLParser::IMPURE, 0);
}

size_t VHDLParser::Function_specificationContext::getRuleIndex() const
{
    return VHDLParser::RuleFunction_specification;
}

void VHDLParser::Function_specificationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterFunction_specification(this);
}

void VHDLParser::Function_specificationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitFunction_specification(this);
}

std::any VHDLParser::Function_specificationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitFunction_specification(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Function_specificationContext *VHDLParser::function_specification()
{
    Function_specificationContext *_localctx = _tracker.createInstance<Function_specificationContext>(_ctx, getState());
    enterRule(_localctx, 466, VHDLParser::RuleFunction_specification);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2412);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::IMPURE

            || _la == VHDLParser::PURE)
        {
            setState(2411);
            _la = _input->LA(1);
            if (!(_la == VHDLParser::IMPURE

                  || _la == VHDLParser::PURE))
            {
                _errHandler->recoverInline(this);
            }
            else
            {
                _errHandler->reportMatch(this);
                consume();
            }
        }
        setState(2414);
        match(VHDLParser::FUNCTION);
        setState(2415);
        designator();
        setState(2420);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::LPAREN)
        {
            setState(2416);
            match(VHDLParser::LPAREN);
            setState(2417);
            formal_parameter_list();
            setState(2418);
            match(VHDLParser::RPAREN);
        }
        setState(2422);
        match(VHDLParser::RETURN);
        setState(2423);
        subtype_indication();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Subprogram_statement_partContext
//------------------------------------------------------------------

VHDLParser::Subprogram_statement_partContext::Subprogram_statement_partContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Sequential_statementContext *> VHDLParser::Subprogram_statement_partContext::sequential_statement()
{
    return getRuleContexts<VHDLParser::Sequential_statementContext>();
}

VHDLParser::Sequential_statementContext *VHDLParser::Subprogram_statement_partContext::sequential_statement(size_t i)
{
    return getRuleContext<VHDLParser::Sequential_statementContext>(i);
}

size_t VHDLParser::Subprogram_statement_partContext::getRuleIndex() const
{
    return VHDLParser::RuleSubprogram_statement_part;
}

void VHDLParser::Subprogram_statement_partContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSubprogram_statement_part(this);
}

void VHDLParser::Subprogram_statement_partContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSubprogram_statement_part(this);
}

std::any VHDLParser::Subprogram_statement_partContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSubprogram_statement_part(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Subprogram_statement_partContext *VHDLParser::subprogram_statement_part()
{
    Subprogram_statement_partContext *_localctx = _tracker.createInstance<Subprogram_statement_partContext>(_ctx, getState());
    enterRule(_localctx, 468, VHDLParser::RuleSubprogram_statement_part);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2428);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 153263194880902144) != 0) || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 4611969143879499779) != 0))
        {
            setState(2425);
            sequential_statement();
            setState(2430);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Subtype_declarationContext
//------------------------------------------------------------------

VHDLParser::Subtype_declarationContext::Subtype_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Subtype_declarationContext::SUBTYPE()
{
    return getToken(VHDLParser::SUBTYPE, 0);
}

VHDLParser::IdentifierContext *VHDLParser::Subtype_declarationContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Subtype_declarationContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Subtype_declarationContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

tree::TerminalNode *VHDLParser::Subtype_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Subtype_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleSubtype_declaration;
}

void VHDLParser::Subtype_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSubtype_declaration(this);
}

void VHDLParser::Subtype_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSubtype_declaration(this);
}

std::any VHDLParser::Subtype_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSubtype_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Subtype_declarationContext *VHDLParser::subtype_declaration()
{
    Subtype_declarationContext *_localctx = _tracker.createInstance<Subtype_declarationContext>(_ctx, getState());
    enterRule(_localctx, 470, VHDLParser::RuleSubtype_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2431);
        match(VHDLParser::SUBTYPE);
        setState(2432);
        identifier();
        setState(2433);
        match(VHDLParser::IS);
        setState(2434);
        subtype_indication();
        setState(2435);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Subtype_indicationContext
//------------------------------------------------------------------

VHDLParser::Subtype_indicationContext::Subtype_indicationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Selected_nameContext *> VHDLParser::Subtype_indicationContext::selected_name()
{
    return getRuleContexts<VHDLParser::Selected_nameContext>();
}

VHDLParser::Selected_nameContext *VHDLParser::Subtype_indicationContext::selected_name(size_t i)
{
    return getRuleContext<VHDLParser::Selected_nameContext>(i);
}

VHDLParser::ConstraintContext *VHDLParser::Subtype_indicationContext::constraint()
{
    return getRuleContext<VHDLParser::ConstraintContext>(0);
}

VHDLParser::Tolerance_aspectContext *VHDLParser::Subtype_indicationContext::tolerance_aspect()
{
    return getRuleContext<VHDLParser::Tolerance_aspectContext>(0);
}

size_t VHDLParser::Subtype_indicationContext::getRuleIndex() const
{
    return VHDLParser::RuleSubtype_indication;
}

void VHDLParser::Subtype_indicationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSubtype_indication(this);
}

void VHDLParser::Subtype_indicationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSubtype_indication(this);
}

std::any VHDLParser::Subtype_indicationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSubtype_indication(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Subtype_indicationContext *VHDLParser::subtype_indication()
{
    Subtype_indicationContext *_localctx = _tracker.createInstance<Subtype_indicationContext>(_ctx, getState());
    enterRule(_localctx, 472, VHDLParser::RuleSubtype_indication);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2437);
        selected_name();
        setState(2439);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(2438);
            selected_name();
        }
        setState(2442);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::RANGE || _la == VHDLParser::LPAREN)
        {
            setState(2441);
            constraint();
        }
        setState(2445);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 272, _ctx))
        {
        case 1: {
            setState(2444);
            tolerance_aspect();
            break;
        }

        default:
            break;
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SuffixContext
//------------------------------------------------------------------

VHDLParser::SuffixContext::SuffixContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::IdentifierContext *VHDLParser::SuffixContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::SuffixContext::CHARACTER_LITERAL()
{
    return getToken(VHDLParser::CHARACTER_LITERAL, 0);
}

tree::TerminalNode *VHDLParser::SuffixContext::STRING_LITERAL()
{
    return getToken(VHDLParser::STRING_LITERAL, 0);
}

tree::TerminalNode *VHDLParser::SuffixContext::ALL()
{
    return getToken(VHDLParser::ALL, 0);
}

size_t VHDLParser::SuffixContext::getRuleIndex() const
{
    return VHDLParser::RuleSuffix;
}

void VHDLParser::SuffixContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterSuffix(this);
}

void VHDLParser::SuffixContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitSuffix(this);
}

std::any VHDLParser::SuffixContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitSuffix(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::SuffixContext *VHDLParser::suffix()
{
    SuffixContext *_localctx = _tracker.createInstance<SuffixContext>(_ctx, getState());
    enterRule(_localctx, 474, VHDLParser::RuleSuffix);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(2451);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER: {
            enterOuterAlt(_localctx, 1);
            setState(2447);
            identifier();
            break;
        }

        case VHDLParser::CHARACTER_LITERAL: {
            enterOuterAlt(_localctx, 2);
            setState(2448);
            match(VHDLParser::CHARACTER_LITERAL);
            break;
        }

        case VHDLParser::STRING_LITERAL: {
            enterOuterAlt(_localctx, 3);
            setState(2449);
            match(VHDLParser::STRING_LITERAL);
            break;
        }

        case VHDLParser::ALL: {
            enterOuterAlt(_localctx, 4);
            setState(2450);
            match(VHDLParser::ALL);
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- TargetContext
//------------------------------------------------------------------

VHDLParser::TargetContext::TargetContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::NameContext *VHDLParser::TargetContext::name()
{
    return getRuleContext<VHDLParser::NameContext>(0);
}

VHDLParser::AggregateContext *VHDLParser::TargetContext::aggregate()
{
    return getRuleContext<VHDLParser::AggregateContext>(0);
}

size_t VHDLParser::TargetContext::getRuleIndex() const
{
    return VHDLParser::RuleTarget;
}

void VHDLParser::TargetContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterTarget(this);
}

void VHDLParser::TargetContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitTarget(this);
}

std::any VHDLParser::TargetContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitTarget(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::TargetContext *VHDLParser::target()
{
    TargetContext *_localctx = _tracker.createInstance<TargetContext>(_ctx, getState());
    enterRule(_localctx, 476, VHDLParser::RuleTarget);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(2455);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER:
        case VHDLParser::STRING_LITERAL: {
            enterOuterAlt(_localctx, 1);
            setState(2453);
            name();
            break;
        }

        case VHDLParser::LPAREN: {
            enterOuterAlt(_localctx, 2);
            setState(2454);
            aggregate();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- TermContext
//------------------------------------------------------------------

VHDLParser::TermContext::TermContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::FactorContext *> VHDLParser::TermContext::factor()
{
    return getRuleContexts<VHDLParser::FactorContext>();
}

VHDLParser::FactorContext *VHDLParser::TermContext::factor(size_t i)
{
    return getRuleContext<VHDLParser::FactorContext>(i);
}

std::vector<VHDLParser::Multiplying_operatorContext *> VHDLParser::TermContext::multiplying_operator()
{
    return getRuleContexts<VHDLParser::Multiplying_operatorContext>();
}

VHDLParser::Multiplying_operatorContext *VHDLParser::TermContext::multiplying_operator(size_t i)
{
    return getRuleContext<VHDLParser::Multiplying_operatorContext>(i);
}

size_t VHDLParser::TermContext::getRuleIndex() const
{
    return VHDLParser::RuleTerm;
}

void VHDLParser::TermContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterTerm(this);
}

void VHDLParser::TermContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitTerm(this);
}

std::any VHDLParser::TermContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitTerm(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::TermContext *VHDLParser::term()
{
    TermContext *_localctx = _tracker.createInstance<TermContext>(_ctx, getState());
    enterRule(_localctx, 478, VHDLParser::RuleTerm);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(2457);
        factor();
        setState(2463);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 275, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(2458);
                multiplying_operator();
                setState(2459);
                factor();
            }
            setState(2465);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 275, _ctx);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Terminal_aspectContext
//------------------------------------------------------------------

VHDLParser::Terminal_aspectContext::Terminal_aspectContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::NameContext *> VHDLParser::Terminal_aspectContext::name()
{
    return getRuleContexts<VHDLParser::NameContext>();
}

VHDLParser::NameContext *VHDLParser::Terminal_aspectContext::name(size_t i)
{
    return getRuleContext<VHDLParser::NameContext>(i);
}

tree::TerminalNode *VHDLParser::Terminal_aspectContext::TO()
{
    return getToken(VHDLParser::TO, 0);
}

size_t VHDLParser::Terminal_aspectContext::getRuleIndex() const
{
    return VHDLParser::RuleTerminal_aspect;
}

void VHDLParser::Terminal_aspectContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterTerminal_aspect(this);
}

void VHDLParser::Terminal_aspectContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitTerminal_aspect(this);
}

std::any VHDLParser::Terminal_aspectContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitTerminal_aspect(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Terminal_aspectContext *VHDLParser::terminal_aspect()
{
    Terminal_aspectContext *_localctx = _tracker.createInstance<Terminal_aspectContext>(_ctx, getState());
    enterRule(_localctx, 480, VHDLParser::RuleTerminal_aspect);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2466);
        name();
        setState(2469);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::TO)
        {
            setState(2467);
            match(VHDLParser::TO);
            setState(2468);
            name();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Terminal_declarationContext
//------------------------------------------------------------------

VHDLParser::Terminal_declarationContext::Terminal_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Terminal_declarationContext::TERMINAL()
{
    return getToken(VHDLParser::TERMINAL, 0);
}

VHDLParser::Identifier_listContext *VHDLParser::Terminal_declarationContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Terminal_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Subnature_indicationContext *VHDLParser::Terminal_declarationContext::subnature_indication()
{
    return getRuleContext<VHDLParser::Subnature_indicationContext>(0);
}

tree::TerminalNode *VHDLParser::Terminal_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

size_t VHDLParser::Terminal_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleTerminal_declaration;
}

void VHDLParser::Terminal_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterTerminal_declaration(this);
}

void VHDLParser::Terminal_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitTerminal_declaration(this);
}

std::any VHDLParser::Terminal_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitTerminal_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Terminal_declarationContext *VHDLParser::terminal_declaration()
{
    Terminal_declarationContext *_localctx = _tracker.createInstance<Terminal_declarationContext>(_ctx, getState());
    enterRule(_localctx, 482, VHDLParser::RuleTerminal_declaration);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2471);
        match(VHDLParser::TERMINAL);
        setState(2472);
        identifier_list();
        setState(2473);
        match(VHDLParser::COLON);
        setState(2474);
        subnature_indication();
        setState(2475);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Through_aspectContext
//------------------------------------------------------------------

VHDLParser::Through_aspectContext::Through_aspectContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Identifier_listContext *VHDLParser::Through_aspectContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Through_aspectContext::THROUGH()
{
    return getToken(VHDLParser::THROUGH, 0);
}

VHDLParser::Tolerance_aspectContext *VHDLParser::Through_aspectContext::tolerance_aspect()
{
    return getRuleContext<VHDLParser::Tolerance_aspectContext>(0);
}

tree::TerminalNode *VHDLParser::Through_aspectContext::VARASGN()
{
    return getToken(VHDLParser::VARASGN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Through_aspectContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::Through_aspectContext::getRuleIndex() const
{
    return VHDLParser::RuleThrough_aspect;
}

void VHDLParser::Through_aspectContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterThrough_aspect(this);
}

void VHDLParser::Through_aspectContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitThrough_aspect(this);
}

std::any VHDLParser::Through_aspectContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitThrough_aspect(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Through_aspectContext *VHDLParser::through_aspect()
{
    Through_aspectContext *_localctx = _tracker.createInstance<Through_aspectContext>(_ctx, getState());
    enterRule(_localctx, 484, VHDLParser::RuleThrough_aspect);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2477);
        identifier_list();
        setState(2479);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::TOLERANCE)
        {
            setState(2478);
            tolerance_aspect();
        }
        setState(2483);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::VARASGN)
        {
            setState(2481);
            match(VHDLParser::VARASGN);
            setState(2482);
            expression();
        }
        setState(2485);
        match(VHDLParser::THROUGH);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Timeout_clauseContext
//------------------------------------------------------------------

VHDLParser::Timeout_clauseContext::Timeout_clauseContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Timeout_clauseContext::FOR()
{
    return getToken(VHDLParser::FOR, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Timeout_clauseContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::Timeout_clauseContext::getRuleIndex() const
{
    return VHDLParser::RuleTimeout_clause;
}

void VHDLParser::Timeout_clauseContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterTimeout_clause(this);
}

void VHDLParser::Timeout_clauseContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitTimeout_clause(this);
}

std::any VHDLParser::Timeout_clauseContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitTimeout_clause(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Timeout_clauseContext *VHDLParser::timeout_clause()
{
    Timeout_clauseContext *_localctx = _tracker.createInstance<Timeout_clauseContext>(_ctx, getState());
    enterRule(_localctx, 486, VHDLParser::RuleTimeout_clause);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2487);
        match(VHDLParser::FOR);
        setState(2488);
        expression();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Tolerance_aspectContext
//------------------------------------------------------------------

VHDLParser::Tolerance_aspectContext::Tolerance_aspectContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Tolerance_aspectContext::TOLERANCE()
{
    return getToken(VHDLParser::TOLERANCE, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Tolerance_aspectContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::Tolerance_aspectContext::getRuleIndex() const
{
    return VHDLParser::RuleTolerance_aspect;
}

void VHDLParser::Tolerance_aspectContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterTolerance_aspect(this);
}

void VHDLParser::Tolerance_aspectContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitTolerance_aspect(this);
}

std::any VHDLParser::Tolerance_aspectContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitTolerance_aspect(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Tolerance_aspectContext *VHDLParser::tolerance_aspect()
{
    Tolerance_aspectContext *_localctx = _tracker.createInstance<Tolerance_aspectContext>(_ctx, getState());
    enterRule(_localctx, 488, VHDLParser::RuleTolerance_aspect);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2490);
        match(VHDLParser::TOLERANCE);
        setState(2491);
        expression();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Type_declarationContext
//------------------------------------------------------------------

VHDLParser::Type_declarationContext::Type_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Type_declarationContext::TYPE()
{
    return getToken(VHDLParser::TYPE, 0);
}

VHDLParser::IdentifierContext *VHDLParser::Type_declarationContext::identifier()
{
    return getRuleContext<VHDLParser::IdentifierContext>(0);
}

tree::TerminalNode *VHDLParser::Type_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

tree::TerminalNode *VHDLParser::Type_declarationContext::IS()
{
    return getToken(VHDLParser::IS, 0);
}

VHDLParser::Type_definitionContext *VHDLParser::Type_declarationContext::type_definition()
{
    return getRuleContext<VHDLParser::Type_definitionContext>(0);
}

size_t VHDLParser::Type_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleType_declaration;
}

void VHDLParser::Type_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterType_declaration(this);
}

void VHDLParser::Type_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitType_declaration(this);
}

std::any VHDLParser::Type_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitType_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Type_declarationContext *VHDLParser::type_declaration()
{
    Type_declarationContext *_localctx = _tracker.createInstance<Type_declarationContext>(_ctx, getState());
    enterRule(_localctx, 490, VHDLParser::RuleType_declaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2493);
        match(VHDLParser::TYPE);
        setState(2494);
        identifier();
        setState(2497);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::IS)
        {
            setState(2495);
            match(VHDLParser::IS);
            setState(2496);
            type_definition();
        }
        setState(2499);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Type_definitionContext
//------------------------------------------------------------------

VHDLParser::Type_definitionContext::Type_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::Scalar_type_definitionContext *VHDLParser::Type_definitionContext::scalar_type_definition()
{
    return getRuleContext<VHDLParser::Scalar_type_definitionContext>(0);
}

VHDLParser::Composite_type_definitionContext *VHDLParser::Type_definitionContext::composite_type_definition()
{
    return getRuleContext<VHDLParser::Composite_type_definitionContext>(0);
}

VHDLParser::Access_type_definitionContext *VHDLParser::Type_definitionContext::access_type_definition()
{
    return getRuleContext<VHDLParser::Access_type_definitionContext>(0);
}

VHDLParser::File_type_definitionContext *VHDLParser::Type_definitionContext::file_type_definition()
{
    return getRuleContext<VHDLParser::File_type_definitionContext>(0);
}

size_t VHDLParser::Type_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleType_definition;
}

void VHDLParser::Type_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterType_definition(this);
}

void VHDLParser::Type_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitType_definition(this);
}

std::any VHDLParser::Type_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitType_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Type_definitionContext *VHDLParser::type_definition()
{
    Type_definitionContext *_localctx = _tracker.createInstance<Type_definitionContext>(_ctx, getState());
    enterRule(_localctx, 492, VHDLParser::RuleType_definition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(2505);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::RANGE:
        case VHDLParser::LPAREN: {
            enterOuterAlt(_localctx, 1);
            setState(2501);
            scalar_type_definition();
            break;
        }

        case VHDLParser::ARRAY:
        case VHDLParser::RECORD: {
            enterOuterAlt(_localctx, 2);
            setState(2502);
            composite_type_definition();
            break;
        }

        case VHDLParser::ACCESS: {
            enterOuterAlt(_localctx, 3);
            setState(2503);
            access_type_definition();
            break;
        }

        case VHDLParser::FILE: {
            enterOuterAlt(_localctx, 4);
            setState(2504);
            file_type_definition();
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Unconstrained_array_definitionContext
//------------------------------------------------------------------

VHDLParser::Unconstrained_array_definitionContext::Unconstrained_array_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Unconstrained_array_definitionContext::ARRAY()
{
    return getToken(VHDLParser::ARRAY, 0);
}

tree::TerminalNode *VHDLParser::Unconstrained_array_definitionContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

std::vector<VHDLParser::Index_subtype_definitionContext *> VHDLParser::Unconstrained_array_definitionContext::index_subtype_definition()
{
    return getRuleContexts<VHDLParser::Index_subtype_definitionContext>();
}

VHDLParser::Index_subtype_definitionContext *VHDLParser::Unconstrained_array_definitionContext::index_subtype_definition(size_t i)
{
    return getRuleContext<VHDLParser::Index_subtype_definitionContext>(i);
}

tree::TerminalNode *VHDLParser::Unconstrained_array_definitionContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

tree::TerminalNode *VHDLParser::Unconstrained_array_definitionContext::OF()
{
    return getToken(VHDLParser::OF, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Unconstrained_array_definitionContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

std::vector<tree::TerminalNode *> VHDLParser::Unconstrained_array_definitionContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Unconstrained_array_definitionContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

size_t VHDLParser::Unconstrained_array_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleUnconstrained_array_definition;
}

void VHDLParser::Unconstrained_array_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterUnconstrained_array_definition(this);
}

void VHDLParser::Unconstrained_array_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitUnconstrained_array_definition(this);
}

std::any VHDLParser::Unconstrained_array_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitUnconstrained_array_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Unconstrained_array_definitionContext *VHDLParser::unconstrained_array_definition()
{
    Unconstrained_array_definitionContext *_localctx = _tracker.createInstance<Unconstrained_array_definitionContext>(_ctx, getState());
    enterRule(_localctx, 494, VHDLParser::RuleUnconstrained_array_definition);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2507);
        match(VHDLParser::ARRAY);
        setState(2508);
        match(VHDLParser::LPAREN);
        setState(2509);
        index_subtype_definition();
        setState(2514);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::COMMA)
        {
            setState(2510);
            match(VHDLParser::COMMA);
            setState(2511);
            index_subtype_definition();
            setState(2516);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(2517);
        match(VHDLParser::RPAREN);
        setState(2518);
        match(VHDLParser::OF);
        setState(2519);
        subtype_indication();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Unconstrained_nature_definitionContext
//------------------------------------------------------------------

VHDLParser::Unconstrained_nature_definitionContext::Unconstrained_nature_definitionContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Unconstrained_nature_definitionContext::ARRAY()
{
    return getToken(VHDLParser::ARRAY, 0);
}

tree::TerminalNode *VHDLParser::Unconstrained_nature_definitionContext::LPAREN()
{
    return getToken(VHDLParser::LPAREN, 0);
}

std::vector<VHDLParser::Index_subtype_definitionContext *> VHDLParser::Unconstrained_nature_definitionContext::index_subtype_definition()
{
    return getRuleContexts<VHDLParser::Index_subtype_definitionContext>();
}

VHDLParser::Index_subtype_definitionContext *VHDLParser::Unconstrained_nature_definitionContext::index_subtype_definition(size_t i)
{
    return getRuleContext<VHDLParser::Index_subtype_definitionContext>(i);
}

tree::TerminalNode *VHDLParser::Unconstrained_nature_definitionContext::RPAREN()
{
    return getToken(VHDLParser::RPAREN, 0);
}

tree::TerminalNode *VHDLParser::Unconstrained_nature_definitionContext::OF()
{
    return getToken(VHDLParser::OF, 0);
}

VHDLParser::Subnature_indicationContext *VHDLParser::Unconstrained_nature_definitionContext::subnature_indication()
{
    return getRuleContext<VHDLParser::Subnature_indicationContext>(0);
}

std::vector<tree::TerminalNode *> VHDLParser::Unconstrained_nature_definitionContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Unconstrained_nature_definitionContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

size_t VHDLParser::Unconstrained_nature_definitionContext::getRuleIndex() const
{
    return VHDLParser::RuleUnconstrained_nature_definition;
}

void VHDLParser::Unconstrained_nature_definitionContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterUnconstrained_nature_definition(this);
}

void VHDLParser::Unconstrained_nature_definitionContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitUnconstrained_nature_definition(this);
}

std::any VHDLParser::Unconstrained_nature_definitionContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitUnconstrained_nature_definition(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Unconstrained_nature_definitionContext *VHDLParser::unconstrained_nature_definition()
{
    Unconstrained_nature_definitionContext *_localctx = _tracker.createInstance<Unconstrained_nature_definitionContext>(_ctx, getState());
    enterRule(_localctx, 496, VHDLParser::RuleUnconstrained_nature_definition);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2521);
        match(VHDLParser::ARRAY);
        setState(2522);
        match(VHDLParser::LPAREN);
        setState(2523);
        index_subtype_definition();
        setState(2528);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::COMMA)
        {
            setState(2524);
            match(VHDLParser::COMMA);
            setState(2525);
            index_subtype_definition();
            setState(2530);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(2531);
        match(VHDLParser::RPAREN);
        setState(2532);
        match(VHDLParser::OF);
        setState(2533);
        subnature_indication();
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Use_clauseContext
//------------------------------------------------------------------

VHDLParser::Use_clauseContext::Use_clauseContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Use_clauseContext::USE()
{
    return getToken(VHDLParser::USE, 0);
}

std::vector<VHDLParser::Selected_nameContext *> VHDLParser::Use_clauseContext::selected_name()
{
    return getRuleContexts<VHDLParser::Selected_nameContext>();
}

VHDLParser::Selected_nameContext *VHDLParser::Use_clauseContext::selected_name(size_t i)
{
    return getRuleContext<VHDLParser::Selected_nameContext>(i);
}

tree::TerminalNode *VHDLParser::Use_clauseContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

std::vector<tree::TerminalNode *> VHDLParser::Use_clauseContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::Use_clauseContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

size_t VHDLParser::Use_clauseContext::getRuleIndex() const
{
    return VHDLParser::RuleUse_clause;
}

void VHDLParser::Use_clauseContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterUse_clause(this);
}

void VHDLParser::Use_clauseContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitUse_clause(this);
}

std::any VHDLParser::Use_clauseContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitUse_clause(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Use_clauseContext *VHDLParser::use_clause()
{
    Use_clauseContext *_localctx = _tracker.createInstance<Use_clauseContext>(_ctx, getState());
    enterRule(_localctx, 498, VHDLParser::RuleUse_clause);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2535);
        match(VHDLParser::USE);
        setState(2536);
        selected_name();
        setState(2541);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VHDLParser::COMMA)
        {
            setState(2537);
            match(VHDLParser::COMMA);
            setState(2538);
            selected_name();
            setState(2543);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(2544);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Variable_assignment_statementContext
//------------------------------------------------------------------

VHDLParser::Variable_assignment_statementContext::Variable_assignment_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

VHDLParser::TargetContext *VHDLParser::Variable_assignment_statementContext::target()
{
    return getRuleContext<VHDLParser::TargetContext>(0);
}

tree::TerminalNode *VHDLParser::Variable_assignment_statementContext::VARASGN()
{
    return getToken(VHDLParser::VARASGN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Variable_assignment_statementContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

tree::TerminalNode *VHDLParser::Variable_assignment_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Variable_assignment_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

size_t VHDLParser::Variable_assignment_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleVariable_assignment_statement;
}

void VHDLParser::Variable_assignment_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterVariable_assignment_statement(this);
}

void VHDLParser::Variable_assignment_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitVariable_assignment_statement(this);
}

std::any VHDLParser::Variable_assignment_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitVariable_assignment_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Variable_assignment_statementContext *VHDLParser::variable_assignment_statement()
{
    Variable_assignment_statementContext *_localctx = _tracker.createInstance<Variable_assignment_statementContext>(_ctx, getState());
    enterRule(_localctx, 500, VHDLParser::RuleVariable_assignment_statement);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2547);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 284, _ctx))
        {
        case 1: {
            setState(2546);
            label_colon();
            break;
        }

        default:
            break;
        }
        setState(2549);
        target();
        setState(2550);
        match(VHDLParser::VARASGN);
        setState(2551);
        expression();
        setState(2552);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Variable_declarationContext
//------------------------------------------------------------------

VHDLParser::Variable_declarationContext::Variable_declarationContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Variable_declarationContext::VARIABLE()
{
    return getToken(VHDLParser::VARIABLE, 0);
}

VHDLParser::Identifier_listContext *VHDLParser::Variable_declarationContext::identifier_list()
{
    return getRuleContext<VHDLParser::Identifier_listContext>(0);
}

tree::TerminalNode *VHDLParser::Variable_declarationContext::COLON()
{
    return getToken(VHDLParser::COLON, 0);
}

VHDLParser::Subtype_indicationContext *VHDLParser::Variable_declarationContext::subtype_indication()
{
    return getRuleContext<VHDLParser::Subtype_indicationContext>(0);
}

tree::TerminalNode *VHDLParser::Variable_declarationContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

tree::TerminalNode *VHDLParser::Variable_declarationContext::SHARED()
{
    return getToken(VHDLParser::SHARED, 0);
}

tree::TerminalNode *VHDLParser::Variable_declarationContext::VARASGN()
{
    return getToken(VHDLParser::VARASGN, 0);
}

VHDLParser::ExpressionContext *VHDLParser::Variable_declarationContext::expression()
{
    return getRuleContext<VHDLParser::ExpressionContext>(0);
}

size_t VHDLParser::Variable_declarationContext::getRuleIndex() const
{
    return VHDLParser::RuleVariable_declaration;
}

void VHDLParser::Variable_declarationContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterVariable_declaration(this);
}

void VHDLParser::Variable_declarationContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitVariable_declaration(this);
}

std::any VHDLParser::Variable_declarationContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitVariable_declaration(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Variable_declarationContext *VHDLParser::variable_declaration()
{
    Variable_declarationContext *_localctx = _tracker.createInstance<Variable_declarationContext>(_ctx, getState());
    enterRule(_localctx, 502, VHDLParser::RuleVariable_declaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2555);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::SHARED)
        {
            setState(2554);
            match(VHDLParser::SHARED);
        }
        setState(2557);
        match(VHDLParser::VARIABLE);
        setState(2558);
        identifier_list();
        setState(2559);
        match(VHDLParser::COLON);
        setState(2560);
        subtype_indication();
        setState(2563);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::VARASGN)
        {
            setState(2561);
            match(VHDLParser::VARASGN);
            setState(2562);
            expression();
        }
        setState(2565);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Wait_statementContext
//------------------------------------------------------------------

VHDLParser::Wait_statementContext::Wait_statementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode *VHDLParser::Wait_statementContext::WAIT()
{
    return getToken(VHDLParser::WAIT, 0);
}

tree::TerminalNode *VHDLParser::Wait_statementContext::SEMI()
{
    return getToken(VHDLParser::SEMI, 0);
}

VHDLParser::Label_colonContext *VHDLParser::Wait_statementContext::label_colon()
{
    return getRuleContext<VHDLParser::Label_colonContext>(0);
}

VHDLParser::Sensitivity_clauseContext *VHDLParser::Wait_statementContext::sensitivity_clause()
{
    return getRuleContext<VHDLParser::Sensitivity_clauseContext>(0);
}

VHDLParser::Condition_clauseContext *VHDLParser::Wait_statementContext::condition_clause()
{
    return getRuleContext<VHDLParser::Condition_clauseContext>(0);
}

VHDLParser::Timeout_clauseContext *VHDLParser::Wait_statementContext::timeout_clause()
{
    return getRuleContext<VHDLParser::Timeout_clauseContext>(0);
}

size_t VHDLParser::Wait_statementContext::getRuleIndex() const
{
    return VHDLParser::RuleWait_statement;
}

void VHDLParser::Wait_statementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterWait_statement(this);
}

void VHDLParser::Wait_statementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitWait_statement(this);
}

std::any VHDLParser::Wait_statementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitWait_statement(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Wait_statementContext *VHDLParser::wait_statement()
{
    Wait_statementContext *_localctx = _tracker.createInstance<Wait_statementContext>(_ctx, getState());
    enterRule(_localctx, 504, VHDLParser::RuleWait_statement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2568);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::BASIC_IDENTIFIER

            || _la == VHDLParser::EXTENDED_IDENTIFIER)
        {
            setState(2567);
            label_colon();
        }
        setState(2570);
        match(VHDLParser::WAIT);
        setState(2572);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::ON)
        {
            setState(2571);
            sensitivity_clause();
        }
        setState(2575);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::UNTIL)
        {
            setState(2574);
            condition_clause();
        }
        setState(2578);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::FOR)
        {
            setState(2577);
            timeout_clause();
        }
        setState(2580);
        match(VHDLParser::SEMI);
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- WaveformContext
//------------------------------------------------------------------

VHDLParser::WaveformContext::WaveformContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::Waveform_elementContext *> VHDLParser::WaveformContext::waveform_element()
{
    return getRuleContexts<VHDLParser::Waveform_elementContext>();
}

VHDLParser::Waveform_elementContext *VHDLParser::WaveformContext::waveform_element(size_t i)
{
    return getRuleContext<VHDLParser::Waveform_elementContext>(i);
}

std::vector<tree::TerminalNode *> VHDLParser::WaveformContext::COMMA()
{
    return getTokens(VHDLParser::COMMA);
}

tree::TerminalNode *VHDLParser::WaveformContext::COMMA(size_t i)
{
    return getToken(VHDLParser::COMMA, i);
}

tree::TerminalNode *VHDLParser::WaveformContext::UNAFFECTED()
{
    return getToken(VHDLParser::UNAFFECTED, 0);
}

size_t VHDLParser::WaveformContext::getRuleIndex() const
{
    return VHDLParser::RuleWaveform;
}

void VHDLParser::WaveformContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterWaveform(this);
}

void VHDLParser::WaveformContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitWaveform(this);
}

std::any VHDLParser::WaveformContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitWaveform(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::WaveformContext *VHDLParser::waveform()
{
    WaveformContext *_localctx = _tracker.createInstance<WaveformContext>(_ctx, getState());
    enterRule(_localctx, 506, VHDLParser::RuleWaveform);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(2591);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
        case VHDLParser::ABS:
        case VHDLParser::NEW:
        case VHDLParser::NOT:
        case VHDLParser::NULL_:
        case VHDLParser::BASE_LITERAL:
        case VHDLParser::BIT_STRING_LITERAL:
        case VHDLParser::REAL_LITERAL:
        case VHDLParser::BASIC_IDENTIFIER:
        case VHDLParser::EXTENDED_IDENTIFIER:
        case VHDLParser::CHARACTER_LITERAL:
        case VHDLParser::STRING_LITERAL:
        case VHDLParser::LPAREN:
        case VHDLParser::PLUS:
        case VHDLParser::MINUS:
        case VHDLParser::INTEGER: {
            enterOuterAlt(_localctx, 1);
            setState(2582);
            waveform_element();
            setState(2587);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == VHDLParser::COMMA)
            {
                setState(2583);
                match(VHDLParser::COMMA);
                setState(2584);
                waveform_element();
                setState(2589);
                _errHandler->sync(this);
                _la = _input->LA(1);
            }
            break;
        }

        case VHDLParser::UNAFFECTED: {
            enterOuterAlt(_localctx, 2);
            setState(2590);
            match(VHDLParser::UNAFFECTED);
            break;
        }

        default:
            throw NoViableAltException(this);
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- Waveform_elementContext
//------------------------------------------------------------------

VHDLParser::Waveform_elementContext::Waveform_elementContext(ParserRuleContext *parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<VHDLParser::ExpressionContext *> VHDLParser::Waveform_elementContext::expression()
{
    return getRuleContexts<VHDLParser::ExpressionContext>();
}

VHDLParser::ExpressionContext *VHDLParser::Waveform_elementContext::expression(size_t i)
{
    return getRuleContext<VHDLParser::ExpressionContext>(i);
}

tree::TerminalNode *VHDLParser::Waveform_elementContext::AFTER()
{
    return getToken(VHDLParser::AFTER, 0);
}

size_t VHDLParser::Waveform_elementContext::getRuleIndex() const
{
    return VHDLParser::RuleWaveform_element;
}

void VHDLParser::Waveform_elementContext::enterRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->enterWaveform_element(this);
}

void VHDLParser::Waveform_elementContext::exitRule(tree::ParseTreeListener *listener)
{
    auto parserListener = dynamic_cast<VHDLListener *>(listener);
    if (parserListener != nullptr)
        parserListener->exitWaveform_element(this);
}

std::any VHDLParser::Waveform_elementContext::accept(tree::ParseTreeVisitor *visitor)
{
    if (auto parserVisitor = dynamic_cast<VHDLVisitor *>(visitor))
        return parserVisitor->visitWaveform_element(this);
    else
        return visitor->visitChildren(this);
}

VHDLParser::Waveform_elementContext *VHDLParser::waveform_element()
{
    Waveform_elementContext *_localctx = _tracker.createInstance<Waveform_elementContext>(_ctx, getState());
    enterRule(_localctx, 508, VHDLParser::RuleWaveform_element);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(2593);
        expression();
        setState(2596);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VHDLParser::AFTER)
        {
            setState(2594);
            match(VHDLParser::AFTER);
            setState(2595);
            expression();
        }
    }
    catch (RecognitionException &e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

void VHDLParser::initialize()
{
#if ANTLR4_USE_THREAD_LOCAL_CACHE
    vhdlParserInitialize();
#else
    ::antlr4::internal::call_once(vhdlParserOnceFlag, vhdlParserInitialize);
#endif
}
